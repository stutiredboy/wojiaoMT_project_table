/*
** Lua binding: engineWin32
*/

#ifndef __cplusplus
#include "stdlib.h"
#endif
#include "string.h"

#include "tolua++.h"

/* Exported function */
TOLUA_API int  tolua_engineWin32_open (lua_State* tolua_S);

#include "EngineLuaNeed.h"
#include "nuisprite.h"
#include "../../../../common/ljfm/code/include/ljfmfex.h"
#include "../../../../common/ljfm/code/include/ljfmopen.h"
#include "Utils/IOS_Utils.h"

/* function to release collected object via destructor */
#ifdef __cplusplus

static int tolua_collect_Nuclear__Cocos2dRenderer (lua_State* tolua_S)
{
 Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__Effect (lua_State* tolua_S)
{
 Nuclear::Effect* self = (Nuclear::Effect*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearTCVertex (lua_State* tolua_S)
{
 Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IEnv (lua_State* tolua_S)
{
 Nuclear::IEnv* self = (Nuclear::IEnv*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__EngineParameter (lua_State* tolua_S)
{
 Nuclear::EngineParameter* self = (Nuclear::EngineParameter*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ExecThread (lua_State* tolua_S)
{
 Nuclear::ExecThread* self = (Nuclear::ExecThread*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__Action (lua_State* tolua_S)
{
 Nuclear::Action* self = (Nuclear::Action*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IEngine (lua_State* tolua_S)
{
 Nuclear::IEngine* self = (Nuclear::IEngine*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_RECT (lua_State* tolua_S)
{
 RECT* self = (RECT*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__PSParameter (lua_State* tolua_S)
{
 Nuclear::PSParameter* self = (Nuclear::PSParameter*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__SpriteManager__Layer (lua_State* tolua_S)
{
 Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearFColor (lua_State* tolua_S)
{
 Nuclear::NuclearFColor* self = (Nuclear::NuclearFColor*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__AniManager (lua_State* tolua_S)
{
 Nuclear::AniManager* self = (Nuclear::AniManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IImmovableObj (lua_State* tolua_S)
{
 Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__Renderer (lua_State* tolua_S)
{
 Nuclear::Renderer* self = (Nuclear::Renderer*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__SystemResourceManager (lua_State* tolua_S)
{
 Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__INuclearTimer (lua_State* tolua_S)
{
 Nuclear::INuclearTimer* self = (Nuclear::INuclearTimer*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearPolygon (lua_State* tolua_S)
{
 Nuclear::NuclearPolygon* self = (Nuclear::NuclearPolygon*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearDisplayMode (lua_State* tolua_S)
{
 Nuclear::NuclearDisplayMode* self = (Nuclear::NuclearDisplayMode*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__INuclearRunnable (lua_State* tolua_S)
{
 Nuclear::INuclearRunnable* self = (Nuclear::INuclearRunnable*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearBase (lua_State* tolua_S)
{
 Nuclear::NuclearBase* self = (Nuclear::NuclearBase*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearEllipse (lua_State* tolua_S)
{
 Nuclear::NuclearEllipse* self = (Nuclear::NuclearEllipse*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearVector4 (lua_State* tolua_S)
{
 Nuclear::NuclearVector4* self = (Nuclear::NuclearVector4*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ConfigManager (lua_State* tolua_S)
{
 Nuclear::ConfigManager* self = (Nuclear::ConfigManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IParticleManager (lua_State* tolua_S)
{
 Nuclear::IParticleManager* self = (Nuclear::IParticleManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearCircle (lua_State* tolua_S)
{
 Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IWorld (lua_State* tolua_S)
{
 Nuclear::IWorld* self = (Nuclear::IWorld*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__INuclearFileIO (lua_State* tolua_S)
{
 Nuclear::INuclearFileIO* self = (Nuclear::INuclearFileIO*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__Renderable (lua_State* tolua_S)
{
 Nuclear::Renderable* self = (Nuclear::Renderable*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ActionType (lua_State* tolua_S)
{
 Nuclear::ActionType* self = (Nuclear::ActionType*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__Component (lua_State* tolua_S)
{
 Nuclear::Component* self = (Nuclear::Component*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS (lua_State* tolua_S)
{
 Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__EffectManager (lua_State* tolua_S)
{
 Nuclear::EffectManager* self = (Nuclear::EffectManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__PSINFO (lua_State* tolua_S)
{
 Nuclear::PSINFO* self = (Nuclear::PSINFO*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__XAni__XBigPic (lua_State* tolua_S)
{
 Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearVector3 (lua_State* tolua_S)
{
 Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__DrawBatchPictureParam (lua_State* tolua_S)
{
 Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_tm (lua_State* tolua_S)
{
 tm* self = (tm*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__GUObject (lua_State* tolua_S)
{
 Nuclear::GUObject* self = (Nuclear::GUObject*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearTCT1Vertex (lua_State* tolua_S)
{
 Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__SpriteManager (lua_State* tolua_S)
{
 Nuclear::SpriteManager* self = (Nuclear::SpriteManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearRect (lua_State* tolua_S)
{
 Nuclear::NuclearRect* self = (Nuclear::NuclearRect*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearMatrix3 (lua_State* tolua_S)
{
 Nuclear::NuclearMatrix3* self = (Nuclear::NuclearMatrix3*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__LINE (lua_State* tolua_S)
{
 Nuclear::LINE* self = (Nuclear::LINE*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearUTCT1Vertex (lua_State* tolua_S)
{
 Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__PSModifyParam (lua_State* tolua_S)
{
 Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearFileIOManager (lua_State* tolua_S)
{
 Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_FireNet__Octets (lua_State* tolua_S)
{
 FireNet::Octets* self = (FireNet::Octets*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ParticleEffect (lua_State* tolua_S)
{
 Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_LJFM__LJFMIF (lua_State* tolua_S)
{
 LJFM::LJFMIF* self = (LJFM::LJFMIF*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearBuffer (lua_State* tolua_S)
{
 Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_LJFM__LJFMFS (lua_State* tolua_S)
{
 LJFM::LJFMFS* self = (LJFM::LJFMFS*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearBufferOctets (lua_State* tolua_S)
{
 Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ModelSoundParam (lua_State* tolua_S)
{
 Nuclear::ModelSoundParam* self = (Nuclear::ModelSoundParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearFPoint (lua_State* tolua_S)
{
 Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearOctets (lua_State* tolua_S)
{
 Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IFontManager (lua_State* tolua_S)
{
 Nuclear::IFontManager* self = (Nuclear::IFontManager*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearPictureInfo (lua_State* tolua_S)
{
 Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearPoint (lua_State* tolua_S)
{
 Nuclear::NuclearPoint* self = (Nuclear::NuclearPoint*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ExecThread__Task (lua_State* tolua_S)
{
 Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__DrawPictureParam (lua_State* tolua_S)
{
 Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__DrawElement (lua_State* tolua_S)
{
 Nuclear::DrawElement* self = (Nuclear::DrawElement*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_LJFM__LJFMF (lua_State* tolua_S)
{
 LJFM::LJFMF* self = (LJFM::LJFMF*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ISprite (lua_State* tolua_S)
{
 Nuclear::ISprite* self = (Nuclear::ISprite*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__INuclearShape (lua_State* tolua_S)
{
 Nuclear::INuclearShape* self = (Nuclear::INuclearShape*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__PAniPack__FileSec (lua_State* tolua_S)
{
 Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IEffectNotify (lua_State* tolua_S)
{
 Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__IParticleEffect (lua_State* tolua_S)
{
 Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__sNuclearFontEffectParam (lua_State* tolua_S)
{
 Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearColor (lua_State* tolua_S)
{
 Nuclear::NuclearColor* self = (Nuclear::NuclearColor*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__ISelectableObj (lua_State* tolua_S)
{
 Nuclear::ISelectableObj* self = (Nuclear::ISelectableObj*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__DrawEllipsePictureParam (lua_State* tolua_S)
{
 Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__NuclearFRectt (lua_State* tolua_S)
{
 Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__World (lua_State* tolua_S)
{
 Nuclear::World* self = (Nuclear::World*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__SpriteSoundParam (lua_State* tolua_S)
{
 Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}

static int tolua_collect_Nuclear__XAni__XPic (lua_State* tolua_S)
{
 Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*) tolua_tousertype(tolua_S,1,0);
	Mtolua_delete(self);
	return 0;
}
#endif


/* function to register type */
static void tolua_reg_types (lua_State* tolua_S)
{
 tolua_usertype(tolua_S,"cocos2d::CCLayer");
 tolua_usertype(tolua_S,"Nuclear::PAniPack");
 tolua_usertype(tolua_S,"CFileUtil");
 tolua_usertype(tolua_S,"wchar_t");
 tolua_usertype(tolua_S,"Nuclear::Effect");
 tolua_usertype(tolua_S,"Nuclear::NuclearTCVertex");
 tolua_usertype(tolua_S,"Nuclear::SystemResourceManager::MemoryStatus");
 tolua_usertype(tolua_S,"std::vector<Nuclear::NuclearFPoint>");
 tolua_usertype(tolua_S,"Nuclear::IEnv");
 tolua_usertype(tolua_S,"Nuclear::EngineParameter");
 tolua_usertype(tolua_S,"Nuclear::ExecThread");
 tolua_usertype(tolua_S,"Nuclear::Action");
 tolua_usertype(tolua_S,"Nuclear::SystemResourceManager::WindowsVersionInfo");
 tolua_usertype(tolua_S,"std::vector<Nuclear::NuclearMultiSampleType>");
 tolua_usertype(tolua_S,"FireNet::Octets");
 tolua_usertype(tolua_S,"RECT");
 tolua_usertype(tolua_S,"core::Logger");
 tolua_usertype(tolua_S,"LJFM::LJFMFSManager");
 tolua_usertype(tolua_S,"Nuclear::NuclearPictureInfo");
 tolua_usertype(tolua_S,"Nuclear::XAni::XBigPic");
 tolua_usertype(tolua_S,"Nuclear::SpriteEventNotify");
 tolua_usertype(tolua_S,"Nuclear::PSParameter");
 tolua_usertype(tolua_S,"Nuclear::XPLoadmapParam");
 tolua_usertype(tolua_S,"LJFM::LJFMIF");
 tolua_usertype(tolua_S,"Nuclear::LINE");
 tolua_usertype(tolua_S,"Nuclear::SpriteManager::Layer");
 tolua_usertype(tolua_S,"Nuclear::PAniPack::FileSec");
 tolua_usertype(tolua_S,"Nuclear::AniManager");
 tolua_usertype(tolua_S,"Nuclear::IImmovableObj");
 tolua_usertype(tolua_S,"Nuclear::SpriteNotify");
 tolua_usertype(tolua_S,"Nuclear::Renderer");
 tolua_usertype(tolua_S,"Nuclear::INuclearShape");
 tolua_usertype(tolua_S,"Nuclear::INuclearTimer");
 tolua_usertype(tolua_S,"LJFMUO");
 tolua_usertype(tolua_S,"Nuclear::DrawPictureParam");
 tolua_usertype(tolua_S,"Nuclear::NuclearPolygon");
 tolua_usertype(tolua_S,"Nuclear::NuclearDisplayMode");
 tolua_usertype(tolua_S,"Nuclear::NuclearSpriteLayer");
 tolua_usertype(tolua_S,"virtualISelectableObj");
 tolua_usertype(tolua_S,"std::vector<Nuclear::NuclearRect>");
 tolua_usertype(tolua_S,"Nuclear::NuclearBuffer");
 tolua_usertype(tolua_S,"Nuclear::INuclearRunnable");
 tolua_usertype(tolua_S,"Nuclear::NuclearBufferOctets");
 tolua_usertype(tolua_S,"Nuclear::NuclearBase");
 tolua_usertype(tolua_S,"Nuclear::NuclearOctets");
 tolua_usertype(tolua_S,"LPRECT");
 tolua_usertype(tolua_S,"std::vector<Nuclear::NuclearTriangle>");
 tolua_usertype(tolua_S,"Nuclear::NuclearEllipse");
 tolua_usertype(tolua_S,"Nuclear::NuclearVector4");
 tolua_usertype(tolua_S,"Nuclear::ConfigManager");
 tolua_usertype(tolua_S,"std::vector<Nuclear::NuclearPoint>");
 tolua_usertype(tolua_S,"Nuclear::IParticleManager");
 tolua_usertype(tolua_S,"Nuclear::Cocos2dRenderer");
 tolua_usertype(tolua_S,"IniFile");
 tolua_usertype(tolua_S,"Nuclear::Renderable");
 tolua_usertype(tolua_S,"Nuclear::NuclearCircle");
 tolua_usertype(tolua_S,"Nuclear::IWorld");
 tolua_usertype(tolua_S,"Nuclear::INuclearFileIO");
 tolua_usertype(tolua_S,"std::vector<int>");
 tolua_usertype(tolua_S,"Nuclear::XPMazeColors");
 tolua_usertype(tolua_S,"Nuclear::ActionType");
 tolua_usertype(tolua_S,"Nuclear::IFontManager");
 tolua_usertype(tolua_S,"Nuclear::Component");
 tolua_usertype(tolua_S,"Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS");
 tolua_usertype(tolua_S,"std::map<std::wstring,int>");
 tolua_usertype(tolua_S,"Nuclear::EffectManager");
 tolua_usertype(tolua_S,"Nuclear::PSINFO");
 tolua_usertype(tolua_S,"Nuclear::ExecThread::CallbackTask");
 tolua_usertype(tolua_S,"LJFM::LJFMBF");
 tolua_usertype(tolua_S,"Nuclear::ExecThread::Task");
 tolua_usertype(tolua_S,"Nuclear::SpriteSoundParam");
 tolua_usertype(tolua_S,"std::vector<std::wstring>");
 tolua_usertype(tolua_S,"Nuclear::DrawBatchPictureParam");
 tolua_usertype(tolua_S,"tm");
 tolua_usertype(tolua_S,"Nuclear::ExecThread::SimpleTask");
 tolua_usertype(tolua_S,"astar::PathFinder");
 tolua_usertype(tolua_S,"Nuclear::ParticleEffect");
 tolua_usertype(tolua_S,"Nuclear::Engine");
 tolua_usertype(tolua_S,"Nuclear::DrawElement");
 tolua_usertype(tolua_S,"Nuclear::NuclearTCT1Vertex");
 tolua_usertype(tolua_S,"Nuclear::SpriteManager");
 tolua_usertype(tolua_S,"Nuclear::NuclearRect");
 tolua_usertype(tolua_S,"Nuclear::NuclearMatrix3");
 tolua_usertype(tolua_S,"Nuclear::IEffect");
 tolua_usertype(tolua_S,"Nuclear::AniLoadingNotify");
 tolua_usertype(tolua_S,"Nuclear::NuclearUTCT1Vertex");
 tolua_usertype(tolua_S,"Nuclear::PSModifyParam");
 tolua_usertype(tolua_S,"Nuclear::NuclearTriangle");
 tolua_usertype(tolua_S,"Nuclear::IApp");
 tolua_usertype(tolua_S,"Nuclear::NuclearFileIOManager");
 tolua_usertype(tolua_S,"Nuclear::IEngine");
 tolua_usertype(tolua_S,"Nuclear::IEffectNotify");
 tolua_usertype(tolua_S,"Nuclear::EngineBase");
 tolua_usertype(tolua_S,"LPCTSTR");
 tolua_usertype(tolua_S,"Nuclear::GUObject");
 tolua_usertype(tolua_S,"Nuclear::ISprite");
 tolua_usertype(tolua_S,"LJFM::LJFMFS");
 tolua_usertype(tolua_S,"Nuclear::NuclearFColor");
 tolua_usertype(tolua_S,"Nuclear::ModelSoundParam");
 tolua_usertype(tolua_S,"Nuclear::NuclearFPoint");
 tolua_usertype(tolua_S,"LJFM::LJFMUO");
 tolua_usertype(tolua_S,"Nuclear::Canvas");
 tolua_usertype(tolua_S,"Nuclear::XAni");
 tolua_usertype(tolua_S,"Nuclear::World");
 tolua_usertype(tolua_S,"std::vector<Nuclear::ISelectableObj*>");
 tolua_usertype(tolua_S,"Nuclear::NuclearPoint");
 tolua_usertype(tolua_S,"Nuclear::NuclearFileIOManager::AsyncReadTask");
 tolua_usertype(tolua_S,"LJFM::LJFMF");
 tolua_usertype(tolua_S,"Nuclear::ShakeScreenController");
 tolua_usertype(tolua_S,"Nuclear::NuclearVector3");
 tolua_usertype(tolua_S,"Nuclear::SystemResourceManager");
 tolua_usertype(tolua_S,"std::map<int,int>");
 tolua_usertype(tolua_S,"Nuclear::IParticleEffect");
 tolua_usertype(tolua_S,"Nuclear::sNuclearFontEffectParam");
 tolua_usertype(tolua_S,"Nuclear::NuclearColor");
 tolua_usertype(tolua_S,"Nuclear::ISelectableObj");
 tolua_usertype(tolua_S,"Nuclear::DrawEllipsePictureParam");
 tolua_usertype(tolua_S,"Nuclear::NuclearFRectt");
 tolua_usertype(tolua_S,"POINT");
 tolua_usertype(tolua_S,"Nuclear::HorseHeight");
 tolua_usertype(tolua_S,"Nuclear::XAni::XPic");
}

/* get function: x of class  POINT */
#ifndef TOLUA_DISABLE_tolua_get_POINT_x
static int tolua_get_POINT_x(lua_State* tolua_S)
{
  POINT* self = (POINT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  POINT */
#ifndef TOLUA_DISABLE_tolua_set_POINT_x
static int tolua_set_POINT_x(lua_State* tolua_S)
{
  POINT* self = (POINT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  POINT */
#ifndef TOLUA_DISABLE_tolua_get_POINT_y
static int tolua_get_POINT_y(lua_State* tolua_S)
{
  POINT* self = (POINT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  POINT */
#ifndef TOLUA_DISABLE_tolua_set_POINT_y
static int tolua_set_POINT_y(lua_State* tolua_S)
{
  POINT* self = (POINT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: left of class  RECT */
#ifndef TOLUA_DISABLE_tolua_get_RECT_left
static int tolua_get_RECT_left(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'left'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->left);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: left of class  RECT */
#ifndef TOLUA_DISABLE_tolua_set_RECT_left
static int tolua_set_RECT_left(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'left'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->left = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: top of class  RECT */
#ifndef TOLUA_DISABLE_tolua_get_RECT_top
static int tolua_get_RECT_top(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'top'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->top);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: top of class  RECT */
#ifndef TOLUA_DISABLE_tolua_set_RECT_top
static int tolua_set_RECT_top(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'top'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->top = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: right of class  RECT */
#ifndef TOLUA_DISABLE_tolua_get_RECT_right
static int tolua_get_RECT_right(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'right'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->right);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: right of class  RECT */
#ifndef TOLUA_DISABLE_tolua_set_RECT_right
static int tolua_set_RECT_right(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'right'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->right = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bottom of class  RECT */
#ifndef TOLUA_DISABLE_tolua_get_RECT_bottom
static int tolua_get_RECT_bottom(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bottom'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->bottom);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bottom of class  RECT */
#ifndef TOLUA_DISABLE_tolua_set_RECT_bottom
static int tolua_set_RECT_bottom(lua_State* tolua_S)
{
  RECT* self = (RECT*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bottom'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bottom = ((long)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: x of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearFPoint_x
static int tolua_get_Nuclear__NuclearFPoint_x(lua_State* tolua_S)
{
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearFPoint_x
static int tolua_set_Nuclear__NuclearFPoint_x(lua_State* tolua_S)
{
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearFPoint_y
static int tolua_get_Nuclear__NuclearFPoint_y(lua_State* tolua_S)
{
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearFPoint_y
static int tolua_set_Nuclear__NuclearFPoint_y(lua_State* tolua_S)
{
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new00
static int tolua_engineWin32_Nuclear_NuclearFPoint_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.f));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new00_local
static int tolua_engineWin32_Nuclear_NuclearFPoint_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.f));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new01
static int tolua_engineWin32_Nuclear_NuclearFPoint_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* p = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(*p));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new01_local
static int tolua_engineWin32_Nuclear_NuclearFPoint_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* p = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(*p));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator+ of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint__add00
static int tolua_engineWin32_Nuclear_NuclearFPoint__add00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* fp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator+'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->operator+(*fp);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.add'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator- of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint__sub00
static int tolua_engineWin32_Nuclear_NuclearFPoint__sub00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* fp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator-'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->operator-(*fp);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.sub'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator* of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint__mul00
static int tolua_engineWin32_Nuclear_NuclearFPoint__mul00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  float k = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator*'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->operator*(k);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.mul'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator/ of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint__div00
static int tolua_engineWin32_Nuclear_NuclearFPoint__div00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  float k = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator/'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->operator/(k);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.div'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator== of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint__eq00
static int tolua_engineWin32_Nuclear_NuclearFPoint__eq00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* fp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator=='", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->operator==(*fp);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.eq'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Dis2 of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_Dis200
static int tolua_engineWin32_Nuclear_NuclearFPoint_Dis200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* cp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dis2'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Dis2(*cp);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dis2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: isInPolygon of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon00
static int tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<Nuclear::NuclearFPoint>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const std::vector<Nuclear::NuclearFPoint>* polygon = ((const std::vector<Nuclear::NuclearFPoint>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isInPolygon'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->isInPolygon(*polygon);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'isInPolygon'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: isInTriangle of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle00
static int tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFPoint p0 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearFPoint p1 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFPoint p2 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isInTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->isInTriangle(p0,p1,p2);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'isInTriangle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new02
static int tolua_engineWin32_Nuclear_NuclearFPoint_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.f));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new02_local
static int tolua_engineWin32_Nuclear_NuclearFPoint_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.f));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new03
static int tolua_engineWin32_Nuclear_NuclearFPoint_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* p = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(*p));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_new03_local
static int tolua_engineWin32_Nuclear_NuclearFPoint_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* p = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearFPoint* tolua_ret = (Nuclear::NuclearFPoint*)  Mtolua_new((Nuclear::NuclearFPoint)(*p));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Dis2 of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_Dis201
static int tolua_engineWin32_Nuclear_NuclearFPoint_Dis201(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* cp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dis2'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Dis2(*cp);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_Dis200(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: angleBetween of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_angleBetween00
static int tolua_engineWin32_Nuclear_NuclearFPoint_angleBetween00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* vec = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'angleBetween'", NULL);
#endif
  {
   float tolua_ret = (float)  self->angleBetween(*vec);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'angleBetween'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: isInPolygon of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon01
static int tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<Nuclear::NuclearFPoint>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  const std::vector<Nuclear::NuclearFPoint>* polygon = ((const std::vector<Nuclear::NuclearFPoint>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isInPolygon'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->isInPolygon(*polygon);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: isInTriangle of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle01
static int tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* self = (const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFPoint p0 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearFPoint p1 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFPoint p2 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isInTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->isInTriangle(p0,p1,p2);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: normalize of class  Nuclear::NuclearFPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFPoint_normalize00
static int tolua_engineWin32_Nuclear_NuclearFPoint_normalize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFPoint* self = (Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'normalize'", NULL);
#endif
  {
   self->normalize();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'normalize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new00
static int tolua_engineWin32_Nuclear_NuclearPoint_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int _x = ((int)  tolua_tonumber(tolua_S,2,0));
  int _y = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new00_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int _x = ((int)  tolua_tonumber(tolua_S,2,0));
  int _y = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new01
static int tolua_engineWin32_Nuclear_NuclearPoint_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* pt = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new01_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* pt = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new02
static int tolua_engineWin32_Nuclear_NuclearPoint_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new02_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator- of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint__sub00
static int tolua_engineWin32_Nuclear_NuclearPoint__sub00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* cp = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator-'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->operator-(*cp);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.sub'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: operator+ of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint__add00
static int tolua_engineWin32_Nuclear_NuclearPoint__add00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* cp = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'operator+'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->operator+(*cp);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '.add'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Dis2 of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_Dis200
static int tolua_engineWin32_Nuclear_NuclearPoint_Dis200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* cp = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dis2'", NULL);
#endif
  {
   int tolua_ret = (int)  self->Dis2(*cp);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dis2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToFPOINT of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT00
static int tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToFPOINT'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->ToFPOINT();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ToFPOINT'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new03
static int tolua_engineWin32_Nuclear_NuclearPoint_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  int _x = ((int)  tolua_tonumber(tolua_S,2,0));
  int _y = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new03_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  int _x = ((int)  tolua_tonumber(tolua_S,2,0));
  int _y = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(_x,_y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new04
static int tolua_engineWin32_Nuclear_NuclearPoint_new04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* pt = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new04_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new04_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const POINT* pt = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new03_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new05
static int tolua_engineWin32_Nuclear_NuclearPoint_new05(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new04(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_new05_local
static int tolua_engineWin32_Nuclear_NuclearPoint_new05_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearPoint* tolua_ret = (Nuclear::NuclearPoint*)  Mtolua_new((Nuclear::NuclearPoint)(*pt));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_new04_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Dis2 of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_Dis201
static int tolua_engineWin32_Nuclear_NuclearPoint_Dis201(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* cp = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dis2'", NULL);
#endif
  {
   int tolua_ret = (int)  self->Dis2(*cp);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_Dis200(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToFPOINT of class  Nuclear::NuclearPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT01
static int tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* self = (const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToFPOINT'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->ToFPOINT();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new00
static int tolua_engineWin32_Nuclear_NuclearRect_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
  int r = ((int)  tolua_tonumber(tolua_S,4,0));
  int b = ((int)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new00_local
static int tolua_engineWin32_Nuclear_NuclearRect_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
  int r = ((int)  tolua_tonumber(tolua_S,4,0));
  int b = ((int)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new01
static int tolua_engineWin32_Nuclear_NuclearRect_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* ltpoint = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int width = ((int)  tolua_tonumber(tolua_S,3,0));
  int height = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new01_local
static int tolua_engineWin32_Nuclear_NuclearRect_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* ltpoint = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int width = ((int)  tolua_tonumber(tolua_S,3,0));
  int height = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new02
static int tolua_engineWin32_Nuclear_NuclearRect_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const RECT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const RECT* r = ((const RECT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new02_local
static int tolua_engineWin32_Nuclear_NuclearRect_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const RECT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const RECT* r = ((const RECT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Widen of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Widen00
static int tolua_engineWin32_Nuclear_NuclearRect_Widen00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  int d = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Widen'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->Widen(d);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Widen'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Union of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Union00
static int tolua_engineWin32_Nuclear_NuclearRect_Union00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* rhs = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Union'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->Union(*rhs);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Union'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPos of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_GetPos00
static int tolua_engineWin32_Nuclear_NuclearRect_GetPos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPos'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->GetPos();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Center of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Center00
static int tolua_engineWin32_Nuclear_NuclearRect_Center00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Center'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->Center();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Center'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToFRECT of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_ToFRECT00
static int tolua_engineWin32_Nuclear_NuclearRect_ToFRECT00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToFRECT'", NULL);
#endif
  {
   Nuclear::NuclearFRectt tolua_ret = (Nuclear::NuclearFRectt)  self->ToFRECT();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFRectt)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFRectt));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ToFRECT'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInRect of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_PtInRect00
static int tolua_engineWin32_Nuclear_NuclearRect_PtInRect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInRect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInRect(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PtInRect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsCross of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_IsCross00
static int tolua_engineWin32_Nuclear_NuclearRect_IsCross00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* rhs = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect* res = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsCross'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsCross(*rhs,*res);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsCross'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Cut of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Cut00
static int tolua_engineWin32_Nuclear_NuclearRect_Cut00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearFRectt",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* vrect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect* drect = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFRectt* srect = ((Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Cut'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Cut(*vrect,*drect,*srect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cut'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new03
static int tolua_engineWin32_Nuclear_NuclearRect_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
  int r = ((int)  tolua_tonumber(tolua_S,4,0));
  int b = ((int)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new03_local
static int tolua_engineWin32_Nuclear_NuclearRect_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
  int r = ((int)  tolua_tonumber(tolua_S,4,0));
  int b = ((int)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new04
static int tolua_engineWin32_Nuclear_NuclearRect_new04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* ltpoint = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int width = ((int)  tolua_tonumber(tolua_S,3,0));
  int height = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new04_local
static int tolua_engineWin32_Nuclear_NuclearRect_new04_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPoint* ltpoint = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int width = ((int)  tolua_tonumber(tolua_S,3,0));
  int height = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new03_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new05
static int tolua_engineWin32_Nuclear_NuclearRect_new05(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const RECT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const RECT* r = ((const RECT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new04(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_new05_local
static int tolua_engineWin32_Nuclear_NuclearRect_new05_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const RECT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const RECT* r = ((const RECT*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearRect* tolua_ret = (Nuclear::NuclearRect*)  Mtolua_new((Nuclear::NuclearRect)(*r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_new04_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Widen of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Widen01
static int tolua_engineWin32_Nuclear_NuclearRect_Widen01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  int d = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Widen'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->Widen(d);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_Widen00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Union of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Union01
static int tolua_engineWin32_Nuclear_NuclearRect_Union01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* rhs = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Union'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->Union(*rhs);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_Union00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPos of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_GetPos01
static int tolua_engineWin32_Nuclear_NuclearRect_GetPos01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPos'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->GetPos();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_GetPos00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Center of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Center01
static int tolua_engineWin32_Nuclear_NuclearRect_Center01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Center'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->Center();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_Center00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToFRECT of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_ToFRECT01
static int tolua_engineWin32_Nuclear_NuclearRect_ToFRECT01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToFRECT'", NULL);
#endif
  {
   Nuclear::NuclearFRectt tolua_ret = (Nuclear::NuclearFRectt)  self->ToFRECT();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFRectt)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFRectt));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_ToFRECT00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Assign of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Assign00
static int tolua_engineWin32_Nuclear_NuclearRect_Assign00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearRect* self = (Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
  int r = ((int)  tolua_tonumber(tolua_S,4,0));
  int b = ((int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Assign'", NULL);
#endif
  {
   Nuclear::NuclearRect& tolua_ret = (Nuclear::NuclearRect&)  self->Assign(l,t,r,b);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Assign'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Width of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Width00
static int tolua_engineWin32_Nuclear_NuclearRect_Width00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Width'", NULL);
#endif
  {
   int tolua_ret = (int)  self->Width();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Width'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Height of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Height00
static int tolua_engineWin32_Nuclear_NuclearRect_Height00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Height'", NULL);
#endif
  {
   int tolua_ret = (int)  self->Height();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Height'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInRect of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_PtInRect01
static int tolua_engineWin32_Nuclear_NuclearRect_PtInRect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInRect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInRect(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_PtInRect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsCross of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_IsCross01
static int tolua_engineWin32_Nuclear_NuclearRect_IsCross01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* rhs = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect* res = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsCross'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsCross(*rhs,*res);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_IsCross00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Cut of class  Nuclear::NuclearRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearRect_Cut01
static int tolua_engineWin32_Nuclear_NuclearRect_Cut01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearFRectt",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearRect* self = (const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* vrect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect* drect = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFRectt* srect = ((Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Cut'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Cut(*vrect,*drect,*srect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearRect_Cut00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearVector4 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector4_new00
static int tolua_engineWin32_Nuclear_NuclearVector4_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector4",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0));
  float _w = ((float)  tolua_tonumber(tolua_S,5,0.0));
  {
   Nuclear::NuclearVector4* tolua_ret = (Nuclear::NuclearVector4*)  Mtolua_new((Nuclear::NuclearVector4)(_x,_y,_z,_w));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector4");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearVector4 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector4_new00_local
static int tolua_engineWin32_Nuclear_NuclearVector4_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector4",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0));
  float _w = ((float)  tolua_tonumber(tolua_S,5,0.0));
  {
   Nuclear::NuclearVector4* tolua_ret = (Nuclear::NuclearVector4*)  Mtolua_new((Nuclear::NuclearVector4)(_x,_y,_z,_w));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearVector4 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector4_new01
static int tolua_engineWin32_Nuclear_NuclearVector4_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector4",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _w = ((float)  tolua_tonumber(tolua_S,5,0.0f));
  {
   Nuclear::NuclearVector4* tolua_ret = (Nuclear::NuclearVector4*)  Mtolua_new((Nuclear::NuclearVector4)(_x,_y,_z,_w));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector4");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector4_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearVector4 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector4_new01_local
static int tolua_engineWin32_Nuclear_NuclearVector4_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector4",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _w = ((float)  tolua_tonumber(tolua_S,5,0.0f));
  {
   Nuclear::NuclearVector4* tolua_ret = (Nuclear::NuclearVector4*)  Mtolua_new((Nuclear::NuclearVector4)(_x,_y,_z,_w));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector4_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new00
static int tolua_engineWin32_Nuclear_NuclearColor_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new00_local
static int tolua_engineWin32_Nuclear_NuclearColor_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new01
static int tolua_engineWin32_Nuclear_NuclearColor_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  DWORD color = ((DWORD)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(color));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new01_local
static int tolua_engineWin32_Nuclear_NuclearColor_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  DWORD color = ((DWORD)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(color));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new02
static int tolua_engineWin32_Nuclear_NuclearColor_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(*v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new02_local
static int tolua_engineWin32_Nuclear_NuclearColor_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(*v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new03
static int tolua_engineWin32_Nuclear_NuclearColor_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(_a,_r,_g,_b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new03_local
static int tolua_engineWin32_Nuclear_NuclearColor_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(_a,_r,_g,_b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_Reset00
static int tolua_engineWin32_Nuclear_NuclearColor_Reset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearColor* self = (Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(*v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Reset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToXPVECTOR4 of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR400
static int tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR400(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearColor* self = (Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToXPVECTOR4'", NULL);
#endif
  {
   Nuclear::NuclearVector4 tolua_ret = (Nuclear::NuclearVector4)  self->ToXPVECTOR4();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearVector4)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearVector4));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ToXPVECTOR4'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_Reset01
static int tolua_engineWin32_Nuclear_NuclearColor_Reset01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearColor* self = (Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(_b,_g,_r,_a);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_Reset00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new04
static int tolua_engineWin32_Nuclear_NuclearColor_new04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new04_local
static int tolua_engineWin32_Nuclear_NuclearColor_new04_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new03_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new05
static int tolua_engineWin32_Nuclear_NuclearColor_new05(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  DWORD color = ((DWORD)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(color));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new04(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new05_local
static int tolua_engineWin32_Nuclear_NuclearColor_new05_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  DWORD color = ((DWORD)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(color));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new04_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new06
static int tolua_engineWin32_Nuclear_NuclearColor_new06(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(*v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new05(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new06_local
static int tolua_engineWin32_Nuclear_NuclearColor_new06_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(*v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new05_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new07
static int tolua_engineWin32_Nuclear_NuclearColor_new07(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(_a,_r,_g,_b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new06(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_new07_local
static int tolua_engineWin32_Nuclear_NuclearColor_new07_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
  {
   Nuclear::NuclearColor* tolua_ret = (Nuclear::NuclearColor*)  Mtolua_new((Nuclear::NuclearColor)(_a,_r,_g,_b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_new06_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_Reset02
static int tolua_engineWin32_Nuclear_NuclearColor_Reset02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearColor* self = (Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearVector4* v = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(*v);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_Reset01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToXPVECTOR4 of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR401
static int tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR401(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearColor* self = (const Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToXPVECTOR4'", NULL);
#endif
  {
   Nuclear::NuclearVector4 tolua_ret = (Nuclear::NuclearVector4)  self->ToXPVECTOR4();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearVector4)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearVector4));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearVector4");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR400(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearColor_Reset03
static int tolua_engineWin32_Nuclear_NuclearColor_Reset03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearColor* self = (Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,1,0);
  unsigned char _b = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char _g = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
  unsigned char _r = ((unsigned char)  tolua_tonumber(tolua_S,4,0));
  unsigned char _a = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(_b,_g,_r,_a);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearColor_Reset02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::INuclearRunnable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearRunnable_delete00
static int tolua_engineWin32_Nuclear_INuclearRunnable_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearRunnable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearRunnable* self = (Nuclear::INuclearRunnable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearDisplayMode */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearDisplayMode_new00
static int tolua_engineWin32_Nuclear_NuclearDisplayMode_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearDisplayMode",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearDisplayMode* tolua_ret = (Nuclear::NuclearDisplayMode*)  Mtolua_new((Nuclear::NuclearDisplayMode)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearDisplayMode");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearDisplayMode */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearDisplayMode_new00_local
static int tolua_engineWin32_Nuclear_NuclearDisplayMode_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearDisplayMode",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearDisplayMode* tolua_ret = (Nuclear::NuclearDisplayMode*)  Mtolua_new((Nuclear::NuclearDisplayMode)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: equalExceptScreenMode of class  Nuclear::NuclearDisplayMode */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearDisplayMode_equalExceptScreenMode00
static int tolua_engineWin32_Nuclear_NuclearDisplayMode_equalExceptScreenMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearDisplayMode",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearDisplayMode",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearDisplayMode* self = (Nuclear::NuclearDisplayMode*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearDisplayMode* df = ((const Nuclear::NuclearDisplayMode*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'equalExceptScreenMode'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->equalExceptScreenMode(*df);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'equalExceptScreenMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iTimerID of class  Nuclear::INuclearTimer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__INuclearTimer_m_iTimerID
static int tolua_get_Nuclear__INuclearTimer_m_iTimerID(lua_State* tolua_S)
{
  Nuclear::INuclearTimer* self = (Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTimerID'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iTimerID);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iTimerID of class  Nuclear::INuclearTimer */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__INuclearTimer_m_iTimerID
static int tolua_set_Nuclear__INuclearTimer_m_iTimerID(lua_State* tolua_S)
{
  Nuclear::INuclearTimer* self = (Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTimerID'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iTimerID = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::INuclearTimer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearTimer_OnTimer00
static int tolua_engineWin32_Nuclear_INuclearTimer_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearTimer* self = (Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::INuclearTimer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearTimer_delete00
static int tolua_engineWin32_Nuclear_INuclearTimer_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearTimer* self = (Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new00
static int tolua_engineWin32_Nuclear_NuclearFRectt_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float l = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float t = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float r = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float b = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new00_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float l = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float t = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float r = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float b = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new01
static int tolua_engineWin32_Nuclear_NuclearFRectt_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* ltpoint = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float width = ((float)  tolua_tonumber(tolua_S,3,0));
  float height = ((float)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new01_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* ltpoint = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float width = ((float)  tolua_tonumber(tolua_S,3,0));
  float height = ((float)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new02
static int tolua_engineWin32_Nuclear_NuclearFRectt_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float size = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new02_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float size = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new03
static int tolua_engineWin32_Nuclear_NuclearFRectt_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* rb = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,*rb));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new03_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* rb = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,*rb));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Assign of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Assign00
static int tolua_engineWin32_Nuclear_NuclearFRectt_Assign00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
  float l = ((float)  tolua_tonumber(tolua_S,2,0));
  float t = ((float)  tolua_tonumber(tolua_S,3,0));
  float r = ((float)  tolua_tonumber(tolua_S,4,0));
  float b = ((float)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Assign'", NULL);
#endif
  {
   Nuclear::NuclearFRectt& tolua_ret = (Nuclear::NuclearFRectt&)  self->Assign(l,t,r,b);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Assign'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Width of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Width00
static int tolua_engineWin32_Nuclear_NuclearFRectt_Width00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Width'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Width();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Width'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Height of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Height00
static int tolua_engineWin32_Nuclear_NuclearFRectt_Height00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Height'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Height();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Height'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInRect of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect00
static int tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInRect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInRect(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PtInRect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new04
static int tolua_engineWin32_Nuclear_NuclearFRectt_new04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float l = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float t = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float r = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float b = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new04_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new04_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float l = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float t = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float r = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float b = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(l,t,r,b));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new03_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new05
static int tolua_engineWin32_Nuclear_NuclearFRectt_new05(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* ltpoint = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float width = ((float)  tolua_tonumber(tolua_S,3,0));
  float height = ((float)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new04(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new05_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new05_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* ltpoint = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float width = ((float)  tolua_tonumber(tolua_S,3,0));
  float height = ((float)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*ltpoint,width,height));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new04_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new06
static int tolua_engineWin32_Nuclear_NuclearFRectt_new06(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float size = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new05(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new06_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new06_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float size = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new05_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new07
static int tolua_engineWin32_Nuclear_NuclearFRectt_new07(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* rb = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,*rb));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new06(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_new07_local
static int tolua_engineWin32_Nuclear_NuclearFRectt_new07_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFPoint* lt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* rb = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::NuclearFRectt* tolua_ret = (Nuclear::NuclearFRectt*)  Mtolua_new((Nuclear::NuclearFRectt)(*lt,*rb));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFRectt");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_new06_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Assign of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Assign01
static int tolua_engineWin32_Nuclear_NuclearFRectt_Assign01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearFRectt* self = (Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
  float l = ((float)  tolua_tonumber(tolua_S,2,0));
  float t = ((float)  tolua_tonumber(tolua_S,3,0));
  float r = ((float)  tolua_tonumber(tolua_S,4,0));
  float b = ((float)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Assign'", NULL);
#endif
  {
   Nuclear::NuclearFRectt& tolua_ret = (Nuclear::NuclearFRectt&)  self->Assign(l,t,r,b);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearFRectt");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_Assign00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Width of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Width01
static int tolua_engineWin32_Nuclear_NuclearFRectt_Width01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFRectt* self = (const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Width'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Width();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_Width00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Height of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_Height01
static int tolua_engineWin32_Nuclear_NuclearFRectt_Height01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFRectt* self = (const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Height'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Height();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_Height00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInRect of class  Nuclear::NuclearFRectt */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect01
static int tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFRectt* self = (const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInRect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInRect(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_new00
static int tolua_engineWin32_Nuclear_NuclearVector3_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  {
   Nuclear::NuclearVector3* tolua_ret = (Nuclear::NuclearVector3*)  Mtolua_new((Nuclear::NuclearVector3)(_x,_y,_z));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_new00_local
static int tolua_engineWin32_Nuclear_NuclearVector3_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  {
   Nuclear::NuclearVector3* tolua_ret = (Nuclear::NuclearVector3*)  Mtolua_new((Nuclear::NuclearVector3)(_x,_y,_z));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector3");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Reset00
static int tolua_engineWin32_Nuclear_NuclearVector3_Reset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
  float _x = ((float)  tolua_tonumber(tolua_S,2,0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   Nuclear::NuclearVector3& tolua_ret = (Nuclear::NuclearVector3&)  self->Reset(_x,_y,_z);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Reset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Add of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Add00
static int tolua_engineWin32_Nuclear_NuclearVector3_Add00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
  float _x = ((float)  tolua_tonumber(tolua_S,2,0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Add'", NULL);
#endif
  {
   Nuclear::NuclearVector3& tolua_ret = (Nuclear::NuclearVector3&)  self->Add(_x,_y,_z);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Add'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Length of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Length00
static int tolua_engineWin32_Nuclear_NuclearVector3_Length00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Length'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Length();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Length'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_new01
static int tolua_engineWin32_Nuclear_NuclearVector3_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  {
   Nuclear::NuclearVector3* tolua_ret = (Nuclear::NuclearVector3*)  Mtolua_new((Nuclear::NuclearVector3)(_x,_y,_z));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector3_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_new01_local
static int tolua_engineWin32_Nuclear_NuclearVector3_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  {
   Nuclear::NuclearVector3* tolua_ret = (Nuclear::NuclearVector3*)  Mtolua_new((Nuclear::NuclearVector3)(_x,_y,_z));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearVector3");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector3_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Reset01
static int tolua_engineWin32_Nuclear_NuclearVector3_Reset01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
  float _x = ((float)  tolua_tonumber(tolua_S,2,0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   Nuclear::NuclearVector3& tolua_ret = (Nuclear::NuclearVector3&)  self->Reset(_x,_y,_z);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector3_Reset00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Add of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Add01
static int tolua_engineWin32_Nuclear_NuclearVector3_Add01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearVector3* self = (Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
  float _x = ((float)  tolua_tonumber(tolua_S,2,0));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Add'", NULL);
#endif
  {
   Nuclear::NuclearVector3& tolua_ret = (Nuclear::NuclearVector3&)  self->Add(_x,_y,_z);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearVector3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector3_Add00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Length of class  Nuclear::NuclearVector3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearVector3_Length01
static int tolua_engineWin32_Nuclear_NuclearVector3_Length01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearVector3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearVector3* self = (const Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Length'", NULL);
#endif
  {
   float tolua_ret = (float)  self->Length();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearVector3_Length00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_new00
static int tolua_engineWin32_Nuclear_NuclearFColor_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _r = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFColor* tolua_ret = (Nuclear::NuclearFColor*)  Mtolua_new((Nuclear::NuclearFColor)(_r,_g,_b,_a));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFColor");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_new00_local
static int tolua_engineWin32_Nuclear_NuclearFColor_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _r = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFColor* tolua_ret = (Nuclear::NuclearFColor*)  Mtolua_new((Nuclear::NuclearFColor)(_r,_g,_b,_a));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_Reset00
static int tolua_engineWin32_Nuclear_NuclearFColor_Reset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFColor* self = (Nuclear::NuclearFColor*)  tolua_tousertype(tolua_S,1,0);
  float _r = ((float)  tolua_tonumber(tolua_S,2,0));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(_r,_g,_b,_a);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Reset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToDWORD of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD00
static int tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFColor* self = (Nuclear::NuclearFColor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToDWORD'", NULL);
#endif
  {
   DWORD tolua_ret = (DWORD)  self->ToDWORD();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ToDWORD'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_new01
static int tolua_engineWin32_Nuclear_NuclearFColor_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _r = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFColor* tolua_ret = (Nuclear::NuclearFColor*)  Mtolua_new((Nuclear::NuclearFColor)(_r,_g,_b,_a));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFColor");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFColor_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_new01_local
static int tolua_engineWin32_Nuclear_NuclearFColor_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _r = ((float)  tolua_tonumber(tolua_S,2,0.f));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0.f));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0.f));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0.f));
  {
   Nuclear::NuclearFColor* tolua_ret = (Nuclear::NuclearFColor*)  Mtolua_new((Nuclear::NuclearFColor)(_r,_g,_b,_a));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFColor_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Reset of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_Reset01
static int tolua_engineWin32_Nuclear_NuclearFColor_Reset01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearFColor* self = (Nuclear::NuclearFColor*)  tolua_tousertype(tolua_S,1,0);
  float _r = ((float)  tolua_tonumber(tolua_S,2,0));
  float _g = ((float)  tolua_tonumber(tolua_S,3,0));
  float _b = ((float)  tolua_tonumber(tolua_S,4,0));
  float _a = ((float)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Reset'", NULL);
#endif
  {
   self->Reset(_r,_g,_b,_a);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFColor_Reset00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: ToDWORD of class  Nuclear::NuclearFColor */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD01
static int tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFColor",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearFColor* self = (const Nuclear::NuclearFColor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ToDWORD'", NULL);
#endif
  {
   DWORD tolua_ret = (DWORD)  self->ToDWORD();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInTriangle of class  Nuclear::NuclearTriangle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle00
static int tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearTriangle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearTriangle* self = (Nuclear::NuclearTriangle*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInTriangle(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PtInTriangle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInTriangle of class  Nuclear::NuclearTriangle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle01
static int tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearTriangle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearTriangle* self = (const Nuclear::NuclearTriangle*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInTriangle(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearEllipse */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearEllipse_new00
static int tolua_engineWin32_Nuclear_NuclearEllipse_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearEllipse",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearEllipse* tolua_ret = (Nuclear::NuclearEllipse*)  Mtolua_new((Nuclear::NuclearEllipse)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearEllipse");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearEllipse */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearEllipse_new00_local
static int tolua_engineWin32_Nuclear_NuclearEllipse_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearEllipse",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearEllipse* tolua_ret = (Nuclear::NuclearEllipse*)  Mtolua_new((Nuclear::NuclearEllipse)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearEllipse");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PtInEllipse of class  Nuclear::NuclearEllipse */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearEllipse_PtInEllipse00
static int tolua_engineWin32_Nuclear_NuclearEllipse_PtInEllipse00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearEllipse",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearEllipse* self = (Nuclear::NuclearEllipse*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PtInEllipse'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PtInEllipse(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PtInEllipse'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new00
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new00_local
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new01
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _11 = ((float)  tolua_tonumber(tolua_S,2,0));
  float _12 = ((float)  tolua_tonumber(tolua_S,3,0));
  float _13 = ((float)  tolua_tonumber(tolua_S,4,0));
  float _21 = ((float)  tolua_tonumber(tolua_S,5,0));
  float _22 = ((float)  tolua_tonumber(tolua_S,6,0));
  float _23 = ((float)  tolua_tonumber(tolua_S,7,0));
  float _31 = ((float)  tolua_tonumber(tolua_S,8,0));
  float _32 = ((float)  tolua_tonumber(tolua_S,9,0));
  float _33 = ((float)  tolua_tonumber(tolua_S,10,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)(_11,_12,_13,_21,_22,_23,_31,_32,_33));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new01_local
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _11 = ((float)  tolua_tonumber(tolua_S,2,0));
  float _12 = ((float)  tolua_tonumber(tolua_S,3,0));
  float _13 = ((float)  tolua_tonumber(tolua_S,4,0));
  float _21 = ((float)  tolua_tonumber(tolua_S,5,0));
  float _22 = ((float)  tolua_tonumber(tolua_S,6,0));
  float _23 = ((float)  tolua_tonumber(tolua_S,7,0));
  float _31 = ((float)  tolua_tonumber(tolua_S,8,0));
  float _32 = ((float)  tolua_tonumber(tolua_S,9,0));
  float _33 = ((float)  tolua_tonumber(tolua_S,10,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)(_11,_12,_13,_21,_22,_23,_31,_32,_33));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Translation of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_Translation00
static int tolua_engineWin32_Nuclear_NuclearMatrix3_Translation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* self = (Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* result = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* fp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Translation'", NULL);
#endif
  {
   self->Translation(*result,*fp);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Translation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Translation of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_Translation01
static int tolua_engineWin32_Nuclear_NuclearMatrix3_Translation01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearMatrix3* self = (Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* result = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
  float x = ((float)  tolua_tonumber(tolua_S,3,0));
  float y = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Translation'", NULL);
#endif
  {
   self->Translation(*result,x,y);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_Translation00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: inverse of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_inverse00
static int tolua_engineWin32_Nuclear_NuclearMatrix3_inverse00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* self = (Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'inverse'", NULL);
#endif
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  self->inverse(pOut);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'inverse'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new02
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _11 = ((float)  tolua_tonumber(tolua_S,2,0));
  float _12 = ((float)  tolua_tonumber(tolua_S,3,0));
  float _13 = ((float)  tolua_tonumber(tolua_S,4,0));
  float _21 = ((float)  tolua_tonumber(tolua_S,5,0));
  float _22 = ((float)  tolua_tonumber(tolua_S,6,0));
  float _23 = ((float)  tolua_tonumber(tolua_S,7,0));
  float _31 = ((float)  tolua_tonumber(tolua_S,8,0));
  float _32 = ((float)  tolua_tonumber(tolua_S,9,0));
  float _33 = ((float)  tolua_tonumber(tolua_S,10,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)(_11,_12,_13,_21,_22,_23,_31,_32,_33));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_new02_local
static int tolua_engineWin32_Nuclear_NuclearMatrix3_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  float _11 = ((float)  tolua_tonumber(tolua_S,2,0));
  float _12 = ((float)  tolua_tonumber(tolua_S,3,0));
  float _13 = ((float)  tolua_tonumber(tolua_S,4,0));
  float _21 = ((float)  tolua_tonumber(tolua_S,5,0));
  float _22 = ((float)  tolua_tonumber(tolua_S,6,0));
  float _23 = ((float)  tolua_tonumber(tolua_S,7,0));
  float _31 = ((float)  tolua_tonumber(tolua_S,8,0));
  float _32 = ((float)  tolua_tonumber(tolua_S,9,0));
  float _33 = ((float)  tolua_tonumber(tolua_S,10,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Mtolua_new((Nuclear::NuclearMatrix3)(_11,_12,_13,_21,_22,_23,_31,_32,_33));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Translation of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_Translation02
static int tolua_engineWin32_Nuclear_NuclearMatrix3_Translation02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearMatrix3",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearMatrix3* self = (const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* result = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearFPoint* fp = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Translation'", NULL);
#endif
  {
   self->Translation(*result,*fp);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_Translation01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Translation of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_Translation03
static int tolua_engineWin32_Nuclear_NuclearMatrix3_Translation03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearMatrix3",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearMatrix3* self = (const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* result = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
  float x = ((float)  tolua_tonumber(tolua_S,3,0));
  float y = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Translation'", NULL);
#endif
  {
   self->Translation(*result,x,y);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_Translation02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: inverse of class  Nuclear::NuclearMatrix3 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearMatrix3_inverse01
static int tolua_engineWin32_Nuclear_NuclearMatrix3_inverse01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearMatrix3* self = (const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'inverse'", NULL);
#endif
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  self->inverse(pOut);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearMatrix3_inverse00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_delete00
static int tolua_engineWin32_Nuclear_INuclearShape_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearShape* self = (Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_IsPointIn00
static int tolua_engineWin32_Nuclear_INuclearShape_IsPointIn00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearShape",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearShape* self = (Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsPointIn'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_DistanceTo00
static int tolua_engineWin32_Nuclear_INuclearShape_DistanceTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearShape",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearShape* self = (Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(*pt);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DistanceTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_IsPointIn01
static int tolua_engineWin32_Nuclear_INuclearShape_IsPointIn01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(x,y);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_INuclearShape_IsPointIn00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_IsPointIn02
static int tolua_engineWin32_Nuclear_INuclearShape_IsPointIn02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(*pt);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_INuclearShape_IsPointIn01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_DistanceTo01
static int tolua_engineWin32_Nuclear_INuclearShape_DistanceTo01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_INuclearShape_DistanceTo00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_DistanceTo02
static int tolua_engineWin32_Nuclear_INuclearShape_DistanceTo02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(*pt);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_INuclearShape_DistanceTo01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_Render00
static int tolua_engineWin32_Nuclear_INuclearShape_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearRect* viewport = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,0));
  int pointR = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(pRenderer,*viewport,color,fillmode,pointR);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_GetType00
static int tolua_engineWin32_Nuclear_INuclearShape_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::NuclearShapeType tolua_ret = (Nuclear::NuclearShapeType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Extension of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_Extension00
static int tolua_engineWin32_Nuclear_INuclearShape_Extension00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Extension'", NULL);
#endif
  {
   Nuclear::INuclearShape* tolua_ret = (Nuclear::INuclearShape*)  self->Extension(l);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearShape");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Extension'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVaild of class  Nuclear::INuclearShape */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearShape_IsVaild00
static int tolua_engineWin32_Nuclear_INuclearShape_IsVaild00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::INuclearShape",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::INuclearShape* self = (const Nuclear::INuclearShape*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVaild'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVaild();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsVaild'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new00
static int tolua_engineWin32_Nuclear_NuclearCircle_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new00_local
static int tolua_engineWin32_Nuclear_NuclearCircle_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new01
static int tolua_engineWin32_Nuclear_NuclearCircle_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint pos = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int r = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)(pos,r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new01_local
static int tolua_engineWin32_Nuclear_NuclearCircle_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint pos = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int r = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)(pos,r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_GetType00
static int tolua_engineWin32_Nuclear_NuclearCircle_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::NuclearShapeType tolua_ret = (Nuclear::NuclearShapeType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn00
static int tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(x,y);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsPointIn'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo00
static int tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DistanceTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_Render00
static int tolua_engineWin32_Nuclear_NuclearCircle_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearRect* viewport = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,0));
  int pointR = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(pRenderer,*viewport,color,fillmode,pointR);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Extension of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_Extension00
static int tolua_engineWin32_Nuclear_NuclearCircle_Extension00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Extension'", NULL);
#endif
  {
   Nuclear::INuclearShape* tolua_ret = (Nuclear::INuclearShape*)  self->Extension(l);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearShape");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Extension'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVaild of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_IsVaild00
static int tolua_engineWin32_Nuclear_NuclearCircle_IsVaild00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearCircle* self = (Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVaild'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVaild();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsVaild'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new02
static int tolua_engineWin32_Nuclear_NuclearCircle_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new02_local
static int tolua_engineWin32_Nuclear_NuclearCircle_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new03
static int tolua_engineWin32_Nuclear_NuclearCircle_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint pos = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int r = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)(pos,r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_new03_local
static int tolua_engineWin32_Nuclear_NuclearCircle_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearCircle",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint pos = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int r = ((int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearCircle* tolua_ret = (Nuclear::NuclearCircle*)  Mtolua_new((Nuclear::NuclearCircle)(pos,r));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearCircle");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_GetType01
static int tolua_engineWin32_Nuclear_NuclearCircle_GetType01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::NuclearShapeType tolua_ret = (Nuclear::NuclearShapeType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_GetType00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn01
static int tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(x,y);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo01
static int tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_Render01
static int tolua_engineWin32_Nuclear_NuclearCircle_Render01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearRect* viewport = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,0));
  int pointR = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(pRenderer,*viewport,color,fillmode,pointR);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_Render00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Extension of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_Extension01
static int tolua_engineWin32_Nuclear_NuclearCircle_Extension01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Extension'", NULL);
#endif
  {
   Nuclear::INuclearShape* tolua_ret = (Nuclear::INuclearShape*)  self->Extension(l);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearShape");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_Extension00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVaild of class  Nuclear::NuclearCircle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearCircle_IsVaild01
static int tolua_engineWin32_Nuclear_NuclearCircle_IsVaild01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearCircle",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearCircle* self = (const Nuclear::NuclearCircle*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVaild'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVaild();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearCircle_IsVaild00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_new00
static int tolua_engineWin32_Nuclear_NuclearPolygon_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearPolygon* tolua_ret = (Nuclear::NuclearPolygon*)  Mtolua_new((Nuclear::NuclearPolygon)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPolygon");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_new00_local
static int tolua_engineWin32_Nuclear_NuclearPolygon_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearPolygon* tolua_ret = (Nuclear::NuclearPolygon*)  Mtolua_new((Nuclear::NuclearPolygon)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPolygon");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_GetType00
static int tolua_engineWin32_Nuclear_NuclearPolygon_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearPolygon* self = (Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::NuclearShapeType tolua_ret = (Nuclear::NuclearShapeType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn00
static int tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearPolygon* self = (Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(x,y);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsPointIn'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo00
static int tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DistanceTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_Render00
static int tolua_engineWin32_Nuclear_NuclearPolygon_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearRect* viewport = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,0));
  int pointR = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(pRenderer,*viewport,color,fillmode,pointR);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Extension of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_Extension00
static int tolua_engineWin32_Nuclear_NuclearPolygon_Extension00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Extension'", NULL);
#endif
  {
   Nuclear::INuclearShape* tolua_ret = (Nuclear::INuclearShape*)  self->Extension(l);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearShape");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Extension'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVaild of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild00
static int tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearPolygon* self = (Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVaild'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVaild();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsVaild'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_new01
static int tolua_engineWin32_Nuclear_NuclearPolygon_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearPolygon* tolua_ret = (Nuclear::NuclearPolygon*)  Mtolua_new((Nuclear::NuclearPolygon)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPolygon");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_new01_local
static int tolua_engineWin32_Nuclear_NuclearPolygon_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  {
   Nuclear::NuclearPolygon* tolua_ret = (Nuclear::NuclearPolygon*)  Mtolua_new((Nuclear::NuclearPolygon)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPolygon");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_GetType01
static int tolua_engineWin32_Nuclear_NuclearPolygon_GetType01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::NuclearShapeType tolua_ret = (Nuclear::NuclearShapeType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_GetType00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPointIn of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn01
static int tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPointIn'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPointIn(x,y);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DistanceTo of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo01
static int tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DistanceTo'", NULL);
#endif
  {
   float tolua_ret = (float)  self->DistanceTo(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_Render01
static int tolua_engineWin32_Nuclear_NuclearPolygon_Render01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearRect* viewport = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,0));
  int pointR = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(pRenderer,*viewport,color,fillmode,pointR);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_Render00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: Extension of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_Extension01
static int tolua_engineWin32_Nuclear_NuclearPolygon_Extension01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
  int l = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Extension'", NULL);
#endif
  {
   Nuclear::INuclearShape* tolua_ret = (Nuclear::INuclearShape*)  self->Extension(l);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearShape");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_Extension00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVaild of class  Nuclear::NuclearPolygon */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild01
static int tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPolygon",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearPolygon* self = (const Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVaild'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVaild();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* get function: mStartPosition of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition
static int tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mStartPosition'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->mStartPosition,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: mStartPosition of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition
static int tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mStartPosition'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->mStartPosition = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: mTargetPosition of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition
static int tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mTargetPosition'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->mTargetPosition,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: mTargetPosition of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition
static int tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mTargetPosition'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->mTargetPosition = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: mDuration of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration
static int tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mDuration'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->mDuration);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: mDuration of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration
static int tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration(lua_State* tolua_S)
{
  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* self = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mDuration'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->mDuration = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00
static int tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* tolua_ret = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  Mtolua_new((Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00_local
static int tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS* tolua_ret = (Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS*)  Mtolua_new((Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: left of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearBase_left
static int tolua_get_Nuclear__NuclearBase_left(lua_State* tolua_S)
{
  Nuclear::NuclearBase* self = (Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'left'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->left,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: left of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearBase_left
static int tolua_set_Nuclear__NuclearBase_left(lua_State* tolua_S)
{
  Nuclear::NuclearBase* self = (Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'left'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->left = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: right of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearBase_right
static int tolua_get_Nuclear__NuclearBase_right(lua_State* tolua_S)
{
  Nuclear::NuclearBase* self = (Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'right'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->right,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: right of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearBase_right
static int tolua_set_Nuclear__NuclearBase_right(lua_State* tolua_S)
{
  Nuclear::NuclearBase* self = (Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'right'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->right = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBase_new00
static int tolua_engineWin32_Nuclear_NuclearBase_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearBase* tolua_ret = (Nuclear::NuclearBase*)  Mtolua_new((Nuclear::NuclearBase)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBase");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBase_new00_local
static int tolua_engineWin32_Nuclear_NuclearBase_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearBase* tolua_ret = (Nuclear::NuclearBase*)  Mtolua_new((Nuclear::NuclearBase)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBase");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fMaxScale of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_fMaxScale
static int tolua_get_Nuclear__sNuclearFontEffectParam_fMaxScale(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fMaxScale'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->fMaxScale,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fMaxScale of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_fMaxScale
static int tolua_set_Nuclear__sNuclearFontEffectParam_fMaxScale(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fMaxScale'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fMaxScale = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fMinScale of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_fMinScale
static int tolua_get_Nuclear__sNuclearFontEffectParam_fMinScale(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fMinScale'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->fMinScale,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fMinScale of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_fMinScale
static int tolua_set_Nuclear__sNuclearFontEffectParam_fMinScale(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fMinScale'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fMinScale = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fCycle of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_fCycle
static int tolua_get_Nuclear__sNuclearFontEffectParam_fCycle(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fCycle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->fCycle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fCycle of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_fCycle
static int tolua_set_Nuclear__sNuclearFontEffectParam_fCycle(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fCycle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fCycle = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: nPlayTime of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_nPlayTime
static int tolua_get_Nuclear__sNuclearFontEffectParam_nPlayTime(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nPlayTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->nPlayTime);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: nPlayTime of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_nPlayTime
static int tolua_set_Nuclear__sNuclearFontEffectParam_nPlayTime(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nPlayTime'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->nPlayTime = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: nLoopNum of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_nLoopNum
static int tolua_get_Nuclear__sNuclearFontEffectParam_nLoopNum(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nLoopNum'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->nLoopNum);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: nLoopNum of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_nLoopNum
static int tolua_set_Nuclear__sNuclearFontEffectParam_nLoopNum(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nLoopNum'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->nLoopNum = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pFrctSrc of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr
static int tolua_get_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pFrctSrc'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pFrctSrc,"Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: pFrctSrc of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr
static int tolua_set_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr(lua_State* tolua_S)
{
  Nuclear::sNuclearFontEffectParam* self = (Nuclear::sNuclearFontEffectParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pFrctSrc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Nuclear::NuclearFRectt",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->pFrctSrc = ((Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00
static int tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::sNuclearFontEffectParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::sNuclearFontEffectParam* tolua_ret = (Nuclear::sNuclearFontEffectParam*)  Mtolua_new((Nuclear::sNuclearFontEffectParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::sNuclearFontEffectParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::sNuclearFontEffectParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00_local
static int tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::sNuclearFontEffectParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::sNuclearFontEffectParam* tolua_ret = (Nuclear::sNuclearFontEffectParam*)  Mtolua_new((Nuclear::sNuclearFontEffectParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::sNuclearFontEffectParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: x of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCVertex_x
static int tolua_get_Nuclear__NuclearTCVertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCVertex_x
static int tolua_set_Nuclear__NuclearTCVertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCVertex_y
static int tolua_get_Nuclear__NuclearTCVertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCVertex_y
static int tolua_set_Nuclear__NuclearTCVertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: z of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCVertex_z
static int tolua_get_Nuclear__NuclearTCVertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->z);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: z of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCVertex_z
static int tolua_set_Nuclear__NuclearTCVertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->z = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rhw of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCVertex_rhw
static int tolua_get_Nuclear__NuclearTCVertex_rhw(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rhw'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->rhw);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rhw of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCVertex_rhw
static int tolua_set_Nuclear__NuclearTCVertex_rhw(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rhw'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rhw = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: c of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCVertex_c
static int tolua_get_Nuclear__NuclearTCVertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->c);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: c of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCVertex_c
static int tolua_set_Nuclear__NuclearTCVertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearTCVertex* self = (Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->c = ((DWORD)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTCVertex_new00
static int tolua_engineWin32_Nuclear_NuclearTCVertex_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearTCVertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _rhw = ((float)  tolua_tonumber(tolua_S,5,1.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,6,0xFFFFFFFF));
  {
   Nuclear::NuclearTCVertex* tolua_ret = (Nuclear::NuclearTCVertex*)  Mtolua_new((Nuclear::NuclearTCVertex)(_x,_y,_z,_rhw,_c));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearTCVertex");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearTCVertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTCVertex_new00_local
static int tolua_engineWin32_Nuclear_NuclearTCVertex_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearTCVertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _rhw = ((float)  tolua_tonumber(tolua_S,5,1.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,6,0xFFFFFFFF));
  {
   Nuclear::NuclearTCVertex* tolua_ret = (Nuclear::NuclearTCVertex*)  Mtolua_new((Nuclear::NuclearTCVertex)(_x,_y,_z,_rhw,_c));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearTCVertex");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: x of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_x
static int tolua_get_Nuclear__NuclearUTCT1Vertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_x
static int tolua_set_Nuclear__NuclearUTCT1Vertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_y
static int tolua_get_Nuclear__NuclearUTCT1Vertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_y
static int tolua_set_Nuclear__NuclearUTCT1Vertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: z of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_z
static int tolua_get_Nuclear__NuclearUTCT1Vertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->z);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: z of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_z
static int tolua_set_Nuclear__NuclearUTCT1Vertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->z = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: c of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_c
static int tolua_get_Nuclear__NuclearUTCT1Vertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->c);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: c of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_c
static int tolua_set_Nuclear__NuclearUTCT1Vertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->c = ((DWORD)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: u of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_u
static int tolua_get_Nuclear__NuclearUTCT1Vertex_u(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->u);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: u of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_u
static int tolua_set_Nuclear__NuclearUTCT1Vertex_u(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->u = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: v of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearUTCT1Vertex_v
static int tolua_get_Nuclear__NuclearUTCT1Vertex_v(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->v);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: v of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearUTCT1Vertex_v
static int tolua_set_Nuclear__NuclearUTCT1Vertex_v(lua_State* tolua_S)
{
  Nuclear::NuclearUTCT1Vertex* self = (Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->v = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00
static int tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearUTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,5,0xFFFFFFFF));
  float _u = ((float)  tolua_tonumber(tolua_S,6,0.0f));
  float _v = ((float)  tolua_tonumber(tolua_S,7,0.0f));
  {
   Nuclear::NuclearUTCT1Vertex* tolua_ret = (Nuclear::NuclearUTCT1Vertex*)  Mtolua_new((Nuclear::NuclearUTCT1Vertex)(_x,_y,_z,_c,_u,_v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearUTCT1Vertex");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearUTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00_local
static int tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearUTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,5,0xFFFFFFFF));
  float _u = ((float)  tolua_tonumber(tolua_S,6,0.0f));
  float _v = ((float)  tolua_tonumber(tolua_S,7,0.0f));
  {
   Nuclear::NuclearUTCT1Vertex* tolua_ret = (Nuclear::NuclearUTCT1Vertex*)  Mtolua_new((Nuclear::NuclearUTCT1Vertex)(_x,_y,_z,_c,_u,_v));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearUTCT1Vertex");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: x of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_x
static int tolua_get_Nuclear__NuclearTCT1Vertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_x
static int tolua_set_Nuclear__NuclearTCT1Vertex_x(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_y
static int tolua_get_Nuclear__NuclearTCT1Vertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_y
static int tolua_set_Nuclear__NuclearTCT1Vertex_y(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: z of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_z
static int tolua_get_Nuclear__NuclearTCT1Vertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->z);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: z of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_z
static int tolua_set_Nuclear__NuclearTCT1Vertex_z(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->z = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rhw of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_rhw
static int tolua_get_Nuclear__NuclearTCT1Vertex_rhw(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rhw'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->rhw);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rhw of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_rhw
static int tolua_set_Nuclear__NuclearTCT1Vertex_rhw(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rhw'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rhw = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: c of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_c
static int tolua_get_Nuclear__NuclearTCT1Vertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->c);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: c of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_c
static int tolua_set_Nuclear__NuclearTCT1Vertex_c(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'c'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->c = ((DWORD)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: u of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_u
static int tolua_get_Nuclear__NuclearTCT1Vertex_u(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->u);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: u of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_u
static int tolua_set_Nuclear__NuclearTCT1Vertex_u(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->u = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: v of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_v
static int tolua_get_Nuclear__NuclearTCT1Vertex_v(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->v);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: v of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_v
static int tolua_set_Nuclear__NuclearTCT1Vertex_v(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->v = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: u2 of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_u2
static int tolua_get_Nuclear__NuclearTCT1Vertex_u2(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u2'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->u2);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: u2 of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_u2
static int tolua_set_Nuclear__NuclearTCT1Vertex_u2(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u2'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->u2 = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: v2 of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearTCT1Vertex_v2
static int tolua_get_Nuclear__NuclearTCT1Vertex_v2(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v2'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->v2);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: v2 of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearTCT1Vertex_v2
static int tolua_set_Nuclear__NuclearTCT1Vertex_v2(lua_State* tolua_S)
{
  Nuclear::NuclearTCT1Vertex* self = (Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v2'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->v2 = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00
static int tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _rhw = ((float)  tolua_tonumber(tolua_S,5,1.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,6,0xFFFFFFFF));
  float _u = ((float)  tolua_tonumber(tolua_S,7,0.0f));
  float _v = ((float)  tolua_tonumber(tolua_S,8,0.0f));
  float _u2 = ((float)  tolua_tonumber(tolua_S,9,0.0f));
  float _v2 = ((float)  tolua_tonumber(tolua_S,10,0.0f));
  {
   Nuclear::NuclearTCT1Vertex* tolua_ret = (Nuclear::NuclearTCT1Vertex*)  Mtolua_new((Nuclear::NuclearTCT1Vertex)(_x,_y,_z,_rhw,_c,_u,_v,_u2,_v2));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearTCT1Vertex");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearTCT1Vertex */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00_local
static int tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float _x = ((float)  tolua_tonumber(tolua_S,2,0.0f));
  float _y = ((float)  tolua_tonumber(tolua_S,3,0.0f));
  float _z = ((float)  tolua_tonumber(tolua_S,4,0.0f));
  float _rhw = ((float)  tolua_tonumber(tolua_S,5,1.0f));
  DWORD _c = ((DWORD)  tolua_tonumber(tolua_S,6,0xFFFFFFFF));
  float _u = ((float)  tolua_tonumber(tolua_S,7,0.0f));
  float _v = ((float)  tolua_tonumber(tolua_S,8,0.0f));
  float _u2 = ((float)  tolua_tonumber(tolua_S,9,0.0f));
  float _v2 = ((float)  tolua_tonumber(tolua_S,10,0.0f));
  {
   Nuclear::NuclearTCT1Vertex* tolua_ret = (Nuclear::NuclearTCT1Vertex*)  Mtolua_new((Nuclear::NuclearTCT1Vertex)(_x,_y,_z,_rhw,_c,_u,_v,_u2,_v2));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearTCT1Vertex");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::GetRotationScalingMartrixByDirection */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GetRotationScalingMartrixByDirection00
static int tolua_engineWin32_Nuclear_GetRotationScalingMartrixByDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearDirection dir = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::GetRotationScalingMartrixByDirection(pOut,pP,dir);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRotationScalingMartrixByDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: handle of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XBigPic_handle
static int tolua_get_Nuclear__XAni__XBigPic_handle(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->handle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: handle of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XBigPic_handle
static int tolua_set_Nuclear__XAni__XBigPic_handle(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->handle = ((  int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: filename of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XBigPic_filename
static int tolua_get_Nuclear__XAni__XBigPic_filename(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'filename'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->filename);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: filename of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XBigPic_filename
static int tolua_set_Nuclear__XAni__XBigPic_filename(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'filename'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->filename = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: dir of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XBigPic_dir
static int tolua_get_Nuclear__XAni__XBigPic_dir(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dir'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->dir);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: dir of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XBigPic_dir
static int tolua_set_Nuclear__XAni__XBigPic_dir(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dir'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->dir = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: asyncLoad of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XBigPic_asyncLoad
static int tolua_get_Nuclear__XAni__XBigPic_asyncLoad(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'asyncLoad'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->asyncLoad);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: asyncLoad of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XBigPic_asyncLoad
static int tolua_set_Nuclear__XAni__XBigPic_asyncLoad(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'asyncLoad'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->asyncLoad = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: loaded of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XBigPic_loaded
static int tolua_get_Nuclear__XAni__XBigPic_loaded(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'loaded'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->loaded);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: loaded of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XBigPic_loaded
static int tolua_set_Nuclear__XAni__XBigPic_loaded(lua_State* tolua_S)
{
  Nuclear::XAni::XBigPic* self = (Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'loaded'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->loaded = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_XBigPic_new00
static int tolua_engineWin32_Nuclear_XAni_XBigPic_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XAni::XBigPic",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XAni::XBigPic* tolua_ret = (Nuclear::XAni::XBigPic*)  Mtolua_new((Nuclear::XAni::XBigPic)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XAni::XBigPic");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  XBigPic */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_XBigPic_new00_local
static int tolua_engineWin32_Nuclear_XAni_XBigPic_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XAni::XBigPic",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XAni::XBigPic* tolua_ret = (Nuclear::XAni::XBigPic*)  Mtolua_new((Nuclear::XAni::XBigPic)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XAni::XBigPic");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pBigPic of class  XPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XPic_pBigPic_ptr
static int tolua_get_Nuclear__XAni__XPic_pBigPic_ptr(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pBigPic'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pBigPic,"Nuclear::XAni::XBigPic");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: pBigPic of class  XPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XPic_pBigPic_ptr
static int tolua_set_Nuclear__XAni__XPic_pBigPic_ptr(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pBigPic'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Nuclear::XAni::XBigPic",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->pBigPic = ((Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pBigPicPart of class  XPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XPic_pBigPicPart_ptr
static int tolua_get_Nuclear__XAni__XPic_pBigPicPart_ptr(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pBigPicPart'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pBigPicPart,"Nuclear::XAni::XBigPic");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: pBigPicPart of class  XPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XPic_pBigPicPart_ptr
static int tolua_set_Nuclear__XAni__XPic_pBigPicPart_ptr(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pBigPicPart'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Nuclear::XAni::XBigPic",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->pBigPicPart = ((Nuclear::XAni::XBigPic*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: offset of class  XPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XPic_offset
static int tolua_get_Nuclear__XAni__XPic_offset(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'offset'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->offset,"Nuclear::NuclearRect");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: offset of class  XPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XPic_offset
static int tolua_set_Nuclear__XAni__XPic_offset(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'offset'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->offset = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: srcrect of class  XPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XPic_srcrect
static int tolua_get_Nuclear__XAni__XPic_srcrect(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'srcrect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->srcrect,"Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: srcrect of class  XPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XPic_srcrect
static int tolua_set_Nuclear__XAni__XPic_srcrect(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'srcrect'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFRectt",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->srcrect = *((Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: outLine of class  XPic */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XAni__XPic_outLine
static int tolua_get_Nuclear__XAni__XPic_outLine(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'outLine'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->outLine,"Nuclear::NuclearPolygon");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: outLine of class  XPic */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XAni__XPic_outLine
static int tolua_set_Nuclear__XAni__XPic_outLine(lua_State* tolua_S)
{
  Nuclear::XAni::XPic* self = (Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'outLine'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPolygon",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->outLine = *((Nuclear::NuclearPolygon*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  XPic */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_XPic_new00
static int tolua_engineWin32_Nuclear_XAni_XPic_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XAni::XPic",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XAni::XPic* tolua_ret = (Nuclear::XAni::XPic*)  Mtolua_new((Nuclear::XAni::XPic)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XAni::XPic");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  XPic */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_XPic_new00_local
static int tolua_engineWin32_Nuclear_XAni_XPic_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::XAni::XPic",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::XAni::XPic* tolua_ret = (Nuclear::XAni::XPic*)  Mtolua_new((Nuclear::XAni::XPic)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::XAni::XPic");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestPoint of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_TestPoint00
static int tolua_engineWin32_Nuclear_XAni_TestPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,6,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
  int frame = ((int)  tolua_tonumber(tolua_S,3,0));
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::Nuclear_Mouse_TestMode mode = ((Nuclear::Nuclear_Mouse_TestMode) (int)  tolua_tonumber(tolua_S,5,0));
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,6,0));
  int r = ((int)  tolua_tonumber(tolua_S,7,0));
  float testval = ((float)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestPoint'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestPoint(dir,frame,*pt,mode,pRenderer,r,testval);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestDir of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_TestDir00
static int tolua_engineWin32_Nuclear_XAni_TestDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::XAni* self = (const Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestDir'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestDir(dir);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameCount of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetFrameCount00
static int tolua_engineWin32_Nuclear_XAni_GetFrameCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFrameCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRegionCount of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetRegionCount00
static int tolua_engineWin32_Nuclear_XAni_GetRegionCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRegionCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetRegionCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRegionCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayTime of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetPlayTime00
static int tolua_engineWin32_Nuclear_XAni_GetPlayTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetPlayTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetPlayTime of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetPlayTime00
static int tolua_engineWin32_Nuclear_XAni_SetPlayTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetPlayTime'", NULL);
#endif
  {
   self->SetPlayTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetPlayTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBlend of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetBlend00
static int tolua_engineWin32_Nuclear_XAni_GetBlend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBlend'", NULL);
#endif
  {
   Nuclear::NuclearTextureBlendMode tolua_ret = (Nuclear::NuclearTextureBlendMode)  self->GetBlend();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBlend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBlend of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetBlend00
static int tolua_engineWin32_Nuclear_XAni_SetBlend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearTextureBlendMode blend = ((Nuclear::NuclearTextureBlendMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBlend'", NULL);
#endif
  {
   self->SetBlend(blend);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBlend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetState of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetState00
static int tolua_engineWin32_Nuclear_XAni_GetState00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetState'", NULL);
#endif
  {
   Nuclear::XAni::XPANI_STATE tolua_ret = (Nuclear::XAni::XPANI_STATE)  self->GetState();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetState'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPic of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetPic00
static int tolua_engineWin32_Nuclear_XAni_GetPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::XAni::XPic",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
  int seq = ((int)  tolua_tonumber(tolua_S,3,0));
  int reg = ((int)  tolua_tonumber(tolua_S,4,0));
  Nuclear::XAni::XPic* pic = ((Nuclear::XAni::XPic*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPic'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetPic(dir,seq,reg,*pic);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBase of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetBase00
static int tolua_engineWin32_Nuclear_XAni_GetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBase* base = ((Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBase'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBase(*base);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBase of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetBase00
static int tolua_engineWin32_Nuclear_XAni_SetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearBase* base = ((const Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBase'", NULL);
#endif
  {
   self->SetBase(*base);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBorder of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetBorder00
static int tolua_engineWin32_Nuclear_XAni_GetBorder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearRect* border = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBorder'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBorder(*border);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBorder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBorder of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetBorder00
static int tolua_engineWin32_Nuclear_XAni_SetBorder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* border = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBorder'", NULL);
#endif
  {
   self->SetBorder(*border);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBorder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileFmt of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetFileFmt00
static int tolua_engineWin32_Nuclear_XAni_GetFileFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileFmt'", NULL);
#endif
  {
   Nuclear::NuclearImageFileFormat tolua_ret = (Nuclear::NuclearImageFileFormat)  self->GetFileFmt();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFileFmt of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetFileFmt00
static int tolua_engineWin32_Nuclear_XAni_SetFileFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearImageFileFormat fmt = ((Nuclear::NuclearImageFileFormat) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFileFmt'", NULL);
#endif
  {
   self->SetFileFmt(fmt);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFileFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTexFmt of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetTexFmt00
static int tolua_engineWin32_Nuclear_XAni_GetTexFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTexFmt'", NULL);
#endif
  {
   Nuclear::NuclearTextureFormat tolua_ret = (Nuclear::NuclearTextureFormat)  self->GetTexFmt();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTexFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTexFmt of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetTexFmt00
static int tolua_engineWin32_Nuclear_XAni_SetTexFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearTextureFormat fmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTexFmt'", NULL);
#endif
  {
   self->SetTexFmt(fmt);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTexFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirMode of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetDirMode00
static int tolua_engineWin32_Nuclear_XAni_GetDirMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirMode'", NULL);
#endif
  {
   Nuclear::XPANI_DIRECTIONMODE tolua_ret = (Nuclear::XPANI_DIRECTIONMODE)  self->GetDirMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirMask of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetDirMask00
static int tolua_engineWin32_Nuclear_XAni_GetDirMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::XAni* self = (const Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirMask'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetDirMask();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectBindType of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetEffectBindType00
static int tolua_engineWin32_Nuclear_XAni_GetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectBindType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectBindType tolua_ret = (Nuclear::Nuclear_EffectBindType)  self->GetEffectBindType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectBindType of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetEffectBindType00
static int tolua_engineWin32_Nuclear_XAni_SetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectBindType t = ((Nuclear::Nuclear_EffectBindType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectBindType'", NULL);
#endif
  {
   self->SetEffectBindType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSysLevel of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetSysLevel00
static int tolua_engineWin32_Nuclear_XAni_GetSysLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::XAni* self = (const Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSysLevel'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSysLevel();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSysLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSysLevel of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetSysLevel00
static int tolua_engineWin32_Nuclear_XAni_SetSysLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int sys = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSysLevel'", NULL);
#endif
  {
   self->SetSysLevel(sys);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSysLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetReleaseFlag of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetReleaseFlag00
static int tolua_engineWin32_Nuclear_XAni_GetReleaseFlag00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetReleaseFlag'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetReleaseFlag();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetReleaseFlag'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetReleaseFlag of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_SetReleaseFlag00
static int tolua_engineWin32_Nuclear_XAni_SetReleaseFlag00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPaniReleaseFlag flag = ((Nuclear::NuclearPaniReleaseFlag) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetReleaseFlag'", NULL);
#endif
  {
   self->SetReleaseFlag(flag);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetReleaseFlag'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetUsingDirs of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_GetUsingDirs00
static int tolua_engineWin32_Nuclear_XAni_GetUsingDirs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetUsingDirs'", NULL);
#endif
  {
    std::map<int,int>& tolua_ret = (  std::map<int,int>&)  self->GetUsingDirs();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"std::map<int,int>");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetUsingDirs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ExistInUsingDirs of class  Nuclear::XAni */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XAni_ExistInUsingDirs00
static int tolua_engineWin32_Nuclear_XAni_ExistInUsingDirs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XAni",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XAni* self = (Nuclear::XAni*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ExistInUsingDirs'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ExistInUsingDirs(dir);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ExistInUsingDirs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: offset of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PAniPack__FileSec_offset
static int tolua_get_Nuclear__PAniPack__FileSec_offset(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'offset'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->offset,"Nuclear::NuclearRect");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: offset of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PAniPack__FileSec_offset
static int tolua_set_Nuclear__PAniPack__FileSec_offset(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'offset'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->offset = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: strPicPath of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PAniPack__FileSec_strPicPath
static int tolua_get_Nuclear__PAniPack__FileSec_strPicPath(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'strPicPath'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->strPicPath);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: strPicPath of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PAniPack__FileSec_strPicPath
static int tolua_set_Nuclear__PAniPack__FileSec_strPicPath(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'strPicPath'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->strPicPath = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rctData of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PAniPack__FileSec_rctData
static int tolua_get_Nuclear__PAniPack__FileSec_rctData(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rctData'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->rctData,"Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rctData of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PAniPack__FileSec_rctData
static int tolua_set_Nuclear__PAniPack__FileSec_rctData(lua_State* tolua_S)
{
  Nuclear::PAniPack::FileSec* self = (Nuclear::PAniPack::FileSec*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rctData'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFRectt",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rctData = *((Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_FileSec_new00
static int tolua_engineWin32_Nuclear_PAniPack_FileSec_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PAniPack::FileSec",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PAniPack::FileSec* tolua_ret = (Nuclear::PAniPack::FileSec*)  Mtolua_new((Nuclear::PAniPack::FileSec)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PAniPack::FileSec");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  FileSec */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_FileSec_new00_local
static int tolua_engineWin32_Nuclear_PAniPack_FileSec_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PAniPack::FileSec",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PAniPack::FileSec* tolua_ret = (Nuclear::PAniPack::FileSec*)  Mtolua_new((Nuclear::PAniPack::FileSec)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PAniPack::FileSec");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCenter of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_GetCenter00
static int tolua_engineWin32_Nuclear_PAniPack_GetCenter00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCenter'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->GetCenter();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCenter'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCenter of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetCenter00
static int tolua_engineWin32_Nuclear_PAniPack_SetCenter00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* center = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCenter'", NULL);
#endif
  {
   self->SetCenter(*center);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCenter'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBase of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_GetBase00
static int tolua_engineWin32_Nuclear_PAniPack_GetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBase* base = ((Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBase'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBase(*base);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBase of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetBase00
static int tolua_engineWin32_Nuclear_PAniPack_SetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearBase* base = ((const Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBase'", NULL);
#endif
  {
   self->SetBase(*base);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBorder of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_GetBorder00
static int tolua_engineWin32_Nuclear_PAniPack_GetBorder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearRect* border = ((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBorder'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBorder(*border);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBorder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBorder of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetBorder00
static int tolua_engineWin32_Nuclear_PAniPack_SetBorder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* border = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBorder'", NULL);
#endif
  {
   self->SetBorder(*border);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBorder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileFmt of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_GetFileFmt00
static int tolua_engineWin32_Nuclear_PAniPack_GetFileFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileFmt'", NULL);
#endif
  {
   Nuclear::NuclearImageFileFormat tolua_ret = (Nuclear::NuclearImageFileFormat)  self->GetFileFmt();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTexFmt of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_GetTexFmt00
static int tolua_engineWin32_Nuclear_PAniPack_GetTexFmt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTexFmt'", NULL);
#endif
  {
   Nuclear::NuclearTextureFormat tolua_ret = (Nuclear::NuclearTextureFormat)  self->GetTexFmt();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTexFmt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBlend of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetBlend00
static int tolua_engineWin32_Nuclear_PAniPack_SetBlend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearTextureBlendMode blend = ((Nuclear::NuclearTextureBlendMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBlend'", NULL);
#endif
  {
   self->SetBlend(blend);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBlend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTime of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetTime00
static int tolua_engineWin32_Nuclear_PAniPack_SetTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTime'", NULL);
#endif
  {
   self->SetTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectBindType of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetEffectBindType00
static int tolua_engineWin32_Nuclear_PAniPack_SetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectBindType t = ((Nuclear::Nuclear_EffectBindType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectBindType'", NULL);
#endif
  {
   self->SetEffectBindType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSystemLevel of class  Nuclear::PAniPack */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PAniPack_SetSystemLevel00
static int tolua_engineWin32_Nuclear_PAniPack_SetSystemLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::PAniPack",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::PAniPack* self = (Nuclear::PAniPack*)  tolua_tousertype(tolua_S,1,0);
  int syslevel = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSystemLevel'", NULL);
#endif
  {
   self->SetSystemLevel(syslevel);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSystemLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnLoadAniReady of class  Nuclear::AniLoadingNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniReady00
static int tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniLoadingNotify",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniLoadingNotify* self = (Nuclear::AniLoadingNotify*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnLoadAniReady'", NULL);
#endif
  {
   self->OnLoadAniReady(filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnLoadAniReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnLoadAniBaseReady of class  Nuclear::AniLoadingNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniBaseReady00
static int tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniBaseReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniLoadingNotify",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniLoadingNotify* self = (Nuclear::AniLoadingNotify*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnLoadAniBaseReady'", NULL);
#endif
  {
   self->OnLoadAniBaseReady(filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnLoadAniBaseReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_new00
static int tolua_engineWin32_Nuclear_AniManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::AniManager* tolua_ret = (Nuclear::AniManager*)  Mtolua_new((Nuclear::AniManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::AniManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_new00_local
static int tolua_engineWin32_Nuclear_AniManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::AniManager* tolua_ret = (Nuclear::AniManager*)  Mtolua_new((Nuclear::AniManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::AniManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_delete00
static int tolua_engineWin32_Nuclear_AniManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_Init00
static int tolua_engineWin32_Nuclear_AniManager_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Init();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_Destroy00
static int tolua_engineWin32_Nuclear_AniManager_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   self->Destroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniPicGCTime of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime00
static int tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniPicGCTime'", NULL);
#endif
  {
   self->SetAniPicGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniPicGCTime of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime01
static int tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniPicGCTime'", NULL);
#endif
  {
   self->SetAniPicGCTime(t);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniPicGCTime of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_GetAniPicGCTime00
static int tolua_engineWin32_Nuclear_AniManager_GetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniPicGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniPicGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniXapGCTime of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_SetAniXapGCTime00
static int tolua_engineWin32_Nuclear_AniManager_SetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniXapGCTime'", NULL);
#endif
  {
   self->SetAniXapGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniXapGCTime of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_GetAniXapGCTime00
static int tolua_engineWin32_Nuclear_AniManager_GetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniXapGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniXapGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GarbageCollection of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_GarbageCollection00
static int tolua_engineWin32_Nuclear_AniManager_GarbageCollection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  int nowtick = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GarbageCollection'", NULL);
#endif
  {
   self->GarbageCollection(nowtick);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GarbageCollection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AsyncLoadAni of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_AsyncLoadAni00
static int tolua_engineWin32_Nuclear_AniManager_AsyncLoadAni00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::AniLoadingNotify",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring uri = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::AniLoadingNotify* pNotify = ((Nuclear::AniLoadingNotify*)  tolua_tousertype(tolua_S,3,0));
  bool bLookupSegmPak = ((bool)  tolua_toboolean(tolua_S,4,0));
  unsigned char bDye = ((unsigned char)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AsyncLoadAni'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectAssureResResult tolua_ret = (Nuclear::Nuclear_EffectAssureResResult)  self->AsyncLoadAni(uri,pNotify,bLookupSegmPak,bDye);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)uri);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AsyncLoadAni'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveLoadingNotify of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_RemoveLoadingNotify00
static int tolua_engineWin32_Nuclear_AniManager_RemoveLoadingNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::AniLoadingNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring uri = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::AniLoadingNotify* pNotify = ((Nuclear::AniLoadingNotify*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveLoadingNotify'", NULL);
#endif
  {
   self->RemoveLoadingNotify(uri,pNotify);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)uri);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveLoadingNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadAniFromPack of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_LoadAniFromPack00
static int tolua_engineWin32_Nuclear_AniManager_LoadAniFromPack00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::XAni",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::PAniPack",0,&tolua_err)) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XAni* ani = ((Nuclear::XAni*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::PAniPack* pack = ((const Nuclear::PAniPack*)  tolua_tousertype(tolua_S,3,0));
  const std::wstring packbaseuri = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadAniFromPack'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->LoadAniFromPack(*ani,*pack,packbaseuri,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)packbaseuri);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadAniFromPack'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeAni of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_FreeAni00
static int tolua_engineWin32_Nuclear_AniManager_FreeAni00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::XAni",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XAni* ani = ((Nuclear::XAni*)  tolua_tousertype(tolua_S,2,0));
  bool straight = ((bool)  tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeAni'", NULL);
#endif
  {
   self->FreeAni(*ani,straight);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeAni'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeAniPic of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_FreeAniPic00
static int tolua_engineWin32_Nuclear_AniManager_FreeAniPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::XAni",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XAni* ani = ((Nuclear::XAni*)  tolua_tousertype(tolua_S,2,0));
  bool bCullUsingDir = ((bool)  tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeAniPic'", NULL);
#endif
  {
   self->FreeAniPic(*ani,bCullUsingDir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeAniPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: setGcCooldown of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_setGcCooldown00
static int tolua_engineWin32_Nuclear_AniManager_setGcCooldown00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  int cooldown = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setGcCooldown'", NULL);
#endif
  {
   self->setGcCooldown(cooldown);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'setGcCooldown'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepLoadTexture of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_SetStepLoadTexture00
static int tolua_engineWin32_Nuclear_AniManager_SetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::AniManager* self = (Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepLoadTexture'", NULL);
#endif
  {
   self->SetStepLoadTexture(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepLoadTexture of class  Nuclear::AniManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_AniManager_GetStepLoadTexture00
static int tolua_engineWin32_Nuclear_AniManager_GetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::AniManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::AniManager* self = (const Nuclear::AniManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepLoadTexture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetStepLoadTexture();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_new00
static int tolua_engineWin32_Nuclear_ConfigManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::ConfigManager* tolua_ret = (Nuclear::ConfigManager*)  Mtolua_new((Nuclear::ConfigManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ConfigManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_new00_local
static int tolua_engineWin32_Nuclear_ConfigManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::ConfigManager* tolua_ret = (Nuclear::ConfigManager*)  Mtolua_new((Nuclear::ConfigManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ConfigManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_delete00
static int tolua_engineWin32_Nuclear_ConfigManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_Init00
static int tolua_engineWin32_Nuclear_ConfigManager_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   self->Init();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Update of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_Update00
static int tolua_engineWin32_Nuclear_ConfigManager_Update00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Update'", NULL);
#endif
  {
   self->Update();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Update'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_OnTimer00
static int tolua_engineWin32_Nuclear_ConfigManager_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  int iPeriod = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer(iPeriod);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCreateTexturePoolType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetCreateTexturePoolType00
static int tolua_engineWin32_Nuclear_ConfigManager_GetCreateTexturePoolType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCreateTexturePoolType'", NULL);
#endif
  {
   Nuclear::NuclearPoolType tolua_ret = (Nuclear::NuclearPoolType)  self->GetCreateTexturePoolType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCreateTexturePoolType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteMoveSmoothLimit of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetSpriteMoveSmoothLimit00
static int tolua_engineWin32_Nuclear_ConfigManager_GetSpriteMoveSmoothLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteMoveSmoothLimit'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSpriteMoveSmoothLimit();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteMoveSmoothLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteMoveSmoothLimit of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSpriteMoveSmoothLimit00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSpriteMoveSmoothLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  int iLimit = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteMoveSmoothLimit'", NULL);
#endif
  {
   self->SetSpriteMoveSmoothLimit(iLimit);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteMoveSmoothLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicToWorldScaleX of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetLogicToWorldScaleX00
static int tolua_engineWin32_Nuclear_ConfigManager_GetLogicToWorldScaleX00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicToWorldScaleX'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetLogicToWorldScaleX();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicToWorldScaleX'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLogicToWorldScaleX of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetLogicToWorldScaleX00
static int tolua_engineWin32_Nuclear_ConfigManager_SetLogicToWorldScaleX00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  float fScale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLogicToWorldScaleX'", NULL);
#endif
  {
   self->SetLogicToWorldScaleX(fScale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLogicToWorldScaleX'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderNightEffectByShader of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectByShader00
static int tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectByShader00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderNightEffectByShader'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderNightEffectByShader();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderNightEffectByShader'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderNightEffectByShader of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectByShader00
static int tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectByShader00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderNightEffectByShader'", NULL);
#endif
  {
   self->SetRenderNightEffectByShader(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderNightEffectByShader'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderNightEffectWithRenderTarget of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectWithRenderTarget00
static int tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectWithRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderNightEffectWithRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderNightEffectWithRenderTarget();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderNightEffectWithRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderNightEffectWithRenderTarget of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectWithRenderTarget00
static int tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectWithRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderNightEffectWithRenderTarget'", NULL);
#endif
  {
   self->SetRenderNightEffectWithRenderTarget(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderNightEffectWithRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableMaskPic of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsEnableMaskPic00
static int tolua_engineWin32_Nuclear_ConfigManager_IsEnableMaskPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableMaskPic'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableMaskPic();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableMaskPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableMaskPic of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetEnableMaskPic00
static int tolua_engineWin32_Nuclear_ConfigManager_SetEnableMaskPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableMaskPic'", NULL);
#endif
  {
   self->SetEnableMaskPic(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableMaskPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderSpriteShadow of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsRenderSpriteShadow00
static int tolua_engineWin32_Nuclear_ConfigManager_IsRenderSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderSpriteShadow'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderSpriteShadow();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderSpriteShadow of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetRenderSpriteShadow00
static int tolua_engineWin32_Nuclear_ConfigManager_SetRenderSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderSpriteShadow'", NULL);
#endif
  {
   self->SetRenderSpriteShadow(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsBlurForTeleport of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsBlurForTeleport00
static int tolua_engineWin32_Nuclear_ConfigManager_IsBlurForTeleport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsBlurForTeleport'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsBlurForTeleport();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsBlurForTeleport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBlurForTeleport of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetBlurForTeleport00
static int tolua_engineWin32_Nuclear_ConfigManager_SetBlurForTeleport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBlurForTeleport'", NULL);
#endif
  {
   self->SetBlurForTeleport(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBlurForTeleport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSystemLevel of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetSystemLevel00
static int tolua_engineWin32_Nuclear_ConfigManager_GetSystemLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSystemLevel'", NULL);
#endif
  {
   Nuclear::NuclearComputerConfigType tolua_ret = (Nuclear::NuclearComputerConfigType)  self->GetSystemLevel();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSystemLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSystemLevel of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSystemLevel00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSystemLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearComputerConfigType l = ((Nuclear::NuclearComputerConfigType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSystemLevel'", NULL);
#endif
  {
   self->SetSystemLevel(l);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSystemLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSmoothMove of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsSmoothMove00
static int tolua_engineWin32_Nuclear_ConfigManager_IsSmoothMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSmoothMove'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSmoothMove();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSmoothMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSmoothMove of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSmoothMove00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSmoothMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSmoothMove'", NULL);
#endif
  {
   self->SetSmoothMove(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSmoothMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMinDelta of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetMinDelta00
static int tolua_engineWin32_Nuclear_ConfigManager_GetMinDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMinDelta'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMinDelta();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMinDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMinDelta of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetMinDelta00
static int tolua_engineWin32_Nuclear_ConfigManager_SetMinDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMinDelta'", NULL);
#endif
  {
   self->SetMinDelta(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMinDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaxDiffDelta of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffDelta00
static int tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaxDiffDelta'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMaxDiffDelta();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxDiffDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaxDiffDelta of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffDelta00
static int tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaxDiffDelta'", NULL);
#endif
  {
   self->SetMaxDiffDelta(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaxDiffDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaxDiffFromAvg of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffFromAvg00
static int tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffFromAvg00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaxDiffFromAvg'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMaxDiffFromAvg();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxDiffFromAvg'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaxDiffFromAvg of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffFromAvg00
static int tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffFromAvg00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaxDiffFromAvg'", NULL);
#endif
  {
   self->SetMaxDiffFromAvg(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaxDiffFromAvg'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetUnloadMapBGSoundFadeOutTime of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetUnloadMapBGSoundFadeOutTime00
static int tolua_engineWin32_Nuclear_ConfigManager_GetUnloadMapBGSoundFadeOutTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetUnloadMapBGSoundFadeOutTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetUnloadMapBGSoundFadeOutTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetUnloadMapBGSoundFadeOutTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetUnloadMapBGSoundFadeOutTime of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetUnloadMapBGSoundFadeOutTime00
static int tolua_engineWin32_Nuclear_ConfigManager_SetUnloadMapBGSoundFadeOutTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetUnloadMapBGSoundFadeOutTime'", NULL);
#endif
  {
   self->SetUnloadMapBGSoundFadeOutTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetUnloadMapBGSoundFadeOutTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBGMType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetBGMType00
static int tolua_engineWin32_Nuclear_ConfigManager_GetBGMType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBGMType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetBGMType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBGMType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBGMType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetBGMType00
static int tolua_engineWin32_Nuclear_ConfigManager_SetBGMType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBGMType'", NULL);
#endif
  {
   self->SetBGMType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBGMType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEnvSoundType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetEnvSoundType00
static int tolua_engineWin32_Nuclear_ConfigManager_GetEnvSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEnvSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetEnvSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEnvSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnvSoundType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetEnvSoundType00
static int tolua_engineWin32_Nuclear_ConfigManager_SetEnvSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnvSoundType'", NULL);
#endif
  {
   self->SetEnvSoundType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnvSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepSoundType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundType00
static int tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetStepSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepSoundType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundType00
static int tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepSoundType'", NULL);
#endif
  {
   self->SetStepSoundType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepSoundPriority of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundPriority00
static int tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepSoundPriority'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetStepSoundPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepSoundPriority of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundPriority00
static int tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  short p = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepSoundPriority'", NULL);
#endif
  {
   self->SetStepSoundPriority(p);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetConsoleInfo of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetConsoleInfo00
static int tolua_engineWin32_Nuclear_ConfigManager_SetConsoleInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearConsoleInfo eInfo = ((Nuclear::NuclearConsoleInfo) (int)  tolua_tonumber(tolua_S,2,0));
  bool bOn = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetConsoleInfo'", NULL);
#endif
  {
   self->SetConsoleInfo(eInfo,bOn);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetConsoleInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestConsoleInfo of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_TestConsoleInfo00
static int tolua_engineWin32_Nuclear_ConfigManager_TestConsoleInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearConsoleInfo eInfo = ((Nuclear::NuclearConsoleInfo) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestConsoleInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestConsoleInfo(eInfo);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestConsoleInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameStateInfo of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateInfo00
static int tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
  bool bOn = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameStateInfo'", NULL);
#endif
  {
   self->SetFrameStateInfo(type,bOn);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameStateInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestFrameStateInfo of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_TestFrameStateInfo00
static int tolua_engineWin32_Nuclear_ConfigManager_TestFrameStateInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestFrameStateInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestFrameStateInfo(type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestFrameStateInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameStateColor of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateColor00
static int tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameStateColor'", NULL);
#endif
  {
   self->SetFrameStateColor(type,color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameStateColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameStateColor of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetFrameStateColor00
static int tolua_engineWin32_Nuclear_ConfigManager_GetFrameStateColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameStateColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetFrameStateColor(type);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameStateColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsDynamicMapLoading of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsDynamicMapLoading00
static int tolua_engineWin32_Nuclear_ConfigManager_IsDynamicMapLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsDynamicMapLoading'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsDynamicMapLoading();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsDynamicMapLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDynamicMapLoading of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetDynamicMapLoading00
static int tolua_engineWin32_Nuclear_ConfigManager_SetDynamicMapLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDynamicMapLoading'", NULL);
#endif
  {
   self->SetDynamicMapLoading(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDynamicMapLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsControlFPS of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsControlFPS00
static int tolua_engineWin32_Nuclear_ConfigManager_IsControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsControlFPS'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsControlFPS();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetControlFPS of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS00
static int tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetControlFPS'", NULL);
#endif
  {
   self->SetControlFPS(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetControlFPS of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS01
static int tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
  int fps = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetControlFPS'", NULL);
#endif
  {
   self->SetControlFPS(type,fps);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetControlFPS of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetControlFPS00
static int tolua_engineWin32_Nuclear_ConfigManager_GetControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetControlFPS'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetControlFPS(type);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSortMapObjects of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsSortMapObjects00
static int tolua_engineWin32_Nuclear_ConfigManager_IsSortMapObjects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSortMapObjects'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSortMapObjects();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSortMapObjects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSortMapObjects of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSortMapObjects00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSortMapObjects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSortMapObjects'", NULL);
#endif
  {
   self->SetSortMapObjects(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSortMapObjects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsUseSurfaceCache of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsUseSurfaceCache00
static int tolua_engineWin32_Nuclear_ConfigManager_IsUseSurfaceCache00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsUseSurfaceCache'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsUseSurfaceCache();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsUseSurfaceCache'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetUseSurfaceCache of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetUseSurfaceCache00
static int tolua_engineWin32_Nuclear_ConfigManager_SetUseSurfaceCache00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetUseSurfaceCache'", NULL);
#endif
  {
   self->SetUseSurfaceCache(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetUseSurfaceCache'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSyncBeforeWater of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsSyncBeforeWater00
static int tolua_engineWin32_Nuclear_ConfigManager_IsSyncBeforeWater00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSyncBeforeWater'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSyncBeforeWater();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSyncBeforeWater'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSyncBeforeWater of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSyncBeforeWater00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSyncBeforeWater00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSyncBeforeWater'", NULL);
#endif
  {
   self->SetSyncBeforeWater(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSyncBeforeWater'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableLinkedObjs of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetEnableLinkedObjs00
static int tolua_engineWin32_Nuclear_ConfigManager_SetEnableLinkedObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableLinkedObjs'", NULL);
#endif
  {
   self->SetEnableLinkedObjs(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableLinkedObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableLinkedObjs of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsEnableLinkedObjs00
static int tolua_engineWin32_Nuclear_ConfigManager_IsEnableLinkedObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableLinkedObjs'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableLinkedObjs();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableLinkedObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowSpritePath of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsShowSpritePath00
static int tolua_engineWin32_Nuclear_ConfigManager_IsShowSpritePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowSpritePath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowSpritePath();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowSpritePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShowSpritePath of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetShowSpritePath00
static int tolua_engineWin32_Nuclear_ConfigManager_SetShowSpritePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShowSpritePath'", NULL);
#endif
  {
   self->SetShowSpritePath(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShowSpritePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowSpriteTrail of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsShowSpriteTrail00
static int tolua_engineWin32_Nuclear_ConfigManager_IsShowSpriteTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowSpriteTrail'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowSpriteTrail();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowSpriteTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShowSpriteTrail of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetShowSpriteTrail00
static int tolua_engineWin32_Nuclear_ConfigManager_SetShowSpriteTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShowSpriteTrail'", NULL);
#endif
  {
   self->SetShowSpriteTrail(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShowSpriteTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowMazeGrid of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsShowMazeGrid00
static int tolua_engineWin32_Nuclear_ConfigManager_IsShowMazeGrid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowMazeGrid'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowMazeGrid();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowMazeGrid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShowMazeGrid of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetShowMazeGrid00
static int tolua_engineWin32_Nuclear_ConfigManager_SetShowMazeGrid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShowMazeGrid'", NULL);
#endif
  {
   self->SetShowMazeGrid(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShowMazeGrid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMazeMask of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetMazeMask00
static int tolua_engineWin32_Nuclear_ConfigManager_GetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ConfigManager* self = (const Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMazeMask'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetMazeMask();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMazeMask of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetMazeMask00
static int tolua_engineWin32_Nuclear_ConfigManager_SetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  unsigned int mask = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMazeMask'", NULL);
#endif
  {
   self->SetMazeMask(mask);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteTranslucentType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetSpriteTranslucentType00
static int tolua_engineWin32_Nuclear_ConfigManager_GetSpriteTranslucentType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteTranslucentType'", NULL);
#endif
  {
   Nuclear::NuclearSpriteTranslucentType tolua_ret = (Nuclear::NuclearSpriteTranslucentType)  self->GetSpriteTranslucentType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteTranslucentType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteTranslucentType of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetSpriteTranslucentType00
static int tolua_engineWin32_Nuclear_ConfigManager_SetSpriteTranslucentType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteTranslucentType t = ((Nuclear::NuclearSpriteTranslucentType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteTranslucentType'", NULL);
#endif
  {
   self->SetSpriteTranslucentType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteTranslucentType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaskAlpha of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_GetMaskAlpha00
static int tolua_engineWin32_Nuclear_ConfigManager_GetMaskAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaskAlpha'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetMaskAlpha();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaskAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskAlpha of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetMaskAlpha00
static int tolua_engineWin32_Nuclear_ConfigManager_SetMaskAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  float f = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskAlpha'", NULL);
#endif
  {
   self->SetMaskAlpha(f);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaskAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderSolidMask of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_IsRenderSolidMask00
static int tolua_engineWin32_Nuclear_ConfigManager_IsRenderSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderSolidMask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderSolidMask();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderSolidMask of class  Nuclear::ConfigManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ConfigManager_SetRenderSolidMask00
static int tolua_engineWin32_Nuclear_ConfigManager_SetRenderSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ConfigManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ConfigManager* self = (Nuclear::ConfigManager*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderSolidMask'", NULL);
#endif
  {
   self->SetRenderSolidMask(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_new00
static int tolua_engineWin32_Nuclear_EffectManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::EffectManager* tolua_ret = (Nuclear::EffectManager*)  Mtolua_new((Nuclear::EffectManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EffectManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_new00_local
static int tolua_engineWin32_Nuclear_EffectManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::EffectManager* tolua_ret = (Nuclear::EffectManager*)  Mtolua_new((Nuclear::EffectManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EffectManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_delete00
static int tolua_engineWin32_Nuclear_EffectManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateEffect of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_CreateEffect00
static int tolua_engineWin32_Nuclear_EffectManager_CreateEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
  std::wstring name = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool cycle = ((bool)  tolua_toboolean(tolua_S,3,0));
  bool bPreLoad = ((bool)  tolua_toboolean(tolua_S,4,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateEffect'", NULL);
#endif
  {
   Nuclear::Effect* tolua_ret = (Nuclear::Effect*)  self->CreateEffect(name,cycle,bPreLoad);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Effect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateLinkedEffect of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_CreateLinkedEffect00
static int tolua_engineWin32_Nuclear_EffectManager_CreateLinkedEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
  std::wstring name = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::NuclearPoint* pt1 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  const Nuclear::NuclearPoint* pt2 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  float time = ((float)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateLinkedEffect'", NULL);
#endif
  {
   Nuclear::ParticleEffect* tolua_ret = (Nuclear::ParticleEffect*)  self->CreateLinkedEffect(name,*pt1,*pt2,time);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ParticleEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateLinkedEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateListEffect of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_CreateListEffect00
static int tolua_engineWin32_Nuclear_EffectManager_CreateListEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring begin = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring midcyc = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring end = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  int durTime = ((int)  tolua_tonumber(tolua_S,5,0));
  bool cycle = ((bool)  tolua_toboolean(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
  bool removesound = ((bool)  tolua_toboolean(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateListEffect'", NULL);
#endif
  {
   Nuclear::Effect* tolua_ret = (Nuclear::Effect*)  self->CreateListEffect(begin,midcyc,end,durTime,cycle,async,removesound);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Effect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)begin);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)midcyc);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)end);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateListEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTick of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_OnTick00
static int tolua_engineWin32_Nuclear_EffectManager_OnTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTick'", NULL);
#endif
  {
   self->OnTick();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEffect of class  Nuclear::EffectManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EffectManager_RemoveEffect00
static int tolua_engineWin32_Nuclear_EffectManager_RemoveEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EffectManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EffectManager* self = (Nuclear::EffectManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEffect'", NULL);
#endif
  {
   self->RemoveEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IParticleManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleManager_delete00
static int tolua_engineWin32_Nuclear_IParticleManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleManager* self = (Nuclear::IParticleManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPriority of class  Task */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Task_GetPriority00
static int tolua_engineWin32_Nuclear_ExecThread_Task_GetPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPriority'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Task */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Task_delete00
static int tolua_engineWin32_Nuclear_ExecThread_Task_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Execute of class  Task */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Task_Execute00
static int tolua_engineWin32_Nuclear_ExecThread_Task_Execute00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Execute'", NULL);
#endif
  {
   self->Execute();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Execute'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnexecuteAndDestroy of class  Task */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Task_UnexecuteAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_Task_UnexecuteAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnexecuteAndDestroy'", NULL);
#endif
  {
   self->UnexecuteAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnexecuteAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ExecuteEndAndDestroy of class  Task */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Task_ExecuteEndAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_Task_ExecuteEndAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::Task* self = (Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ExecuteEndAndDestroy'", NULL);
#endif
  {
   self->ExecuteEndAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ExecuteEndAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ExecuteEndAndDestroy of class  SimpleTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_SimpleTask_ExecuteEndAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_SimpleTask_ExecuteEndAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::SimpleTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::SimpleTask* self = (Nuclear::ExecThread::SimpleTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ExecuteEndAndDestroy'", NULL);
#endif
  {
   self->ExecuteEndAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ExecuteEndAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnexecuteAndDestroy of class  SimpleTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_SimpleTask_UnexecuteAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_SimpleTask_UnexecuteAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::SimpleTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::SimpleTask* self = (Nuclear::ExecThread::SimpleTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnexecuteAndDestroy'", NULL);
#endif
  {
   self->UnexecuteAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnexecuteAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Execute of class  SimpleTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Execute00
static int tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Execute00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::SimpleTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::SimpleTask* self = (Nuclear::ExecThread::SimpleTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Execute'", NULL);
#endif
  {
   self->Execute();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Execute'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  SimpleTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Destroy00
static int tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::SimpleTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::SimpleTask* self = (Nuclear::ExecThread::SimpleTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   self->Destroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Cancel of class  CallbackTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Cancel00
static int tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Cancel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::CallbackTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::CallbackTask* self = (Nuclear::ExecThread::CallbackTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Cancel'", NULL);
#endif
  {
   self->Cancel();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cancel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ExecuteEndAndDestroy of class  CallbackTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_CallbackTask_ExecuteEndAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_CallbackTask_ExecuteEndAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::CallbackTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::CallbackTask* self = (Nuclear::ExecThread::CallbackTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ExecuteEndAndDestroy'", NULL);
#endif
  {
   self->ExecuteEndAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ExecuteEndAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnexecuteAndDestroy of class  CallbackTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_CallbackTask_UnexecuteAndDestroy00
static int tolua_engineWin32_Nuclear_ExecThread_CallbackTask_UnexecuteAndDestroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::CallbackTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::CallbackTask* self = (Nuclear::ExecThread::CallbackTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnexecuteAndDestroy'", NULL);
#endif
  {
   self->UnexecuteAndDestroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnexecuteAndDestroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Execute of class  CallbackTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Execute00
static int tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Execute00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::CallbackTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::CallbackTask* self = (Nuclear::ExecThread::CallbackTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Execute'", NULL);
#endif
  {
   self->Execute();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Execute'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Callback of class  CallbackTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Callback00
static int tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Callback00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread::CallbackTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread::CallbackTask* self = (Nuclear::ExecThread::CallbackTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Callback'", NULL);
#endif
  {
   self->Callback();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Callback'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_new00
static int tolua_engineWin32_Nuclear_ExecThread_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ExecThread* tolua_ret = (Nuclear::ExecThread*)  Mtolua_new((Nuclear::ExecThread)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ExecThread");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_new00_local
static int tolua_engineWin32_Nuclear_ExecThread_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ExecThread* tolua_ret = (Nuclear::ExecThread*)  Mtolua_new((Nuclear::ExecThread)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ExecThread");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_delete00
static int tolua_engineWin32_Nuclear_ExecThread_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread* self = (Nuclear::ExecThread*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Init00
static int tolua_engineWin32_Nuclear_ExecThread_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread* self = (Nuclear::ExecThread*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Init();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_Destroy00
static int tolua_engineWin32_Nuclear_ExecThread_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread* self = (Nuclear::ExecThread*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Destroy();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddTask of class  Nuclear::ExecThread */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ExecThread_AddTask00
static int tolua_engineWin32_Nuclear_ExecThread_AddTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ExecThread",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ExecThread* self = (Nuclear::ExecThread*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ExecThread::Task* pTask = ((Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddTask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AddTask(pTask);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::INuclearFileIO */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearFileIO_delete00
static int tolua_engineWin32_Nuclear_INuclearFileIO_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearFileIO",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearFileIO* self = (Nuclear::INuclearFileIO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileImage of class  Nuclear::INuclearFileIO */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_INuclearFileIO_GetFileImage00
static int tolua_engineWin32_Nuclear_INuclearFileIO_GetFileImage00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::INuclearFileIO",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearBuffer",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::INuclearFileIO* self = (Nuclear::INuclearFileIO*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::NuclearBuffer* data = ((Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,3,0));
  bool lookupSegmPakPath = ((bool)  tolua_toboolean(tolua_S,4,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileImage'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetFileImage(filename,*data,lookupSegmPakPath);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileImage'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIOManager of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileIOManager00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileIOManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIOManager'", NULL);
#endif
  {
   Nuclear::NuclearFileIOManager* tolua_ret = (Nuclear::NuclearFileIOManager*)  self->GetFileIOManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFileIOManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIOManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileName of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileName00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileName'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetFileName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetData of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetData00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetData00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetData'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->GetData();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetData'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Submit of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Submit00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Submit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Submit'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Submit();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Submit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Discard of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Discard00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Discard00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Discard'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Discard();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Discard'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsDiscarded of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_IsDiscarded00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_IsDiscarded00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsDiscarded'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsDiscarded();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsDiscarded'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnReady of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnReady00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnReady'", NULL);
#endif
  {
   self->OnReady();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnDiscard of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnDiscard00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnDiscard00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnDiscard'", NULL);
#endif
  {
   self->OnDiscard();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnDiscard'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Execute of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Execute00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Execute00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Execute'", NULL);
#endif
  {
   self->Execute();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Execute'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Callback of class  AsyncReadTask */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Callback00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Callback00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager::AsyncReadTask* self = (Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Callback'", NULL);
#endif
  {
   self->Callback();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Callback'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_new00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearFileIOManager* tolua_ret = (Nuclear::NuclearFileIOManager*)  Mtolua_new((Nuclear::NuclearFileIOManager)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFileIOManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_new00_local
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearFileIOManager* tolua_ret = (Nuclear::NuclearFileIOManager*)  Mtolua_new((Nuclear::NuclearFileIOManager)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFileIOManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_delete00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_Init00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  bool bWritableDefault = ((bool)  tolua_toboolean(tolua_S,2,0));
  bool bApplictionInBuild = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Init(bWritableDefault,bApplictionInBuild);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_Destroy00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Destroy();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnUpdate of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_OnUpdate00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_OnUpdate00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  int64 v = ((int64)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnUpdate'", NULL);
#endif
  {
   self->OnUpdate(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnUpdate'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurrentDirectory of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetCurrentDirectory00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetCurrentDirectory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurrentDirectory'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetCurrentDirectory();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurrentDirectory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddTask of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AddTask00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AddTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ExecThread::Task",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ExecThread::Task* pTask = ((Nuclear::ExecThread::Task*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddTask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AddTask(pTask);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AsyncReadFile of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadFile00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadFile00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFileIOManager::AsyncReadTask* pTask = ((Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AsyncReadFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AsyncReadFile(pTask);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AsyncReadFile'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnAsyncReadFileNotify of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_OnAsyncReadFileNotify00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_OnAsyncReadFileNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager::AsyncReadTask",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFileIOManager::AsyncReadTask* pTask = ((Nuclear::NuclearFileIOManager::AsyncReadTask*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnAsyncReadFileNotify'", NULL);
#endif
  {
   self->OnAsyncReadFileNotify(pTask);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnAsyncReadFileNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIOTaskCount of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskCount00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIOTaskCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFileIOTaskCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIOTaskCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIOTaskBytes of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskBytes00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskBytes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIOTaskBytes'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFileIOTaskBytes();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIOTaskBytes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetQueueOfIOTaskSize of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetQueueOfIOTaskSize00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetQueueOfIOTaskSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetQueueOfIOTaskSize'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->GetQueueOfIOTaskSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetQueueOfIOTaskSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetUpdateTimePerFrame of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_SetUpdateTimePerFrame00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_SetUpdateTimePerFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetUpdateTimePerFrame'", NULL);
#endif
  {
   self->SetUpdateTimePerFrame(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetUpdateTimePerFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetUpdateTimePerFrame of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetUpdateTimePerFrame00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetUpdateTimePerFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetUpdateTimePerFrame'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetUpdateTimePerFrame();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetUpdateTimePerFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_OnTimer00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  int iPeriod = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer(iPeriod);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnReady of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_OnReady00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_OnReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
  int iTime = ((int)  tolua_tonumber(tolua_S,2,0));
  int iSize = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnReady'", NULL);
#endif
  {
   self->OnReady(iTime,iSize);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAverageReadSpeed of class  Nuclear::NuclearFileIOManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearFileIOManager_GetAverageReadSpeed00
static int tolua_engineWin32_Nuclear_NuclearFileIOManager_GetAverageReadSpeed00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* self = (Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAverageReadSpeed'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetAverageReadSpeed();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAverageReadSpeed'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::ISelectableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISelectableObj_new00
static int tolua_engineWin32_Nuclear_ISelectableObj_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ISelectableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ISelectableObj* tolua_ret = (Nuclear::ISelectableObj*)  Mtolua_new((Nuclear::ISelectableObj)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISelectableObj");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::ISelectableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISelectableObj_new00_local
static int tolua_engineWin32_Nuclear_ISelectableObj_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ISelectableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ISelectableObj* tolua_ret = (Nuclear::ISelectableObj*)  Mtolua_new((Nuclear::ISelectableObj)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISelectableObj");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ISelectableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISelectableObj_delete00
static int tolua_engineWin32_Nuclear_ISelectableObj_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISelectableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISelectableObj* self = (Nuclear::ISelectableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_delete00
static int tolua_engineWin32_Nuclear_IImmovableObj_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetLocation00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* location = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(*location);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLocation of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetLocation00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLocation'", NULL);
#endif
  {
    Nuclear::NuclearPoint tolua_ret = (  Nuclear::NuclearPoint)  self->GetLocation();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetDirection00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearDirection direction = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(direction);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirection of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetDirection00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirection'", NULL);
#endif
  {
   Nuclear::NuclearDirection tolua_ret = (Nuclear::NuclearDirection)  self->GetDirection();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetVisible of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetVisible00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetVisible'", NULL);
#endif
  {
   self->SetVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVisiable of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_IsVisiable00
static int tolua_engineWin32_Nuclear_IImmovableObj_IsVisiable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVisiable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVisiable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsVisiable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEntityVisible of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetEntityVisible00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetEntityVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEntityVisible'", NULL);
#endif
  {
   self->SetEntityVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEntityVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEntityVisible of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_IsEntityVisible00
static int tolua_engineWin32_Nuclear_IImmovableObj_IsEntityVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEntityVisible'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEntityVisible();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEntityVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitleVisible of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetTitleVisible00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetTitleVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitleVisible'", NULL);
#endif
  {
   self->SetTitleVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitleVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTitleVisible of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_IsTitleVisible00
static int tolua_engineWin32_Nuclear_IImmovableObj_IsTitleVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTitleVisible'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTitleVisible();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTitleVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitle of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetTitle00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearTitleAlign align = ((Nuclear::NuclearTitleAlign) (int)  tolua_tonumber(tolua_S,3,Nuclear::XPTA_DEFAULT));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitle'", NULL);
#endif
  {
   self->SetTitle(handle,align);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitle of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetTitle00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitle'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->GetTitle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnsetTitle of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_UnsetTitle00
static int tolua_engineWin32_Nuclear_IImmovableObj_UnsetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnsetTitle'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->UnsetTitle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnsetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitleSize of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetTitleSize00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetTitleSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  int width = ((int)  tolua_tonumber(tolua_S,2,0));
  int height = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitleSize'", NULL);
#endif
  {
   self->SetTitleSize(width,height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitleSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitleWidth of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetTitleWidth00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetTitleWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitleWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTitleWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitleWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitleHeight of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetTitleHeight00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetTitleHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitleHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTitleHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitleHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetHighlight of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetHighlight00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetHighlight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetHighlight'", NULL);
#endif
  {
   self->SetHighlight(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetHighlight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsHighlight of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_IsHighlight00
static int tolua_engineWin32_Nuclear_IImmovableObj_IsHighlight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsHighlight'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsHighlight();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsHighlight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTestAlpha of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetTestAlpha00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetTestAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTestAlpha'", NULL);
#endif
  {
   self->SetTestAlpha(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTestAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTestAlpha of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_IsTestAlpha00
static int tolua_engineWin32_Nuclear_IImmovableObj_IsTestAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTestAlpha'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTestAlpha();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTestAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMouseTestMode of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_SetMouseTestMode00
static int tolua_engineWin32_Nuclear_IImmovableObj_SetMouseTestMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IImmovableObj* self = (Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_Mouse_TestMode m = ((Nuclear::Nuclear_Mouse_TestMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMouseTestMode'", NULL);
#endif
  {
   self->SetMouseTestMode(m);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMouseTestMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMouseTestMode of class  Nuclear::IImmovableObj */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IImmovableObj_GetMouseTestMode00
static int tolua_engineWin32_Nuclear_IImmovableObj_GetMouseTestMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IImmovableObj* self = (const Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMouseTestMode'", NULL);
#endif
  {
   Nuclear::Nuclear_Mouse_TestMode tolua_ret = (Nuclear::Nuclear_Mouse_TestMode)  self->GetMouseTestMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMouseTestMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Load of class  Nuclear::HorseHeight */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_HorseHeight_Load00
static int tolua_engineWin32_Nuclear_HorseHeight_Load00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::HorseHeight",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::HorseHeight* self = (Nuclear::HorseHeight*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFileIOManager* pFileIOMan = ((Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Load'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Load(pFileIOMan,modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Load'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Save of class  Nuclear::HorseHeight */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_HorseHeight_Save00
static int tolua_engineWin32_Nuclear_HorseHeight_Save00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::HorseHeight",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::HorseHeight* self = (const Nuclear::HorseHeight*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFileIOManager* pFileIOMan = ((Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Save'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Save(pFileIOMan,modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Save'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetHeight of class  Nuclear::HorseHeight */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_HorseHeight_GetHeight00
static int tolua_engineWin32_Nuclear_HorseHeight_GetHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::HorseHeight",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::HorseHeight* self = (Nuclear::HorseHeight*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring horsename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetHeight(horsename);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)horsename);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetHeight of class  Nuclear::HorseHeight */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_HorseHeight_SetHeight00
static int tolua_engineWin32_Nuclear_HorseHeight_SetHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::HorseHeight",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::HorseHeight* self = (Nuclear::HorseHeight*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring horsename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int height = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetHeight'", NULL);
#endif
  {
   self->SetHeight(horsename,height);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)horsename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: soundname of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteSoundParam_soundname
static int tolua_get_Nuclear__SpriteSoundParam_soundname(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'soundname'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->soundname);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: soundname of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteSoundParam_soundname
static int tolua_set_Nuclear__SpriteSoundParam_soundname(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'soundname'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->soundname = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: vol of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteSoundParam_unsigned_vol
static int tolua_get_Nuclear__SpriteSoundParam_unsigned_vol(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'vol'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->vol);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: vol of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteSoundParam_unsigned_vol
static int tolua_set_Nuclear__SpriteSoundParam_unsigned_vol(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'vol'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->vol = ((unsigned char)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: freq of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteSoundParam_unsigned_freq
static int tolua_get_Nuclear__SpriteSoundParam_unsigned_freq(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'freq'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->freq);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: freq of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteSoundParam_unsigned_freq
static int tolua_set_Nuclear__SpriteSoundParam_unsigned_freq(lua_State* tolua_S)
{
  Nuclear::SpriteSoundParam* self = (Nuclear::SpriteSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'freq'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->freq = ((unsigned char)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteSoundParam_new00
static int tolua_engineWin32_Nuclear_SpriteSoundParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteSoundParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::SpriteSoundParam* tolua_ret = (Nuclear::SpriteSoundParam*)  Mtolua_new((Nuclear::SpriteSoundParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteSoundParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::SpriteSoundParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteSoundParam_new00_local
static int tolua_engineWin32_Nuclear_SpriteSoundParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteSoundParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::SpriteSoundParam* tolua_ret = (Nuclear::SpriteSoundParam*)  Mtolua_new((Nuclear::SpriteSoundParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteSoundParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: keyComponentID of class  Nuclear::ModelSoundParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__ModelSoundParam_keyComponentID
static int tolua_get_Nuclear__ModelSoundParam_keyComponentID(lua_State* tolua_S)
{
  Nuclear::ModelSoundParam* self = (Nuclear::ModelSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'keyComponentID'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->keyComponentID);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: keyComponentID of class  Nuclear::ModelSoundParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__ModelSoundParam_keyComponentID
static int tolua_set_Nuclear__ModelSoundParam_keyComponentID(lua_State* tolua_S)
{
  Nuclear::ModelSoundParam* self = (Nuclear::ModelSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'keyComponentID'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->keyComponentID = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::ModelSoundParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ModelSoundParam_new00
static int tolua_engineWin32_Nuclear_ModelSoundParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ModelSoundParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ModelSoundParam* tolua_ret = (Nuclear::ModelSoundParam*)  Mtolua_new((Nuclear::ModelSoundParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ModelSoundParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::ModelSoundParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ModelSoundParam_new00_local
static int tolua_engineWin32_Nuclear_ModelSoundParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ModelSoundParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ModelSoundParam* tolua_ret = (Nuclear::ModelSoundParam*)  Mtolua_new((Nuclear::ModelSoundParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ModelSoundParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearSoundMap of class  Nuclear::ModelSoundParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ModelSoundParam_ClearSoundMap00
static int tolua_engineWin32_Nuclear_ModelSoundParam_ClearSoundMap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ModelSoundParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ModelSoundParam* self = (Nuclear::ModelSoundParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearSoundMap'", NULL);
#endif
  {
   self->ClearSoundMap();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearSoundMap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_new00
static int tolua_engineWin32_Nuclear_ActionType_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ActionType* tolua_ret = (Nuclear::ActionType*)  Mtolua_new((Nuclear::ActionType)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ActionType");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_new00_local
static int tolua_engineWin32_Nuclear_ActionType_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::ActionType* tolua_ret = (Nuclear::ActionType*)  Mtolua_new((Nuclear::ActionType)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ActionType");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_delete00
static int tolua_engineWin32_Nuclear_ActionType_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ActionType* self = (Nuclear::ActionType*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_Init00
static int tolua_engineWin32_Nuclear_ActionType_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ActionType* self = (Nuclear::ActionType*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFileIOManager* pFileIOMan = ((Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   self->Init(pFileIOMan);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Load of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_Load00
static int tolua_engineWin32_Nuclear_ActionType_Load00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ActionType* self = (Nuclear::ActionType*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Load'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Load();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Load'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionType of class  Nuclear::ActionType */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ActionType_GetActionType00
static int tolua_engineWin32_Nuclear_ActionType_GetActionType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ActionType",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ActionType* self = (Nuclear::ActionType*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionType'", NULL);
#endif
  {
   unsigned short tolua_ret = ( unsigned short)  self->GetActionType(name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_new00
static int tolua_engineWin32_Nuclear_Action_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::Action* tolua_ret = (Nuclear::Action*)  Mtolua_new((Nuclear::Action)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Action");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_new00_local
static int tolua_engineWin32_Nuclear_Action_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::Action* tolua_ret = (Nuclear::Action*)  Mtolua_new((Nuclear::Action)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Action");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLineFrame of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetLineFrame00
static int tolua_engineWin32_Nuclear_Action_GetLineFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLineFrame'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLineFrame(seq);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLineFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDir of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetDir00
static int tolua_engineWin32_Nuclear_Action_SetDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDir'", NULL);
#endif
  {
   self->SetDir(dir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearDir of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_ClearDir00
static int tolua_engineWin32_Nuclear_Action_ClearDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearDir'", NULL);
#endif
  {
   self->ClearDir(dir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestDir of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_TestDir00
static int tolua_engineWin32_Nuclear_Action_TestDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestDir'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestDir(dir);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirMask of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetDirMask00
static int tolua_engineWin32_Nuclear_Action_GetDirMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirMask'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetDirMask();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEquip of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetEquip00
static int tolua_engineWin32_Nuclear_Action_SetEquip00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int ec = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEquip'", NULL);
#endif
  {
   self->SetEquip(ec);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEquip'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearEquip of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_ClearEquip00
static int tolua_engineWin32_Nuclear_Action_ClearEquip00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int ec = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearEquip'", NULL);
#endif
  {
   self->ClearEquip(ec);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearEquip'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestEquip of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_TestEquip00
static int tolua_engineWin32_Nuclear_Action_TestEquip00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int ec = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestEquip'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestEquip(ec);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestEquip'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEquipMask of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetEquipMask00
static int tolua_engineWin32_Nuclear_Action_GetEquipMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEquipMask'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetEquipMask();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEquipMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEquipMask of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetEquipMask00
static int tolua_engineWin32_Nuclear_Action_SetEquipMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int m = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEquipMask'", NULL);
#endif
  {
   self->SetEquipMask(m);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEquipMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsInd of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_IsInd00
static int tolua_engineWin32_Nuclear_Action_IsInd00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsInd'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsInd();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsInd'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetInd of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetInd00
static int tolua_engineWin32_Nuclear_Action_SetInd00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  bool f = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetInd'", NULL);
#endif
  {
   self->SetInd(f);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetInd'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameLink of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetFrameLink00
static int tolua_engineWin32_Nuclear_Action_SetFrameLink00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring n = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int f = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameLink'", NULL);
#endif
  {
   self->SetFrameLink(seq,n,f);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)n);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameLink'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameOrder of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetFrameOrder00
static int tolua_engineWin32_Nuclear_Action_SetFrameOrder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
  int dir = ((int)  tolua_tonumber(tolua_S,3,0));
  const int ec = ((const int)  tolua_tonumber(tolua_S,4,0));
  int size = ((int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameOrder'", NULL);
#endif
  {
   self->SetFrameOrder(seq,dir,&ec,size);
   tolua_pushnumber(tolua_S,(lua_Number)ec);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameOrder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameOrder of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetFrameOrder00
static int tolua_engineWin32_Nuclear_Action_GetFrameOrder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Action* self = (const Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
  int dir = ((int)  tolua_tonumber(tolua_S,3,0));
  int ec = ((int)  tolua_tonumber(tolua_S,4,0));
  int size = ((int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameOrder'", NULL);
#endif
  {
   self->GetFrameOrder(seq,dir,&ec,size);
   tolua_pushnumber(tolua_S,(lua_Number)ec);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameOrder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameStartTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetFrameStartTime00
static int tolua_engineWin32_Nuclear_Action_GetFrameStartTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameStartTime'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetFrameStartTime(seq);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameStartTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameStartTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetFrameStartTime00
static int tolua_engineWin32_Nuclear_Action_SetFrameStartTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
  float t = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameStartTime'", NULL);
#endif
  {
   self->SetFrameStartTime(seq,t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameStartTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetFrameTime00
static int tolua_engineWin32_Nuclear_Action_SetFrameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
  int t = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameTime'", NULL);
#endif
  {
   self->SetFrameTime(seq,t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetFrameTime00
static int tolua_engineWin32_Nuclear_Action_GetFrameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int seq = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFrameTime(seq);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameCount of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetFrameCount00
static int tolua_engineWin32_Nuclear_Action_GetFrameCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFrameCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStride of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetStride00
static int tolua_engineWin32_Nuclear_Action_GetStride00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStride'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetStride();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStride'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetTime00
static int tolua_engineWin32_Nuclear_Action_GetTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTime of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetTime00
static int tolua_engineWin32_Nuclear_Action_SetTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int nTime = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTime'", NULL);
#endif
  {
   self->SetTime(nTime);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectPoint of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetEffectPoint00
static int tolua_engineWin32_Nuclear_Action_GetEffectPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectPoint'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetEffectPoint();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDamagePoint of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetDamagePoint00
static int tolua_engineWin32_Nuclear_Action_GetDamagePoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDamagePoint'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetDamagePoint();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDamagePoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDamagePoint of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetDamagePoint00
static int tolua_engineWin32_Nuclear_Action_SetDamagePoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int p = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDamagePoint'", NULL);
#endif
  {
   self->SetDamagePoint(p);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDamagePoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectPoint of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetEffectPoint00
static int tolua_engineWin32_Nuclear_Action_SetEffectPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int p = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectPoint'", NULL);
#endif
  {
   self->SetEffectPoint(p);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStride of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetStride00
static int tolua_engineWin32_Nuclear_Action_SetStride00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int stride = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStride'", NULL);
#endif
  {
   self->SetStride(stride);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStride'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameCount of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetFrameCount00
static int tolua_engineWin32_Nuclear_Action_SetFrameCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int n = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameCount'", NULL);
#endif
  {
   self->SetFrameCount(n);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBoundingBox of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_GetBoundingBox00
static int tolua_engineWin32_Nuclear_Action_GetBoundingBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBoundingBox'", NULL);
#endif
  {
   const Nuclear::NuclearRect& tolua_ret = (const Nuclear::NuclearRect&)  self->GetBoundingBox(dir);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBoundingBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBoundingBox of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_SetBoundingBox00
static int tolua_engineWin32_Nuclear_Action_SetBoundingBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
  int dir = ((int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearRect* rect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBoundingBox'", NULL);
#endif
  {
   self->SetBoundingBox(dir,*rect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBoundingBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsValid of class  Nuclear::Action */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Action_IsValid00
static int tolua_engineWin32_Nuclear_Action_IsValid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Action",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Action* self = (Nuclear::Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsValid'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsValid();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsValid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new00
static int tolua_engineWin32_Nuclear_Component_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new00_local
static int tolua_engineWin32_Nuclear_Component_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new01
static int tolua_engineWin32_Nuclear_Component_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB,layer,name));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Component_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new01_local
static int tolua_engineWin32_Nuclear_Component_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB,layer,name));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Component_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new02
static int tolua_engineWin32_Nuclear_Component_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring linkname = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB,layer,name,linkname));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)linkname);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Component_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_new02_local
static int tolua_engineWin32_Nuclear_Component_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring linkname = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  Mtolua_new((Nuclear::Component)(pEB,layer,name,linkname));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)linkname);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Component_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_delete00
static int tolua_engineWin32_Nuclear_Component_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Release of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_Release00
static int tolua_engineWin32_Nuclear_Component_Release00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Release'", NULL);
#endif
  {
   self->Release();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Release'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsInSegmPak of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_IsInSegmPak00
static int tolua_engineWin32_Nuclear_Component_IsInSegmPak00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsInSegmPak'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsInSegmPak();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsInSegmPak'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSegmPak of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_SetSegmPak00
static int tolua_engineWin32_Nuclear_Component_SetSegmPak00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSegmPak'", NULL);
#endif
  {
   self->SetSegmPak(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSegmPak'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayer of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_GetLayer00
static int tolua_engineWin32_Nuclear_Component_GetLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayer'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLayer();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetName of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_GetName00
static int tolua_engineWin32_Nuclear_Component_GetName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetName'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetConstName of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_GetConstName00
static int tolua_engineWin32_Nuclear_Component_GetConstName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetConstName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetConstName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetConstName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnLoadAniReady of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_OnLoadAniReady00
static int tolua_engineWin32_Nuclear_Component_OnLoadAniReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnLoadAniReady'", NULL);
#endif
  {
   self->OnLoadAniReady(filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnLoadAniReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnLoadAniBaseReady of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_OnLoadAniBaseReady00
static int tolua_engineWin32_Nuclear_Component_OnLoadAniBaseReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnLoadAniBaseReady'", NULL);
#endif
  {
   self->OnLoadAniBaseReady(filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnLoadAniBaseReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseAction of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_ReleaseAction00
static int tolua_engineWin32_Nuclear_Component_ReleaseAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseAction'", NULL);
#endif
  {
   self->ReleaseAction(action_name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetName of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_SetName00
static int tolua_engineWin32_Nuclear_Component_SetName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetName'", NULL);
#endif
  {
   self->SetName(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLinkName of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_SetLinkName00
static int tolua_engineWin32_Nuclear_Component_SetLinkName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring linkname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLinkName'", NULL);
#endif
  {
   self->SetLinkName(linkname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)linkname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLinkName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAction of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_DeleteAction00
static int tolua_engineWin32_Nuclear_Component_DeleteAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAction'", NULL);
#endif
  {
   self->DeleteAction(modelname,name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenameAction of class  Nuclear::Component */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Component_RenameAction00
static int tolua_engineWin32_Nuclear_Component_RenameAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Component",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Component* self = (Nuclear::Component*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring oldname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring newname = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  bool renamexap = ((bool)  tolua_toboolean(tolua_S,5,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenameAction'", NULL);
#endif
  {
   self->RenameAction(modelname,oldname,newname,renamexap);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)oldname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)newname);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenameAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: name of class  Layer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteManager__Layer_name
static int tolua_get_Nuclear__SpriteManager__Layer_name(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'name'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->name);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: name of class  Layer */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteManager__Layer_name
static int tolua_set_Nuclear__SpriteManager__Layer_name(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'name'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->name = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: des of class  Layer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteManager__Layer_des
static int tolua_get_Nuclear__SpriteManager__Layer_des(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'des'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->des);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: des of class  Layer */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteManager__Layer_des
static int tolua_set_Nuclear__SpriteManager__Layer_des(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'des'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->des = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bRide of class  Layer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteManager__Layer_bRide
static int tolua_get_Nuclear__SpriteManager__Layer_bRide(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bRide'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bRide);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bRide of class  Layer */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteManager__Layer_bRide
static int tolua_set_Nuclear__SpriteManager__Layer_bRide(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bRide'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bRide = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bEffect of class  Layer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SpriteManager__Layer_bEffect
static int tolua_get_Nuclear__SpriteManager__Layer_bEffect(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bEffect'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bEffect);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bEffect of class  Layer */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SpriteManager__Layer_bEffect
static int tolua_set_Nuclear__SpriteManager__Layer_bEffect(lua_State* tolua_S)
{
  Nuclear::SpriteManager::Layer* self = (Nuclear::SpriteManager::Layer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bEffect'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bEffect = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Layer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_Layer_new00
static int tolua_engineWin32_Nuclear_SpriteManager_Layer_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager::Layer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::SpriteManager::Layer* tolua_ret = (Nuclear::SpriteManager::Layer*)  Mtolua_new((Nuclear::SpriteManager::Layer)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager::Layer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Layer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_Layer_new00_local
static int tolua_engineWin32_Nuclear_SpriteManager_Layer_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager::Layer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::SpriteManager::Layer* tolua_ret = (Nuclear::SpriteManager::Layer*)  Mtolua_new((Nuclear::SpriteManager::Layer)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager::Layer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Layer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_Layer_new01
static int tolua_engineWin32_Nuclear_SpriteManager_Layer_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager::Layer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const std::wstring n = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring d = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  bool r = ((bool)  tolua_toboolean(tolua_S,4,0));
  bool e = ((bool)  tolua_toboolean(tolua_S,5,0));
  {
   Nuclear::SpriteManager::Layer* tolua_ret = (Nuclear::SpriteManager::Layer*)  Mtolua_new((Nuclear::SpriteManager::Layer)(n,d,r,e));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager::Layer");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)n);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)d);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_SpriteManager_Layer_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Layer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_Layer_new01_local
static int tolua_engineWin32_Nuclear_SpriteManager_Layer_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager::Layer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const std::wstring n = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring d = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  bool r = ((bool)  tolua_toboolean(tolua_S,4,0));
  bool e = ((bool)  tolua_toboolean(tolua_S,5,0));
  {
   Nuclear::SpriteManager::Layer* tolua_ret = (Nuclear::SpriteManager::Layer*)  Mtolua_new((Nuclear::SpriteManager::Layer)(n,d,r,e));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager::Layer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
   tolua_pushcppwstring(tolua_S,(const wchar_t*)n);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)d);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_SpriteManager_Layer_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_new00
static int tolua_engineWin32_Nuclear_SpriteManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::SpriteManager* tolua_ret = (Nuclear::SpriteManager*)  Mtolua_new((Nuclear::SpriteManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_new00_local
static int tolua_engineWin32_Nuclear_SpriteManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* pEB = ((Nuclear::EngineBase*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::SpriteManager* tolua_ret = (Nuclear::SpriteManager*)  Mtolua_new((Nuclear::SpriteManager)(pEB));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_delete00
static int tolua_engineWin32_Nuclear_SpriteManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetModelDes of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetModelDes00
static int tolua_engineWin32_Nuclear_SpriteManager_GetModelDes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetModelDes'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetModelDes(modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetModelDes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpModelNames of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DumpModelNames00
static int tolua_engineWin32_Nuclear_SpriteManager_DumpModelNames00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"std::vector<std::wstring>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  std::vector<std::wstring>* modellist = ((std::vector<std::wstring>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpModelNames'", NULL);
#endif
  {
   self->DumpModelNames(*modellist);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpModelNames'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DelModel of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DelModel00
static int tolua_engineWin32_Nuclear_SpriteManager_DelModel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DelModel'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DelModel(modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DelModel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerCount of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetLayerCount00
static int tolua_engineWin32_Nuclear_SpriteManager_GetLayerCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLayerCount(modelname);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerName of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetLayerName00
static int tolua_engineWin32_Nuclear_SpriteManager_GetLayerName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int i = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerName'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetLayerName(modelname,i);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerDes of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetLayerDes00
static int tolua_engineWin32_Nuclear_SpriteManager_GetLayerDes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int i = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerDes'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetLayerDes(modelname,i);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerDes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerRideEnable of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetLayerRideEnable00
static int tolua_engineWin32_Nuclear_SpriteManager_GetLayerRideEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int i = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerRideEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetLayerRideEnable(modelname,i);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerRideEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerEffectEnable of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetLayerEffectEnable00
static int tolua_engineWin32_Nuclear_SpriteManager_GetLayerEffectEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int i = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerEffectEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetLayerEffectEnable(modelname,i);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerEffectEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitlePos of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetTitlePos00
static int tolua_engineWin32_Nuclear_SpriteManager_GetTitlePos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitlePos'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTitlePos(modelname);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitlePos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetModelScale of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetModelScale00
static int tolua_engineWin32_Nuclear_SpriteManager_GetModelScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetModelScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetModelScale(modelname);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetModelScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectPos of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetEffectPos00
static int tolua_engineWin32_Nuclear_SpriteManager_GetEffectPos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectPos'", NULL);
#endif
  {
   const Nuclear::NuclearPoint& tolua_ret = (const Nuclear::NuclearPoint&)  self->GetEffectPos(modelname);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearPoint");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectPos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetHorseHeight of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetHorseHeight00
static int tolua_engineWin32_Nuclear_SpriteManager_GetHorseHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring horsename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetHorseHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetHorseHeight(modelname,horsename);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)horsename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetHorseHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionSoundType of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetActionSoundType00
static int tolua_engineWin32_Nuclear_SpriteManager_GetActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetActionSoundType(action_name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetActionSoundType of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetActionSoundType00
static int tolua_engineWin32_Nuclear_SpriteManager_SetActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  unsigned char type = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetActionSoundType'", NULL);
#endif
  {
   self->SetActionSoundType(action_name,type);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionRef of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetActionRef00
static int tolua_engineWin32_Nuclear_SpriteManager_GetActionRef00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring actname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionRef'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetActionRef(modelname,actname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actname);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionRef'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveSoundParam of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SaveSoundParam00
static int tolua_engineWin32_Nuclear_SpriteManager_SaveSoundParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveSoundParam'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveSoundParam(modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveSoundParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveBase of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SaveBase00
static int tolua_engineWin32_Nuclear_SpriteManager_SaveBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveBase'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveBase(modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitlePos of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetTitlePos00
static int tolua_engineWin32_Nuclear_SpriteManager_SetTitlePos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int pos = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitlePos'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetTitlePos(modelname,pos);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitlePos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectPos of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetEffectPos00
static int tolua_engineWin32_Nuclear_SpriteManager_SetEffectPos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::NuclearPoint* pos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectPos'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetEffectPos(modelname,*pos);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectPos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetHorseHeight of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetHorseHeight00
static int tolua_engineWin32_Nuclear_SpriteManager_SetHorseHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring horsename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int pos = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetHorseHeight'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetHorseHeight(modelname,horsename,pos);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)horsename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetHorseHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWaterSurfaceType of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetWaterSurfaceType00
static int tolua_engineWin32_Nuclear_SpriteManager_SetWaterSurfaceType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::NuclearWaterSurfaceType type = ((Nuclear::NuclearWaterSurfaceType) (int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWaterSurfaceType'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetWaterSurfaceType(modelname,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWaterSurfaceType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAction2 of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DeleteAction200
static int tolua_engineWin32_Nuclear_SpriteManager_DeleteAction200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAction2'", NULL);
#endif
  {
   self->DeleteAction2(modelname,name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAction2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenameAction2 of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_RenameAction200
static int tolua_engineWin32_Nuclear_SpriteManager_RenameAction200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring oldname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring newname = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  bool renamexap = ((bool)  tolua_toboolean(tolua_S,5,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenameAction2'", NULL);
#endif
  {
   self->RenameAction2(modelname,oldname,newname,renamexap);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)oldname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)newname);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenameAction2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddComponent of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_AddComponent00
static int tolua_engineWin32_Nuclear_SpriteManager_AddComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::Component",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::Component* equip = ((const Nuclear::Component*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddComponent'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AddComponent(modelname,*equip);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteComponent of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DeleteComponent00
static int tolua_engineWin32_Nuclear_SpriteManager_DeleteComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::Component",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::Component* equip = ((const Nuclear::Component*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteComponent'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DeleteComponent(modelname,*equip);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetComponent of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetComponent00
static int tolua_engineWin32_Nuclear_SpriteManager_GetComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int ectype = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetComponent'", NULL);
#endif
  {
   Nuclear::Component* tolua_ret = (Nuclear::Component*)  self->GetComponent(modelname,ectype,name);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Component");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpComponent of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DumpComponent00
static int tolua_engineWin32_Nuclear_SpriteManager_DumpComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"std::vector<std::wstring>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int ectype = ((int)  tolua_tonumber(tolua_S,3,0));
  std::vector<std::wstring>* equiplist = ((std::vector<std::wstring>*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpComponent'", NULL);
#endif
  {
   self->DumpComponent(modelname,ectype,*equiplist);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenameComponent of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_RenameComponent00
static int tolua_engineWin32_Nuclear_SpriteManager_RenameComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring oldname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring newname = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenameComponent'", NULL);
#endif
  {
   self->RenameComponent(modelname,oldname,newname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)oldname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)newname);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenameComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundParam of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam00
static int tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundParam'", NULL);
#endif
  {
   Nuclear::ModelSoundParam& tolua_ret = (Nuclear::ModelSoundParam&)  self->GetSoundParam(modelname);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::ModelSoundParam");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundParam of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam01
static int tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundParam'", NULL);
#endif
  {
   const Nuclear::ModelSoundParam& tolua_ret = (const Nuclear::ModelSoundParam&)  self->GetSoundParam(modelname);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::ModelSoundParam");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetAction00
static int tolua_engineWin32_Nuclear_SpriteManager_GetAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring actName = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAction'", NULL);
#endif
  {
   const Nuclear::Action* tolua_ret = (const Nuclear::Action*)  self->GetAction(modelname,actName);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::Action");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actName);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SetAction00
static int tolua_engineWin32_Nuclear_SpriteManager_SetAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::Action",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring actName = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::Action* act = ((const Nuclear::Action*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAction'", NULL);
#endif
  {
   self->SetAction(modelname,actName,*act);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actName);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveActions of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SaveActions00
static int tolua_engineWin32_Nuclear_SpriteManager_SaveActions00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveActions'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveActions(modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveActions'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_AddAction00
static int tolua_engineWin32_Nuclear_SpriteManager_AddAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::Action",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::Action* act = ((const Nuclear::Action*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddAction'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AddAction(modelname,name,*act);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DeleteAction00
static int tolua_engineWin32_Nuclear_SpriteManager_DeleteAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAction'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DeleteAction(modelname,name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenameAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_RenameAction00
static int tolua_engineWin32_Nuclear_SpriteManager_RenameAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring oldname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring newname = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenameAction'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->RenameAction(modelname,oldname,newname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)oldname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)newname);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenameAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpAction of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_DumpAction00
static int tolua_engineWin32_Nuclear_SpriteManager_DumpAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"std::vector<std::wstring>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SpriteManager* self = (const Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  std::vector<std::wstring>* actlist = ((std::vector<std::wstring>*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpAction'", NULL);
#endif
  {
   self->DumpAction(modelname,*actlist);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PreInit of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_PreInit00
static int tolua_engineWin32_Nuclear_SpriteManager_PreInit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PreInit'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PreInit();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PreInit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PostInit of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_PostInit00
static int tolua_engineWin32_Nuclear_SpriteManager_PostInit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PostInit'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PostInit();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PostInit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveModels of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_SaveModels00
static int tolua_engineWin32_Nuclear_SpriteManager_SaveModels00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveModels'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveModels();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveModels'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetInitCount of class  Nuclear::SpriteManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteManager_GetInitCount00
static int tolua_engineWin32_Nuclear_SpriteManager_GetInitCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteManager* self = (Nuclear::SpriteManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetInitCount'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->GetInitCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetInitCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iPlatformID of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID
static int tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iPlatformID'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iPlatformID);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iPlatformID of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID
static int tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iPlatformID'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iPlatformID = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iMajorVersion of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion
static int tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMajorVersion'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iMajorVersion);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iMajorVersion of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion
static int tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMajorVersion'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iMajorVersion = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iMinorVersion of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion
static int tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMinorVersion'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iMinorVersion);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iMinorVersion of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion
static int tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMinorVersion'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iMinorVersion = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iBuildNumber of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber
static int tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iBuildNumber'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iBuildNumber);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iBuildNumber of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber
static int tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iBuildNumber'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iBuildNumber = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_strInfo of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo
static int tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_strInfo'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->m_strInfo);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_strInfo of class  WindowsVersionInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo
static int tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::WindowsVersionInfo* self = (Nuclear::SystemResourceManager::WindowsVersionInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_strInfo'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_strInfo = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iTotalPhys of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys
static int tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTotalPhys'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iTotalPhys);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iTotalPhys of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys
static int tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTotalPhys'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iTotalPhys = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iAvailPhys of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys
static int tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iAvailPhys'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iAvailPhys);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iAvailPhys of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys
static int tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iAvailPhys'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iAvailPhys = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iMemoryLoad of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad
static int tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMemoryLoad'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iMemoryLoad);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iMemoryLoad of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad
static int tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iMemoryLoad'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iMemoryLoad = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iTotalVirtual of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual
static int tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTotalVirtual'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iTotalVirtual);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iTotalVirtual of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual
static int tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iTotalVirtual'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iTotalVirtual = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_iAvailVirtual of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual
static int tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iAvailVirtual'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_iAvailVirtual);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_iAvailVirtual of class  MemoryStatus */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual
static int tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual(lua_State* tolua_S)
{
  Nuclear::SystemResourceManager::MemoryStatus* self = (Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_iAvailVirtual'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_iAvailVirtual = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_new00
static int tolua_engineWin32_Nuclear_SystemResourceManager_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::SystemResourceManager* tolua_ret = (Nuclear::SystemResourceManager*)  Mtolua_new((Nuclear::SystemResourceManager)(pRenderer));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SystemResourceManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_new00_local
static int tolua_engineWin32_Nuclear_SystemResourceManager_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* pRenderer = ((Nuclear::Renderer*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::SystemResourceManager* tolua_ret = (Nuclear::SystemResourceManager*)  Mtolua_new((Nuclear::SystemResourceManager)(pRenderer));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SystemResourceManager");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_delete00
static int tolua_engineWin32_Nuclear_SystemResourceManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_Init00
static int tolua_engineWin32_Nuclear_SystemResourceManager_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   self->Init();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Update of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_Update00
static int tolua_engineWin32_Nuclear_SystemResourceManager_Update00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Update'", NULL);
#endif
  {
   self->Update();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Update'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_OnTimer00
static int tolua_engineWin32_Nuclear_SystemResourceManager_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
  int iPeriod = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer(iPeriod);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCPUCount of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUCount00
static int tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCPUCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetCPUCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCPUCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSystemTimerPeriod of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_GetSystemTimerPeriod00
static int tolua_engineWin32_Nuclear_SystemResourceManager_GetSystemTimerPeriod00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSystemTimerPeriod'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSystemTimerPeriod();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSystemTimerPeriod'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTextureCapsNoPow2 of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_IsTextureCapsNoPow200
static int tolua_engineWin32_Nuclear_SystemResourceManager_IsTextureCapsNoPow200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTextureCapsNoPow2'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTextureCapsNoPow2();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTextureCapsNoPow2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCPUFrequency of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUFrequency00
static int tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUFrequency00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCPUFrequency'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetCPUFrequency();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCPUFrequency'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsCPUFrequencyValid of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_IsCPUFrequencyValid00
static int tolua_engineWin32_Nuclear_SystemResourceManager_IsCPUFrequencyValid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsCPUFrequencyValid'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsCPUFrequencyValid();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsCPUFrequencyValid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMemoryStatus of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_GetMemoryStatus00
static int tolua_engineWin32_Nuclear_SystemResourceManager_GetMemoryStatus00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::SystemResourceManager::MemoryStatus",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::SystemResourceManager::MemoryStatus* tolua_var_1 = ((Nuclear::SystemResourceManager::MemoryStatus*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMemoryStatus'", NULL);
#endif
  {
   self->GetMemoryStatus(*tolua_var_1);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMemoryStatus'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAvailTextureMemory of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_GetAvailTextureMemory00
static int tolua_engineWin32_Nuclear_SystemResourceManager_GetAvailTextureMemory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::SystemResourceManager* self = (const Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAvailTextureMemory'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAvailTextureMemory();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAvailTextureMemory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundInited of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_SetSoundInited00
static int tolua_engineWin32_Nuclear_SystemResourceManager_SetSoundInited00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
  bool ok = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundInited'", NULL);
#endif
  {
   self->SetSoundInited(ok);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSoundInited'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSoundInited of class  Nuclear::SystemResourceManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SystemResourceManager_IsSoundInited00
static int tolua_engineWin32_Nuclear_SystemResourceManager_IsSoundInited00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SystemResourceManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SystemResourceManager* self = (Nuclear::SystemResourceManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSoundInited'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSoundInited();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSoundInited'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: objLoc of class  Nuclear::XPLoadmapParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__XPLoadmapParam_objLoc
static int tolua_get_Nuclear__XPLoadmapParam_objLoc(lua_State* tolua_S)
{
  Nuclear::XPLoadmapParam* self = (Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'objLoc'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->objLoc,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: objLoc of class  Nuclear::XPLoadmapParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__XPLoadmapParam_objLoc
static int tolua_set_Nuclear__XPLoadmapParam_objLoc(lua_State* tolua_S)
{
  Nuclear::XPLoadmapParam* self = (Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'objLoc'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->objLoc = *((  Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::XPLoadmapParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPLoadmapParam_GetType00
static int tolua_engineWin32_Nuclear_XPLoadmapParam_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::XPLoadmapParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::XPLoadmapParam* self = (Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::XPLOADMAP_EFFECT tolua_ret = (Nuclear::XPLOADMAP_EFFECT)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetShakeScreenAdjust of class  Nuclear::ShakeScreenController */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ShakeScreenController_GetShakeScreenAdjust00
static int tolua_engineWin32_Nuclear_ShakeScreenController_GetShakeScreenAdjust00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ShakeScreenController",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ShakeScreenController* self = (Nuclear::ShakeScreenController*)  tolua_tousertype(tolua_S,1,0);
  int now = ((int)  tolua_tonumber(tolua_S,2,0));
  int delta = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetShakeScreenAdjust'", NULL);
#endif
  {
   Nuclear::NuclearPoint tolua_ret = (Nuclear::NuclearPoint)  self->GetShakeScreenAdjust(now,delta);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetShakeScreenAdjust'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::transformWarLayer2NewLayer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_transformWarLayer2NewLayer00
static int tolua_engineWin32_Nuclear_transformWarLayer2NewLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Nuclear_EffectLayer oldWarLayer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,1,0));
  {
   Nuclear::Nuclear_EffectLayer tolua_ret = (Nuclear::Nuclear_EffectLayer)  Nuclear::transformWarLayer2NewLayer(oldWarLayer);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'transformWarLayer2NewLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_delete00
static int tolua_engineWin32_Nuclear_IWorld_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadMap of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_LoadMap00
static int tolua_engineWin32_Nuclear_IWorld_LoadMap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"const Nuclear::XPLoadmapParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring mapname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring mazename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::XPLoadmapParam* param = ((const Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadMap'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->LoadMap(mapname,mazename,param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mapname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mazename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadMap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadMap of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_LoadMap01
static int tolua_engineWin32_Nuclear_IWorld_LoadMap01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"const Nuclear::XPLoadmapParam",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring mapname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring mazename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::XPLoadmapParam* param = ((const Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,4,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadMap'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->LoadMap(mapname,mazename,param,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mapname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mazename);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_LoadMap00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnloadMap of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_UnloadMap00
static int tolua_engineWin32_Nuclear_IWorld_UnloadMap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnloadMap'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->UnloadMap();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnloadMap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMapSize of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetMapSize00
static int tolua_engineWin32_Nuclear_IWorld_GetMapSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPoint* size = ((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMapSize'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetMapSize(*size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMapSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShakeScreenController of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetShakeScreenController00
static int tolua_engineWin32_Nuclear_IWorld_SetShakeScreenController00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ShakeScreenController",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ShakeScreenController* pController = ((Nuclear::ShakeScreenController*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShakeScreenController'", NULL);
#endif
  {
   self->SetShakeScreenController(pController);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShakeScreenController'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetShakeScreenController of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetShakeScreenController00
static int tolua_engineWin32_Nuclear_IWorld_GetShakeScreenController00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetShakeScreenController'", NULL);
#endif
  {
   Nuclear::ShakeScreenController* tolua_ret = (Nuclear::ShakeScreenController*)  self->GetShakeScreenController();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ShakeScreenController");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetShakeScreenController'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetScale00
static int tolua_engineWin32_Nuclear_IWorld_SetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  float scale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScale of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetScale00
static int tolua_engineWin32_Nuclear_IWorld_GetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMapMaze of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetMapMaze00
static int tolua_engineWin32_Nuclear_IWorld_SetMapMaze00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const void* mazeBuffer = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMapMaze'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetMapMaze(mazeBuffer,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMapMaze'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMazeMask of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetMazeMask00
static int tolua_engineWin32_Nuclear_IWorld_SetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  unsigned const char* pData = ((unsigned const char*)  tolua_tostring(tolua_S,2,0));
  const Nuclear::NuclearRect* rect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMazeMask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetMazeMask(pData,*rect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMazeMask of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetMazeMask00
static int tolua_engineWin32_Nuclear_IWorld_GetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMazeMask'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetMazeMask(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMazeColors of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetMazeColors00
static int tolua_engineWin32_Nuclear_IWorld_SetMazeColors00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::XPMazeColors",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::XPMazeColors* colors = ((const Nuclear::XPMazeColors*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMazeColors'", NULL);
#endif
  {
   self->SetMazeColors(*colors);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMazeColors'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMazeColors of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetMazeColors00
static int tolua_engineWin32_Nuclear_IWorld_GetMazeColors00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMazeColors'", NULL);
#endif
  {
   const Nuclear::XPMazeColors& tolua_ret = (const Nuclear::XPMazeColors&)  self->GetMazeColors();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::XPMazeColors");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMazeColors'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskBoxColor of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor00
static int tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskBoxColor'", NULL);
#endif
  {
   self->SetMaskBoxColor();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaskBoxColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskBoxColor of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor01
static int tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearColor* color = ((const Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskBoxColor'", NULL);
#endif
  {
   self->SetMaskBoxColor(*color);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaskBoxColor of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetMaskBoxColor00
static int tolua_engineWin32_Nuclear_IWorld_GetMaskBoxColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaskBoxColor'", NULL);
#endif
  {
   const Nuclear::NuclearColor& tolua_ret = (const Nuclear::NuclearColor&)  self->GetMaskBoxColor();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearColor");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaskBoxColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWorldMode of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWorldMode00
static int tolua_engineWin32_Nuclear_IWorld_SetWorldMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::eNuclearWorldMode m = ((Nuclear::eNuclearWorldMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWorldMode'", NULL);
#endif
  {
   self->SetWorldMode(m);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWorldMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorldMode of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetWorldMode00
static int tolua_engineWin32_Nuclear_IWorld_GetWorldMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorldMode'", NULL);
#endif
  {
   Nuclear::eNuclearWorldMode tolua_ret = (Nuclear::eNuclearWorldMode)  self->GetWorldMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorldMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadWarBackgound of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_LoadWarBackgound00
static int tolua_engineWin32_Nuclear_IWorld_LoadWarBackgound00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadWarBackgound'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->LoadWarBackgound(name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadWarBackgound'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeWarBackgroundHandle of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_FreeWarBackgroundHandle00
static int tolua_engineWin32_Nuclear_IWorld_FreeWarBackgroundHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeWarBackgroundHandle'", NULL);
#endif
  {
   self->FreeWarBackgroundHandle(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeWarBackgroundHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarBackground of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWarBackground00
static int tolua_engineWin32_Nuclear_IWorld_SetWarBackground00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarBackground'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetWarBackground(handle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarBackground'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarBackground of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWarBackground01
static int tolua_engineWin32_Nuclear_IWorld_SetWarBackground01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearWarBackgroundType type = ((Nuclear::NuclearWarBackgroundType) (int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarBackground'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetWarBackground(handle,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_SetWarBackground00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeAllWarBackground of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_FreeAllWarBackground00
static int tolua_engineWin32_Nuclear_IWorld_FreeAllWarBackground00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeAllWarBackground'", NULL);
#endif
  {
   self->FreeAllWarBackground();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeAllWarBackground'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarBackgroundEdge of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWarBackgroundEdge00
static int tolua_engineWin32_Nuclear_IWorld_SetWarBackgroundEdge00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  float fEdge = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarBackgroundEdge'", NULL);
#endif
  {
   self->SetWarBackgroundEdge(fEdge);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarBackgroundEdge'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWarBackgroundEdge of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetWarBackgroundEdge00
static int tolua_engineWin32_Nuclear_IWorld_GetWarBackgroundEdge00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWarBackgroundEdge'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetWarBackgroundEdge();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWarBackgroundEdge'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSortTick of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetSortTick00
static int tolua_engineWin32_Nuclear_IWorld_GetSortTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSortTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSortTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSortTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_NewSprite00
static int tolua_engineWin32_Nuclear_IWorld_NewSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewSprite'", NULL);
#endif
  {
   Nuclear::ISprite* tolua_ret = (Nuclear::ISprite*)  self->NewSprite(layer,modelname);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISprite");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_AttachSprite00
static int tolua_engineWin32_Nuclear_IWorld_AttachSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"const Nuclear::NuclearVector3",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  const std::wstring hostSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring clientSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  const Nuclear::NuclearVector3* relpos = ((const Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,6,0));
  unsigned int sign = ((unsigned int)  tolua_tonumber(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AttachSprite(pHostSprite,pClientSprite,hostSocket,clientSocket,*relpos,sign);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)hostSocket);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)clientSocket);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AttachSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_AttachSprite01
static int tolua_engineWin32_Nuclear_IWorld_AttachSprite01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  const std::wstring hostSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring clientSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  unsigned int sign = ((unsigned int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AttachSprite(pHostSprite,pClientSprite,hostSocket,clientSocket,sign);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)hostSocket);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)clientSocket);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_AttachSprite00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DetachSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DetachSprite00
static int tolua_engineWin32_Nuclear_IWorld_DetachSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DetachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DetachSprite(layer,pHostSprite,pClientSprite);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DetachSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteSprite00
static int tolua_engineWin32_Nuclear_IWorld_DeleteSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* sprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteSprite'", NULL);
#endif
  {
   self->DeleteSprite(sprite);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite00
static int tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  bool keepAttached = ((bool)  tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllSprite'", NULL);
#endif
  {
   self->DeleteAllSprite(layer,keepAttached);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAllSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: MoveSpriteLayer of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_MoveSpriteLayer00
static int tolua_engineWin32_Nuclear_IWorld_MoveSpriteLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearSpriteLayer fromlayer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearSpriteLayer tolayer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'MoveSpriteLayer'", NULL);
#endif
  {
   self->MoveSpriteLayer(pSprite,fromlayer,tolayer);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MoveSpriteLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_NewSprite01
static int tolua_engineWin32_Nuclear_IWorld_NewSprite01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewSprite'", NULL);
#endif
  {
   Nuclear::ISprite* tolua_ret = (Nuclear::ISprite*)  self->NewSprite(modelname);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISprite");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_NewSprite00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DetachSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DetachSprite01
static int tolua_engineWin32_Nuclear_IWorld_DetachSprite01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DetachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DetachSprite(pHostSprite,pClientSprite);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_DetachSprite00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite01
static int tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  bool keepAttached = ((bool)  tolua_toboolean(tolua_S,2,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllSprite'", NULL);
#endif
  {
   self->DeleteAllSprite(keepAttached);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewWarSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_NewWarSprite00
static int tolua_engineWin32_Nuclear_IWorld_NewWarSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewWarSprite'", NULL);
#endif
  {
   Nuclear::ISprite* tolua_ret = (Nuclear::ISprite*)  self->NewWarSprite(modelname);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISprite");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewWarSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachWarSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_AttachWarSprite00
static int tolua_engineWin32_Nuclear_IWorld_AttachWarSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  const std::wstring hostSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring clientSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  unsigned int sign = ((unsigned int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachWarSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AttachWarSprite(pHostSprite,pClientSprite,hostSocket,clientSocket,sign);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)hostSocket);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)clientSocket);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AttachWarSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DetachWarSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DetachWarSprite00
static int tolua_engineWin32_Nuclear_IWorld_DetachWarSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DetachWarSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DetachWarSprite(pHostSprite,pClientSprite);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DetachWarSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteWarSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteWarSprite00
static int tolua_engineWin32_Nuclear_IWorld_DeleteWarSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* sprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteWarSprite'", NULL);
#endif
  {
   self->DeleteWarSprite(sprite);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteWarSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllWarSprite of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteAllWarSprite00
static int tolua_engineWin32_Nuclear_IWorld_DeleteAllWarSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllWarSprite'", NULL);
#endif
  {
   self->DeleteAllWarSprite();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAllWarSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteShadowParam of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetSpriteShadowParam00
static int tolua_engineWin32_Nuclear_IWorld_GetSpriteShadowParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  float shearX = ((float)  tolua_tonumber(tolua_S,2,0));
  float scalingY = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteShadowParam'", NULL);
#endif
  {
   self->GetSpriteShadowParam(shearX,scalingY);
   tolua_pushnumber(tolua_S,(lua_Number)shearX);
   tolua_pushnumber(tolua_S,(lua_Number)scalingY);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteShadowParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteShadowParam of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetSpriteShadowParam00
static int tolua_engineWin32_Nuclear_IWorld_SetSpriteShadowParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const float shearX = ((const float)  tolua_tonumber(tolua_S,2,0));
  const float scalingY = ((const float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteShadowParam'", NULL);
#endif
  {
   self->SetSpriteShadowParam(shearX,scalingY);
   tolua_pushnumber(tolua_S,(lua_Number)shearX);
   tolua_pushnumber(tolua_S,(lua_Number)scalingY);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteShadowParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewImmovableObj of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_NewImmovableObj00
static int tolua_engineWin32_Nuclear_IWorld_NewImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring objname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  float freq = ((float)  tolua_tonumber(tolua_S,5,1.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewImmovableObj'", NULL);
#endif
  {
   Nuclear::IImmovableObj* tolua_ret = (Nuclear::IImmovableObj*)  self->NewImmovableObj(objname,layer,color,freq);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IImmovableObj");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)objname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteImmovableObj of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteImmovableObj00
static int tolua_engineWin32_Nuclear_IWorld_DeleteImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IImmovableObj* immobj = ((Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteImmovableObj'", NULL);
#endif
  {
   self->DeleteImmovableObj(immobj);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllImmovableObj of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_DeleteAllImmovableObj00
static int tolua_engineWin32_Nuclear_IWorld_DeleteAllImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllImmovableObj'", NULL);
#endif
  {
   self->DeleteAllImmovableObj();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAllImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SelectObjs of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SelectObjs00
static int tolua_engineWin32_Nuclear_IWorld_SelectObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"std::vector<Nuclear::ISelectableObj*>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  std::vector<Nuclear::ISelectableObj*>* ettobjs = ((std::vector<Nuclear::ISelectableObj*>*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SelectObjs'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SelectObjs(*loc,*ettobjs);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SelectObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLinkedEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetLinkedEffect00
static int tolua_engineWin32_Nuclear_IWorld_SetLinkedEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  const Nuclear::NuclearPoint* pt1 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  const Nuclear::NuclearPoint* pt2 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,5,0));
  float time = ((float)  tolua_tonumber(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLinkedEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetLinkedEffect(name,layer,*pt1,*pt2,time,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLinkedEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetEffect00
static int tolua_engineWin32_Nuclear_IWorld_SetEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetEffect(name,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetContinueEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetContinueEffect00
static int tolua_engineWin32_Nuclear_IWorld_SetContinueEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,9,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring headEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring midEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring endEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  int continueTime = ((int)  tolua_tonumber(tolua_S,5,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,6,0));
  int x = ((int)  tolua_tonumber(tolua_S,7,0));
  int y = ((int)  tolua_tonumber(tolua_S,8,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetContinueEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetContinueEffect(headEffect,midEffect,endEffect,continueTime,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)headEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)midEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)endEffect);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetContinueEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_RemoveEffect00
static int tolua_engineWin32_Nuclear_IWorld_RemoveEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEffect'", NULL);
#endif
  {
   self->RemoveEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEffectEx of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_RemoveEffectEx00
static int tolua_engineWin32_Nuclear_IWorld_RemoveEffectEx00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEffectEx'", NULL);
#endif
  {
   self->RemoveEffectEx(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEffectEx'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_PlayEffect00
static int tolua_engineWin32_Nuclear_IWorld_PlayEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  int times = ((int)  tolua_tonumber(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEffect(name,layer,x,y,times,async,soundtype);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWarEffect00
static int tolua_engineWin32_Nuclear_IWorld_SetWarEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetWarEffect(name,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarContinueEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetWarContinueEffect00
static int tolua_engineWin32_Nuclear_IWorld_SetWarContinueEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,9,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring headEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring midEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring endEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  int continueTime = ((int)  tolua_tonumber(tolua_S,5,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,6,0));
  int x = ((int)  tolua_tonumber(tolua_S,7,0));
  int y = ((int)  tolua_tonumber(tolua_S,8,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarContinueEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetWarContinueEffect(headEffect,midEffect,endEffect,continueTime,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)headEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)midEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)endEffect);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarContinueEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveWarEffect of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_RemoveWarEffect00
static int tolua_engineWin32_Nuclear_IWorld_RemoveWarEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveWarEffect'", NULL);
#endif
  {
   self->RemoveWarEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveWarEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachCameraTo of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_AttachCameraTo00
static int tolua_engineWin32_Nuclear_IWorld_AttachCameraTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* sprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachCameraTo'", NULL);
#endif
  {
   self->AttachCameraTo(sprite);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AttachCameraTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetViewport of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetViewport00
static int tolua_engineWin32_Nuclear_IWorld_GetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetViewport'", NULL);
#endif
  {
   const Nuclear::NuclearRect& tolua_ret = (const Nuclear::NuclearRect&)  self->GetViewport();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetViewport of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetViewport00
static int tolua_engineWin32_Nuclear_IWorld_SetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  bool syncRsrc = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetViewport'", NULL);
#endif
  {
   self->SetViewport(*loc,syncRsrc);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetViewportLT of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetViewportLT00
static int tolua_engineWin32_Nuclear_IWorld_SetViewportLT00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  int left = ((int)  tolua_tonumber(tolua_S,2,0));
  int top = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetViewportLT'", NULL);
#endif
  {
   self->SetViewportLT(left,top);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetViewportLT'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTime of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetGameTime00
static int tolua_engineWin32_Nuclear_IWorld_SetGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  float time = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTime'", NULL);
#endif
  {
   self->SetGameTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTempGameTime of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetTempGameTime00
static int tolua_engineWin32_Nuclear_IWorld_GetTempGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTempGameTime'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetTempGameTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTempGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTimeCycle of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetGameTimeCycle00
static int tolua_engineWin32_Nuclear_IWorld_SetGameTimeCycle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTimeCycle'", NULL);
#endif
  {
   self->SetGameTimeCycle(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTimeCycle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCameraUpdateType of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType00
static int tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearCameraUpdateType type = ((Nuclear::NuclearCameraUpdateType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCameraUpdateType'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCameraUpdateType(type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCameraUpdateType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCameraUpdateType of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType01
static int tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearCameraUpdateType type = ((Nuclear::NuclearCameraUpdateType) (int)  tolua_tonumber(tolua_S,2,0));
  void* pParams = ((void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCameraUpdateType'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCameraUpdateType(type,pParams);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCameraUpdateType of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_GetCameraUpdateType00
static int tolua_engineWin32_Nuclear_IWorld_GetCameraUpdateType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IWorld* self = (const Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCameraUpdateType'", NULL);
#endif
  {
   Nuclear::NuclearCameraUpdateType tolua_ret = (Nuclear::NuclearCameraUpdateType)  self->GetCameraUpdateType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCameraUpdateType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PrefetchMapRes of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_PrefetchMapRes00
static int tolua_engineWin32_Nuclear_IWorld_PrefetchMapRes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring mapname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring mazename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::NuclearPoint* center = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  bool autoSwitch = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PrefetchMapRes'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PrefetchMapRes(mapname,mazename,*center,autoSwitch);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mapname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mazename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PrefetchMapRes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CancelPrefetch of class  Nuclear::IWorld */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IWorld_CancelPrefetch00
static int tolua_engineWin32_Nuclear_IWorld_CancelPrefetch00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IWorld",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IWorld* self = (Nuclear::IWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CancelPrefetch'", NULL);
#endif
  {
   self->CancelPrefetch();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CancelPrefetch'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_new00
static int tolua_engineWin32_Nuclear_World_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* pEngine = ((Nuclear::Engine*)  tolua_tousertype(tolua_S,2,0));
  int viewwidth = ((int)  tolua_tonumber(tolua_S,3,0));
  int viewheight = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::World* tolua_ret = (Nuclear::World*)  Mtolua_new((Nuclear::World)(pEngine,viewwidth,viewheight));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::World");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_new00_local
static int tolua_engineWin32_Nuclear_World_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* pEngine = ((Nuclear::Engine*)  tolua_tousertype(tolua_S,2,0));
  int viewwidth = ((int)  tolua_tonumber(tolua_S,3,0));
  int viewheight = ((int)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::World* tolua_ret = (Nuclear::World*)  Mtolua_new((Nuclear::World)(pEngine,viewwidth,viewheight));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::World");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_delete00
static int tolua_engineWin32_Nuclear_World_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnChangeBGSoundMode of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_OnChangeBGSoundMode00
static int tolua_engineWin32_Nuclear_World_OnChangeBGSoundMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBGSoundMode mode = ((Nuclear::NuclearBGSoundMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnChangeBGSoundMode'", NULL);
#endif
  {
   self->OnChangeBGSoundMode(mode);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnChangeBGSoundMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ResetBGSound of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_ResetBGSound00
static int tolua_engineWin32_Nuclear_World_ResetBGSound00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ResetBGSound'", NULL);
#endif
  {
   self->ResetBGSound();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ResetBGSound'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMapName of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetMapName00
static int tolua_engineWin32_Nuclear_World_GetMapName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMapName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetMapName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMapName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWaterDepth of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetWaterDepth00
static int tolua_engineWin32_Nuclear_World_GetWaterDepth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  unsigned int nDepth = ((unsigned int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWaterDepth'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetWaterDepth(*pt,nDepth);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)nDepth);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWaterDepth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadMap of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_LoadMap00
static int tolua_engineWin32_Nuclear_World_LoadMap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"const Nuclear::XPLoadmapParam",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring mapname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring mazename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::XPLoadmapParam* param = ((const Nuclear::XPLoadmapParam*)  tolua_tousertype(tolua_S,4,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadMap'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->LoadMap(mapname,mazename,param,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mapname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mazename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadMap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnloadMap of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_UnloadMap00
static int tolua_engineWin32_Nuclear_World_UnloadMap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnloadMap'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->UnloadMap();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnloadMap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMapLoaded of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_IsMapLoaded00
static int tolua_engineWin32_Nuclear_World_IsMapLoaded00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMapLoaded'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMapLoaded();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMapLoaded'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMapFull of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_IsMapFull00
static int tolua_engineWin32_Nuclear_World_IsMapFull00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMapFull'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMapFull();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMapFull'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMapSize of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetMapSize00
static int tolua_engineWin32_Nuclear_World_GetMapSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPoint* size = ((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMapSize'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetMapSize(*size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMapSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMapMaze of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetMapMaze00
static int tolua_engineWin32_Nuclear_World_SetMapMaze00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const void* mazeBuffer = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMapMaze'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetMapMaze(mazeBuffer,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMapMaze'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMazeMask of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetMazeMask00
static int tolua_engineWin32_Nuclear_World_SetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned const char* pData = ((unsigned const char*)  tolua_tostring(tolua_S,2,0));
  const Nuclear::NuclearRect* rect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMazeMask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetMazeMask(pData,*rect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMazeMask of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetMazeMask00
static int tolua_engineWin32_Nuclear_World_GetMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMazeMask'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetMazeMask(x,y);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskBoxColor of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetMaskBoxColor00
static int tolua_engineWin32_Nuclear_World_SetMaskBoxColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskBoxColor'", NULL);
#endif
  {
   self->SetMaskBoxColor();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaskBoxColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskBoxColor of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetMaskBoxColor01
static int tolua_engineWin32_Nuclear_World_SetMaskBoxColor01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearColor* color = ((const Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskBoxColor'", NULL);
#endif
  {
   self->SetMaskBoxColor(*color);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_World_SetMaskBoxColor00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaskBoxColor of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetMaskBoxColor00
static int tolua_engineWin32_Nuclear_World_GetMaskBoxColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaskBoxColor'", NULL);
#endif
  {
   const Nuclear::NuclearColor& tolua_ret = (const Nuclear::NuclearColor&)  self->GetMaskBoxColor();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearColor");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaskBoxColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteShadowParam of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetSpriteShadowParam00
static int tolua_engineWin32_Nuclear_World_GetSpriteShadowParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  float shearX = ((float)  tolua_tonumber(tolua_S,2,0));
  float scalingY = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteShadowParam'", NULL);
#endif
  {
   self->GetSpriteShadowParam(shearX,scalingY);
   tolua_pushnumber(tolua_S,(lua_Number)shearX);
   tolua_pushnumber(tolua_S,(lua_Number)scalingY);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteShadowParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSortTick of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetSortTick00
static int tolua_engineWin32_Nuclear_World_GetSortTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSortTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSortTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSortTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAllSpriteCount of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetAllSpriteCount00
static int tolua_engineWin32_Nuclear_World_GetAllSpriteCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAllSpriteCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAllSpriteCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAllSpriteCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAllSpriteDetail of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetAllSpriteDetail00
static int tolua_engineWin32_Nuclear_World_GetAllSpriteDetail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"std::map<std::wstring,int>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  std::map<std::wstring,int>* detail = ((std::map<std::wstring,int>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAllSpriteDetail'", NULL);
#endif
  {
   self->GetAllSpriteDetail(*detail);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAllSpriteDetail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAllEffectCount of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetAllEffectCount00
static int tolua_engineWin32_Nuclear_World_GetAllEffectCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAllEffectCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAllEffectCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAllEffectCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAllEffectDetail of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetAllEffectDetail00
static int tolua_engineWin32_Nuclear_World_GetAllEffectDetail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"std::map<std::wstring,int>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  std::map<std::wstring,int>* detail = ((std::map<std::wstring,int>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAllEffectDetail'", NULL);
#endif
  {
   self->GetAllEffectDetail(*detail);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAllEffectDetail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableRenderDuringLoading of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_EnableRenderDuringLoading00
static int tolua_engineWin32_Nuclear_World_EnableRenderDuringLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableRenderDuringLoading'", NULL);
#endif
  {
   self->EnableRenderDuringLoading(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableRenderDuringLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderDuringLoading of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_IsRenderDuringLoading00
static int tolua_engineWin32_Nuclear_World_IsRenderDuringLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderDuringLoading'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderDuringLoading();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderDuringLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteShadowParam of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetSpriteShadowParam00
static int tolua_engineWin32_Nuclear_World_SetSpriteShadowParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const float shearX = ((const float)  tolua_tonumber(tolua_S,2,0));
  const float scalingY = ((const float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteShadowParam'", NULL);
#endif
  {
   self->SetSpriteShadowParam(shearX,scalingY);
   tolua_pushnumber(tolua_S,(lua_Number)shearX);
   tolua_pushnumber(tolua_S,(lua_Number)scalingY);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteShadowParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetScale00
static int tolua_engineWin32_Nuclear_World_SetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  float scale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScale of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetScale00
static int tolua_engineWin32_Nuclear_World_GetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PushSpriteTopEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_PushSpriteTopEffect00
static int tolua_engineWin32_Nuclear_World_PushSpriteTopEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Effect* pEffect = ((Nuclear::Effect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PushSpriteTopEffect'", NULL);
#endif
  {
   self->PushSpriteTopEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushSpriteTopEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PushSpriteBottomEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_PushSpriteBottomEffect00
static int tolua_engineWin32_Nuclear_World_PushSpriteBottomEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Effect* pEffect = ((Nuclear::Effect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PushSpriteBottomEffect'", NULL);
#endif
  {
   self->PushSpriteBottomEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushSpriteBottomEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWorldMode of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetWorldMode00
static int tolua_engineWin32_Nuclear_World_SetWorldMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::eNuclearWorldMode m = ((Nuclear::eNuclearWorldMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWorldMode'", NULL);
#endif
  {
   self->SetWorldMode(m);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWorldMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorldMode of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetWorldMode00
static int tolua_engineWin32_Nuclear_World_GetWorldMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorldMode'", NULL);
#endif
  {
   Nuclear::eNuclearWorldMode tolua_ret = (Nuclear::eNuclearWorldMode)  self->GetWorldMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorldMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadWarBackgound of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_LoadWarBackgound00
static int tolua_engineWin32_Nuclear_World_LoadWarBackgound00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadWarBackgound'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->LoadWarBackgound(name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadWarBackgound'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeWarBackgroundHandle of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_FreeWarBackgroundHandle00
static int tolua_engineWin32_Nuclear_World_FreeWarBackgroundHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeWarBackgroundHandle'", NULL);
#endif
  {
   self->FreeWarBackgroundHandle(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeWarBackgroundHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarBackground of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetWarBackground00
static int tolua_engineWin32_Nuclear_World_SetWarBackground00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearWarBackgroundType type = ((Nuclear::NuclearWarBackgroundType) (int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarBackground'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetWarBackground(handle,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarBackground'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeAllWarBackground of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_FreeAllWarBackground00
static int tolua_engineWin32_Nuclear_World_FreeAllWarBackground00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeAllWarBackground'", NULL);
#endif
  {
   self->FreeAllWarBackground();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeAllWarBackground'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetWarBackgroundEdge of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetWarBackgroundEdge00
static int tolua_engineWin32_Nuclear_World_SetWarBackgroundEdge00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  float fEdge = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetWarBackgroundEdge'", NULL);
#endif
  {
   self->SetWarBackgroundEdge(fEdge);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWarBackgroundEdge'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWarBackgroundEdge of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetWarBackgroundEdge00
static int tolua_engineWin32_Nuclear_World_GetWarBackgroundEdge00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWarBackgroundEdge'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetWarBackgroundEdge();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWarBackgroundEdge'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_NewSprite00
static int tolua_engineWin32_Nuclear_World_NewSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewSprite'", NULL);
#endif
  {
   Nuclear::ISprite* tolua_ret = (Nuclear::ISprite*)  self->NewSprite(layer,modelname);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ISprite");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_AttachSprite00
static int tolua_engineWin32_Nuclear_World_AttachSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"const Nuclear::NuclearVector3",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  const std::wstring hostSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  const std::wstring clientSocket = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  const Nuclear::NuclearVector3* relpos = ((const Nuclear::NuclearVector3*)  tolua_tousertype(tolua_S,6,0));
  unsigned int sign = ((unsigned int)  tolua_tonumber(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->AttachSprite(pHostSprite,pClientSprite,hostSocket,clientSocket,*relpos,sign);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)hostSocket);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)clientSocket);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AttachSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DetachSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_DetachSprite00
static int tolua_engineWin32_Nuclear_World_DetachSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::ISprite* pHostSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::ISprite* pClientSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DetachSprite'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DetachSprite(layer,pHostSprite,pClientSprite);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DetachSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_DeleteSprite00
static int tolua_engineWin32_Nuclear_World_DeleteSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* sprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteSprite'", NULL);
#endif
  {
   self->DeleteSprite(sprite);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_DeleteAllSprite00
static int tolua_engineWin32_Nuclear_World_DeleteAllSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteLayer layer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,2,0));
  bool keepAttached = ((bool)  tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllSprite'", NULL);
#endif
  {
   self->DeleteAllSprite(layer,keepAttached);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAllSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: MoveSpriteLayer of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_MoveSpriteLayer00
static int tolua_engineWin32_Nuclear_World_MoveSpriteLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearSpriteLayer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearSpriteLayer fromlayer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearSpriteLayer tolayer = *((Nuclear::NuclearSpriteLayer*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'MoveSpriteLayer'", NULL);
#endif
  {
   self->MoveSpriteLayer(pSprite,fromlayer,tolayer);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MoveSpriteLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewImmovableObj of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_NewImmovableObj00
static int tolua_engineWin32_Nuclear_World_NewImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring objname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int layer = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  float freq = ((float)  tolua_tonumber(tolua_S,5,1));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewImmovableObj'", NULL);
#endif
  {
   Nuclear::IImmovableObj* tolua_ret = (Nuclear::IImmovableObj*)  self->NewImmovableObj(objname,layer,color,freq);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IImmovableObj");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)objname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteImmovableObj of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_DeleteImmovableObj00
static int tolua_engineWin32_Nuclear_World_DeleteImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IImmovableObj",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IImmovableObj* immobj = ((Nuclear::IImmovableObj*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteImmovableObj'", NULL);
#endif
  {
   self->DeleteImmovableObj(immobj);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeleteAllImmovableObj of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_DeleteAllImmovableObj00
static int tolua_engineWin32_Nuclear_World_DeleteAllImmovableObj00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeleteAllImmovableObj'", NULL);
#endif
  {
   self->DeleteAllImmovableObj();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteAllImmovableObj'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SelectObjs of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SelectObjs00
static int tolua_engineWin32_Nuclear_World_SelectObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"std::vector<Nuclear::ISelectableObj*>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  std::vector<Nuclear::ISelectableObj*>* ettobjs = ((std::vector<Nuclear::ISelectableObj*>*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SelectObjs'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SelectObjs(*loc,*ettobjs);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SelectObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLinkedEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetLinkedEffect00
static int tolua_engineWin32_Nuclear_World_SetLinkedEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  const Nuclear::NuclearPoint* pt1 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  const Nuclear::NuclearPoint* pt2 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,5,0));
  float time = ((float)  tolua_tonumber(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLinkedEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetLinkedEffect(name,layer,*pt1,*pt2,time,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLinkedEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetEffect00
static int tolua_engineWin32_Nuclear_World_SetEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetEffect(name,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetContinueEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetContinueEffect00
static int tolua_engineWin32_Nuclear_World_SetContinueEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,9,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring headEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring midEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring endEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  int continueTime = ((int)  tolua_tonumber(tolua_S,5,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,6,0));
  int x = ((int)  tolua_tonumber(tolua_S,7,0));
  int y = ((int)  tolua_tonumber(tolua_S,8,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetContinueEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetContinueEffect(headEffect,midEffect,endEffect,continueTime,layer,x,y,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)headEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)midEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)endEffect);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetContinueEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RemoveEffect00
static int tolua_engineWin32_Nuclear_World_RemoveEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEffect'", NULL);
#endif
  {
   self->RemoveEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEffectEx of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RemoveEffectEx00
static int tolua_engineWin32_Nuclear_World_RemoveEffectEx00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEffectEx'", NULL);
#endif
  {
   self->RemoveEffectEx(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEffectEx'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_PlayEffect00
static int tolua_engineWin32_Nuclear_World_PlayEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  int times = ((int)  tolua_tonumber(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEffect(name,layer,x,y,times,async,soundtype);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayOnceEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_PlayOnceEffect00
static int tolua_engineWin32_Nuclear_World_PlayOnceEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::Nuclear_EffectLayer layer = ((Nuclear::Nuclear_EffectLayer) (int)  tolua_tonumber(tolua_S,3,0));
  int x = ((int)  tolua_tonumber(tolua_S,4,0));
  int y = ((int)  tolua_tonumber(tolua_S,5,0));
  int times = ((int)  tolua_tonumber(tolua_S,6,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,7,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayOnceEffect'", NULL);
#endif
  {
   Nuclear::Effect* tolua_ret = (Nuclear::Effect*)  self->PlayOnceEffect(name,layer,x,y,times,async,soundtype);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Effect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayOnceEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CheckMapGUID of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_CheckMapGUID00
static int tolua_engineWin32_Nuclear_World_CheckMapGUID00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned int mapguid = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CheckMapGUID'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CheckMapGUID(mapguid);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CheckMapGUID'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: pauseSceneEffects of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_pauseSceneEffects00
static int tolua_engineWin32_Nuclear_World_pauseSceneEffects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'pauseSceneEffects'", NULL);
#endif
  {
   self->pauseSceneEffects();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'pauseSceneEffects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: resumeSceneEffects of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_resumeSceneEffects00
static int tolua_engineWin32_Nuclear_World_resumeSceneEffects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'resumeSceneEffects'", NULL);
#endif
  {
   self->resumeSceneEffects();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'resumeSceneEffects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: showSceneEffects of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_showSceneEffects00
static int tolua_engineWin32_Nuclear_World_showSceneEffects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  bool bshow = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'showSceneEffects'", NULL);
#endif
  {
   self->showSceneEffects(bshow);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'showSceneEffects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: isShowSceneEffects of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_isShowSceneEffects00
static int tolua_engineWin32_Nuclear_World_isShowSceneEffects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isShowSceneEffects'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->isShowSceneEffects();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'isShowSceneEffects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AttachCameraTo of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_AttachCameraTo00
static int tolua_engineWin32_Nuclear_World_AttachCameraTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* sprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AttachCameraTo'", NULL);
#endif
  {
   self->AttachCameraTo(sprite);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AttachCameraTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetViewport of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetViewport00
static int tolua_engineWin32_Nuclear_World_SetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  bool syncRsrc = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetViewport'", NULL);
#endif
  {
   self->SetViewport(*loc,syncRsrc);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetViewportLT of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetViewportLT00
static int tolua_engineWin32_Nuclear_World_SetViewportLT00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int left = ((int)  tolua_tonumber(tolua_S,2,0));
  int top = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetViewportLT'", NULL);
#endif
  {
   self->SetViewportLT(left,top);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetViewportLT'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PrefetchMapRes of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_PrefetchMapRes00
static int tolua_engineWin32_Nuclear_World_PrefetchMapRes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring mapname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring mazename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::NuclearPoint* center = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  bool autoSwitch = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PrefetchMapRes'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PrefetchMapRes(mapname,mazename,*center,autoSwitch);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mapname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)mazename);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PrefetchMapRes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CancelPrefetch of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_CancelPrefetch00
static int tolua_engineWin32_Nuclear_World_CancelPrefetch00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CancelPrefetch'", NULL);
#endif
  {
   self->CancelPrefetch();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CancelPrefetch'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnRendererRestore of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_OnRendererRestore00
static int tolua_engineWin32_Nuclear_World_OnRendererRestore00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnRendererRestore'", NULL);
#endif
  {
   self->OnRendererRestore();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnRendererRestore'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeAllPicReses of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_FreeAllPicReses00
static int tolua_engineWin32_Nuclear_World_FreeAllPicReses00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeAllPicReses'", NULL);
#endif
  {
   self->FreeAllPicReses();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeAllPicReses'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NotifyLoadmapProgress of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_NotifyLoadmapProgress00
static int tolua_engineWin32_Nuclear_World_NotifyLoadmapProgress00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int pro = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NotifyLoadmapProgress'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->NotifyLoadmapProgress(pro);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NotifyLoadmapProgress'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NotifyALoadItemFin of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_NotifyALoadItemFin00
static int tolua_engineWin32_Nuclear_World_NotifyALoadItemFin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned char beginPro = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
  unsigned char endPro = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NotifyALoadItemFin'", NULL);
#endif
  {
   self->NotifyALoadItemFin(beginPro,endPro);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NotifyALoadItemFin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddTotalLoadingCount of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_AddTotalLoadingCount00
static int tolua_engineWin32_Nuclear_World_AddTotalLoadingCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddTotalLoadingCount'", NULL);
#endif
  {
   self->AddTotalLoadingCount();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddTotalLoadingCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Init of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_Init00
static int tolua_engineWin32_Nuclear_World_Init00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Init'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Init();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Init'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetViewSize of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetViewSize00
static int tolua_engineWin32_Nuclear_World_SetViewSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int width = ((int)  tolua_tonumber(tolua_S,2,0));
  int height = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetViewSize'", NULL);
#endif
  {
   self->SetViewSize(width,height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetViewSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetViewport of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetViewport00
static int tolua_engineWin32_Nuclear_World_GetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetViewport'", NULL);
#endif
  {
   const Nuclear::NuclearRect& tolua_ret = (const Nuclear::NuclearRect&)  self->GetViewport();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_OnTimer00
static int tolua_engineWin32_Nuclear_World_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int iPeriod = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer(iPeriod);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UpdateBeforeRender of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_UpdateBeforeRender00
static int tolua_engineWin32_Nuclear_World_UpdateBeforeRender00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int delta = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UpdateBeforeRender'", NULL);
#endif
  {
   self->UpdateBeforeRender(delta);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UpdateBeforeRender'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SortMid of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SortMid00
static int tolua_engineWin32_Nuclear_World_SortMid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SortMid'", NULL);
#endif
  {
   self->SortMid();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SortMid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_Render00
static int tolua_engineWin32_Nuclear_World_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int now = ((int)  tolua_tonumber(tolua_S,2,0));
  bool UseCavas = ((bool)  tolua_toboolean(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(now,UseCavas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderCaptureWorld of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderCaptureWorld00
static int tolua_engineWin32_Nuclear_World_RenderCaptureWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderCaptureWorld'", NULL);
#endif
  {
   self->RenderCaptureWorld();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderCaptureWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderStaticLayer of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderStaticLayer00
static int tolua_engineWin32_Nuclear_World_RenderStaticLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  int drawTick = ((int)  tolua_tonumber(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderStaticLayer'", NULL);
#endif
  {
   self->RenderStaticLayer(layer,drawTick,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderStaticLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSortedLayer of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderSortedLayer00
static int tolua_engineWin32_Nuclear_World_RenderSortedLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::Canvas* pCanvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSortedLayer'", NULL);
#endif
  {
   self->RenderSortedLayer(layer,pCanvas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSortedLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSortedLayerWithoutAlpha of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderSortedLayerWithoutAlpha00
static int tolua_engineWin32_Nuclear_World_RenderSortedLayerWithoutAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::Canvas* pCanvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSortedLayerWithoutAlpha'", NULL);
#endif
  {
   self->RenderSortedLayerWithoutAlpha(layer,pCanvas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSortedLayerWithoutAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSortedLayerElementWithoutSprite of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderSortedLayerElementWithoutSprite00
static int tolua_engineWin32_Nuclear_World_RenderSortedLayerElementWithoutSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::Canvas* pCanvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSortedLayerElementWithoutSprite'", NULL);
#endif
  {
   self->RenderSortedLayerElementWithoutSprite(layer,pCanvas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSortedLayerElementWithoutSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSortedLayerAlphaSpriteWithoutElement of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderSortedLayerAlphaSpriteWithoutElement00
static int tolua_engineWin32_Nuclear_World_RenderSortedLayerAlphaSpriteWithoutElement00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::Canvas* pCanvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSortedLayerAlphaSpriteWithoutElement'", NULL);
#endif
  {
   self->RenderSortedLayerAlphaSpriteWithoutElement(layer,pCanvas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSortedLayerAlphaSpriteWithoutElement'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSortedLayerNonAlphaSpriteWithAlphaElement of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderSortedLayerNonAlphaSpriteWithAlphaElement00
static int tolua_engineWin32_Nuclear_World_RenderSortedLayerNonAlphaSpriteWithAlphaElement00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int layer = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::Canvas* pCanvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,3,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSortedLayerNonAlphaSpriteWithAlphaElement'", NULL);
#endif
  {
   self->RenderSortedLayerNonAlphaSpriteWithAlphaElement(layer,pCanvas,realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSortedLayerNonAlphaSpriteWithAlphaElement'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderMovingBackground of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderMovingBackground00
static int tolua_engineWin32_Nuclear_World_RenderMovingBackground00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderMovingBackground'", NULL);
#endif
  {
   self->RenderMovingBackground();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderMovingBackground'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderRenderTargetCache of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderRenderTargetCache00
static int tolua_engineWin32_Nuclear_World_RenderRenderTargetCache00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderRenderTargetCache'", NULL);
#endif
  {
   self->RenderRenderTargetCache();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderRenderTargetCache'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetNightEffect of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetNightEffect00
static int tolua_engineWin32_Nuclear_World_SetNightEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  bool bIsInBattle = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetNightEffect'", NULL);
#endif
  {
   self->SetNightEffect(bIsInBattle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNightEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTick of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_OnTick00
static int tolua_engineWin32_Nuclear_World_OnTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  unsigned int now = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
  unsigned int delta = ((unsigned int)  tolua_tonumber(tolua_S,3,0));
  unsigned int realDelta = ((unsigned int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTick'", NULL);
#endif
  {
   self->OnTick(now,delta,realDelta);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UpdateSpriteAction of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_UpdateSpriteAction00
static int tolua_engineWin32_Nuclear_World_UpdateSpriteAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  DWORD delta = ((DWORD)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UpdateSpriteAction'", NULL);
#endif
  {
   self->UpdateSpriteAction(delta);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UpdateSpriteAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderMaze of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderMaze00
static int tolua_engineWin32_Nuclear_World_RenderMaze00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderMaze'", NULL);
#endif
  {
   self->RenderMaze();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderMaze'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderMaskBox of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_RenderMaskBox00
static int tolua_engineWin32_Nuclear_World_RenderMaskBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderMaskBox'", NULL);
#endif
  {
   self->RenderMaskBox();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderMaskBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTime of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetGameTime00
static int tolua_engineWin32_Nuclear_World_SetGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  float time = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTime'", NULL);
#endif
  {
   self->SetGameTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTimeCycle of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetGameTimeCycle00
static int tolua_engineWin32_Nuclear_World_SetGameTimeCycle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTimeCycle'", NULL);
#endif
  {
   self->SetGameTimeCycle(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTimeCycle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGameTime of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetGameTime00
static int tolua_engineWin32_Nuclear_World_GetGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGameTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetGameTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTempGameTime of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetTempGameTime00
static int tolua_engineWin32_Nuclear_World_GetTempGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTempGameTime'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetTempGameTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTempGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCameraUpdateType of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetCameraUpdateType00
static int tolua_engineWin32_Nuclear_World_SetCameraUpdateType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearCameraUpdateType type = ((Nuclear::NuclearCameraUpdateType) (int)  tolua_tonumber(tolua_S,2,0));
  void* pParams = ((void*)  tolua_touserdata(tolua_S,3,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCameraUpdateType'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCameraUpdateType(type,pParams);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCameraUpdateType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCameraUpdateType of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetCameraUpdateType00
static int tolua_engineWin32_Nuclear_World_GetCameraUpdateType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCameraUpdateType'", NULL);
#endif
  {
   Nuclear::NuclearCameraUpdateType tolua_ret = (Nuclear::NuclearCameraUpdateType)  self->GetCameraUpdateType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCameraUpdateType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShakeScreenController of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetShakeScreenController00
static int tolua_engineWin32_Nuclear_World_SetShakeScreenController00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ShakeScreenController",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ShakeScreenController* pController = ((Nuclear::ShakeScreenController*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShakeScreenController'", NULL);
#endif
  {
   self->SetShakeScreenController(pController);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShakeScreenController'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetShakeScreenController of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetShakeScreenController00
static int tolua_engineWin32_Nuclear_World_GetShakeScreenController00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetShakeScreenController'", NULL);
#endif
  {
   Nuclear::ShakeScreenController* tolua_ret = (Nuclear::ShakeScreenController*)  self->GetShakeScreenController();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ShakeScreenController");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetShakeScreenController'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCurveMoveHeight of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_SetCurveMoveHeight00
static int tolua_engineWin32_Nuclear_World_SetCurveMoveHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::World",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::World* self = (Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
  float height = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCurveMoveHeight'", NULL);
#endif
  {
   self->SetCurveMoveHeight(height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCurveMoveHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurveMoveHeight of class  Nuclear::World */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_World_GetCurveMoveHeight00
static int tolua_engineWin32_Nuclear_World_GetCurveMoveHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::World",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::World* self = (const Nuclear::World*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurveMoveHeight'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetCurveMoveHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurveMoveHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddNotify of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_AddNotify00
static int tolua_engineWin32_Nuclear_IEffect_AddNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffectNotify* pNotify = ((Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddNotify'", NULL);
#endif
  {
   self->AddNotify(pNotify);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveNotify of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_RemoveNotify00
static int tolua_engineWin32_Nuclear_IEffect_RemoveNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffectNotify* pNotify = ((Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveNotify'", NULL);
#endif
  {
   self->RemoveNotify(pNotify);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Play of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_Play00
static int tolua_engineWin32_Nuclear_IEffect_Play00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Play'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Play();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Play'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Stop of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_Stop00
static int tolua_engineWin32_Nuclear_IEffect_Stop00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Stop'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Stop();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Stop'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Pause of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_Pause00
static int tolua_engineWin32_Nuclear_IEffect_Pause00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Pause'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Pause();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Pause'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Resume of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_Resume00
static int tolua_engineWin32_Nuclear_IEffect_Resume00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Resume'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Resume();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Resume'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetLocation00
static int tolua_engineWin32_Nuclear_IEffect_SetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* location = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(*location);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLocation of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetLocation00
static int tolua_engineWin32_Nuclear_IEffect_GetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLocation'", NULL);
#endif
  {
    Nuclear::NuclearPoint tolua_ret = (  Nuclear::NuclearPoint)  self->GetLocation();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetDirection00
static int tolua_engineWin32_Nuclear_IEffect_SetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearDirection direction = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(direction);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirection of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetDirection00
static int tolua_engineWin32_Nuclear_IEffect_GetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirection'", NULL);
#endif
  {
   Nuclear::NuclearDirection tolua_ret = (Nuclear::NuclearDirection)  self->GetDirection();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetDirection01
static int tolua_engineWin32_Nuclear_IEffect_SetDirection01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* target = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_SetDirection00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetDirection02
static int tolua_engineWin32_Nuclear_IEffect_SetDirection02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  float targetx = ((float)  tolua_tonumber(tolua_S,2,0));
  float targety = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(targetx,targety);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_SetDirection01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRotationRadian of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetRotationRadian00
static int tolua_engineWin32_Nuclear_IEffect_SetRotationRadian00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  float radian = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRotationRadian'", NULL);
#endif
  {
   self->SetRotationRadian(radian);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRotationRadian'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRotationRadian of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetRotationRadian00
static int tolua_engineWin32_Nuclear_IEffect_GetRotationRadian00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRotationRadian'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetRotationRadian();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRotationRadian'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetScale00
static int tolua_engineWin32_Nuclear_IEffect_SetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  float scaleX = ((float)  tolua_tonumber(tolua_S,2,0));
  float scaleY = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scaleX,scaleY);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetScale01
static int tolua_engineWin32_Nuclear_IEffect_SetScale01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  float scale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scale);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_SetScale00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetScale02
static int tolua_engineWin32_Nuclear_IEffect_SetScale02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* scale = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(*scale);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_SetScale01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScale of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetScale00
static int tolua_engineWin32_Nuclear_IEffect_GetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScale'", NULL);
#endif
  {
   const Nuclear::NuclearFPoint& tolua_ret = (const Nuclear::NuclearFPoint&)  self->GetScale();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetVertexColor of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetVertexColor00
static int tolua_engineWin32_Nuclear_IEffect_SetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetVertexColor'", NULL);
#endif
  {
   self->SetVertexColor(color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetVertexColor of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetVertexColor00
static int tolua_engineWin32_Nuclear_IEffect_GetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetVertexColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetVertexColor();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRelBouningBox of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetRelBouningBox00
static int tolua_engineWin32_Nuclear_IEffect_GetRelBouningBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRelBouningBox'", NULL);
#endif
  {
   const Nuclear::NuclearRect& tolua_ret = (const Nuclear::NuclearRect&)  self->GetRelBouningBox();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRelBouningBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectBindType of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetEffectBindType00
static int tolua_engineWin32_Nuclear_IEffect_SetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectBindType t = ((Nuclear::Nuclear_EffectBindType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectBindType'", NULL);
#endif
  {
   self->SetEffectBindType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectBindType of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetEffectBindType00
static int tolua_engineWin32_Nuclear_IEffect_GetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectBindType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectBindType tolua_ret = (Nuclear::Nuclear_EffectBindType)  self->GetEffectBindType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundType of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetSoundType00
static int tolua_engineWin32_Nuclear_IEffect_SetSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  unsigned char type = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundType'", NULL);
#endif
  {
   self->SetSoundType(type);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundType of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetSoundType01
static int tolua_engineWin32_Nuclear_IEffect_SetSoundType01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  unsigned char type = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundType'", NULL);
#endif
  {
   self->SetSoundType(type);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_SetSoundType00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundType of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetSoundType00
static int tolua_engineWin32_Nuclear_IEffect_GetSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundPriority of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetSoundPriority00
static int tolua_engineWin32_Nuclear_IEffect_SetSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  short priority = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundPriority'", NULL);
#endif
  {
   self->SetSoundPriority(priority);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundPriority of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetSoundPriority00
static int tolua_engineWin32_Nuclear_IEffect_GetSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundPriority'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetSoundPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayState of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_GetPlayState00
static int tolua_engineWin32_Nuclear_IEffect_GetPlayState00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayState'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectState tolua_ret = (Nuclear::Nuclear_EffectState)  self->GetPlayState();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayState'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TryConvertToParticle of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle00
static int tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEffect* self = (const Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TryConvertToParticle'", NULL);
#endif
  {
   const Nuclear::IParticleEffect* tolua_ret = (const Nuclear::IParticleEffect*)  self->TryConvertToParticle();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::IParticleEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TryConvertToParticle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TryConvertToParticle of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle01
static int tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TryConvertToParticle'", NULL);
#endif
  {
   Nuclear::IParticleEffect* tolua_ret = (Nuclear::IParticleEffect*)  self->TryConvertToParticle();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IParticleEffect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearNotify of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_ClearNotify00
static int tolua_engineWin32_Nuclear_IEffect_ClearNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearNotify'", NULL);
#endif
  {
   self->ClearNotify();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Update of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_Update00
static int tolua_engineWin32_Nuclear_IEffect_Update00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  DWORD tickTime = ((DWORD)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Update'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Update(tickTime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Update'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDefaultActName of class  Nuclear::IEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffect_SetDefaultActName00
static int tolua_engineWin32_Nuclear_IEffect_SetDefaultActName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffect* self = (Nuclear::IEffect*)  tolua_tousertype(tolua_S,1,0);
  const char* szActName = ((const char*)  tolua_tostring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDefaultActName'", NULL);
#endif
  {
   self->SetDefaultActName(szActName);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDefaultActName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_new00
static int tolua_engineWin32_Nuclear_IEffectNotify_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::IEffectNotify* tolua_ret = (Nuclear::IEffectNotify*)  Mtolua_new((Nuclear::IEffectNotify)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffectNotify");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_new00_local
static int tolua_engineWin32_Nuclear_IEffectNotify_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::IEffectNotify* tolua_ret = (Nuclear::IEffectNotify*)  Mtolua_new((Nuclear::IEffectNotify)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffectNotify");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnStop of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_OnStop00
static int tolua_engineWin32_Nuclear_IEffectNotify_OnStop00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnStop'", NULL);
#endif
  {
   self->OnStop(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnStop'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnEnd of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_OnEnd00
static int tolua_engineWin32_Nuclear_IEffectNotify_OnEnd00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnEnd'", NULL);
#endif
  {
   self->OnEnd(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnEnd'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnDelete of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_OnDelete00
static int tolua_engineWin32_Nuclear_IEffectNotify_OnDelete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnDelete'", NULL);
#endif
  {
   self->OnDelete(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnDelete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnAsyncLoaded of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_OnAsyncLoaded00
static int tolua_engineWin32_Nuclear_IEffectNotify_OnAsyncLoaded00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
  bool succeeded = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnAsyncLoaded'", NULL);
#endif
  {
   self->OnAsyncLoaded(pEffect,succeeded);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnAsyncLoaded'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IEffectNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEffectNotify_delete00
static int tolua_engineWin32_Nuclear_IEffectNotify_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEffectNotify* self = (Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_delete00
static int tolua_engineWin32_Nuclear_Effect_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsInSegmPak of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_IsInSegmPak00
static int tolua_engineWin32_Nuclear_Effect_IsInSegmPak00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsInSegmPak'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsInSegmPak();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsInSegmPak'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSegmPak of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetSegmPak00
static int tolua_engineWin32_Nuclear_Effect_SetSegmPak00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSegmPak'", NULL);
#endif
  {
   self->SetSegmPak(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSegmPak'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AssureResource of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_AssureResource00
static int tolua_engineWin32_Nuclear_Effect_AssureResource00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  bool async = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AssureResource'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectAssureResResult tolua_ret = (Nuclear::Nuclear_EffectAssureResResult)  self->AssureResource(async);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AssureResource'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Release of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Release00
static int tolua_engineWin32_Nuclear_Effect_Release00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Release'", NULL);
#endif
  {
   self->Release();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Release'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScaleType of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetScaleType00
static int tolua_engineWin32_Nuclear_Effect_SetScaleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectScaleType t = ((Nuclear::Nuclear_EffectScaleType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScaleType'", NULL);
#endif
  {
   self->SetScaleType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScaleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScaleType of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetScaleType00
static int tolua_engineWin32_Nuclear_Effect_GetScaleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScaleType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectScaleType tolua_ret = (Nuclear::Nuclear_EffectScaleType)  self->GetScaleType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScaleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddNotify of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_AddNotify00
static int tolua_engineWin32_Nuclear_Effect_AddNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffectNotify* pNotify = ((Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddNotify'", NULL);
#endif
  {
   self->AddNotify(pNotify);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveNotify of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_RemoveNotify00
static int tolua_engineWin32_Nuclear_Effect_RemoveNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffectNotify",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffectNotify* pNotify = ((Nuclear::IEffectNotify*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveNotify'", NULL);
#endif
  {
   self->RemoveNotify(pNotify);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearNotify of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_ClearNotify00
static int tolua_engineWin32_Nuclear_Effect_ClearNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearNotify'", NULL);
#endif
  {
   self->ClearNotify();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: HoldRes of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_HoldRes00
static int tolua_engineWin32_Nuclear_Effect_HoldRes00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HoldRes'", NULL);
#endif
  {
   self->HoldRes();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HoldRes'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Play of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Play00
static int tolua_engineWin32_Nuclear_Effect_Play00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Play'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Play();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Play'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Stop of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Stop00
static int tolua_engineWin32_Nuclear_Effect_Stop00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Stop'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Stop();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Stop'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Pause of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Pause00
static int tolua_engineWin32_Nuclear_Effect_Pause00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Pause'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Pause();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Pause'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Resume of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Resume00
static int tolua_engineWin32_Nuclear_Effect_Resume00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Resume'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Resume();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Resume'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayState of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetPlayState00
static int tolua_engineWin32_Nuclear_Effect_GetPlayState00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayState'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectState tolua_ret = (Nuclear::Nuclear_EffectState)  self->GetPlayState();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayState'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetName of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetName00
static int tolua_engineWin32_Nuclear_Effect_GetName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScreenCrood of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetScreenCrood00
static int tolua_engineWin32_Nuclear_Effect_SetScreenCrood00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScreenCrood'", NULL);
#endif
  {
   self->SetScreenCrood(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScreenCrood'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsScreenCrood of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_IsScreenCrood00
static int tolua_engineWin32_Nuclear_Effect_IsScreenCrood00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsScreenCrood'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsScreenCrood();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsScreenCrood'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRelBouningBox of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetRelBouningBox00
static int tolua_engineWin32_Nuclear_Effect_GetRelBouningBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRelBouningBox'", NULL);
#endif
  {
   const Nuclear::NuclearRect& tolua_ret = (const Nuclear::NuclearRect&)  self->GetRelBouningBox();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearRect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRelBouningBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirection of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetDirection00
static int tolua_engineWin32_Nuclear_Effect_GetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirection'", NULL);
#endif
  {
   Nuclear::NuclearDirection tolua_ret = (Nuclear::NuclearDirection)  self->GetDirection();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLocation of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetLocation00
static int tolua_engineWin32_Nuclear_Effect_GetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLocation'", NULL);
#endif
  {
    Nuclear::NuclearPoint tolua_ret = (  Nuclear::NuclearPoint)  self->GetLocation();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTranslation of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetTranslation00
static int tolua_engineWin32_Nuclear_Effect_GetTranslation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTranslation'", NULL);
#endif
  {
   const Nuclear::NuclearFPoint& tolua_ret = (const Nuclear::NuclearFPoint&)  self->GetTranslation();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTranslation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScale of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetScale00
static int tolua_engineWin32_Nuclear_Effect_GetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScale'", NULL);
#endif
  {
   const Nuclear::NuclearFPoint& tolua_ret = (const Nuclear::NuclearFPoint&)  self->GetScale();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRotationRadian of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetRotationRadian00
static int tolua_engineWin32_Nuclear_Effect_GetRotationRadian00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRotationRadian'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetRotationRadian();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRotationRadian'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetVertexColor of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetVertexColor00
static int tolua_engineWin32_Nuclear_Effect_GetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetVertexColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetVertexColor();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTransparent of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetTransparent00
static int tolua_engineWin32_Nuclear_Effect_GetTransparent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTransparent'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetTransparent();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTransparent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetColorate of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetColorate00
static int tolua_engineWin32_Nuclear_Effect_GetColorate00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetColorate'", NULL);
#endif
  {
   const Nuclear::NuclearVector4& tolua_ret = (const Nuclear::NuclearVector4&)  self->GetColorate();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearVector4");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColorate'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetDirection00
static int tolua_engineWin32_Nuclear_Effect_SetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearDirection direction = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(direction);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetDirection01
static int tolua_engineWin32_Nuclear_Effect_SetDirection01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* target = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Effect_SetDirection00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetDirection02
static int tolua_engineWin32_Nuclear_Effect_SetDirection02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearDirection direction = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearFPoint* target = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(direction,*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Effect_SetDirection01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetLocation00
static int tolua_engineWin32_Nuclear_Effect_SetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* location = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(*location);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetLocation01
static int tolua_engineWin32_Nuclear_Effect_SetLocation01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  int x = ((int)  tolua_tonumber(tolua_S,2,0));
  int y = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(x,y);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Effect_SetLocation00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTranslation of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetTranslation00
static int tolua_engineWin32_Nuclear_Effect_SetTranslation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* trans = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTranslation'", NULL);
#endif
  {
   self->SetTranslation(*trans);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTranslation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetScale00
static int tolua_engineWin32_Nuclear_Effect_SetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  float scaleX = ((float)  tolua_tonumber(tolua_S,2,0));
  float scaleY = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scaleX,scaleY);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRotationRadian of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetRotationRadian00
static int tolua_engineWin32_Nuclear_Effect_SetRotationRadian00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  float radian = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRotationRadian'", NULL);
#endif
  {
   self->SetRotationRadian(radian);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRotationRadian'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetVertexColor of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetVertexColor00
static int tolua_engineWin32_Nuclear_Effect_SetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetVertexColor'", NULL);
#endif
  {
   self->SetVertexColor(color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTransparent of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetTransparent00
static int tolua_engineWin32_Nuclear_Effect_SetTransparent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  float alpha = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTransparent'", NULL);
#endif
  {
   self->SetTransparent(alpha);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTransparent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Colorate of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_Colorate00
static int tolua_engineWin32_Nuclear_Effect_Colorate00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearVector4* color = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Colorate'", NULL);
#endif
  {
   self->Colorate(*color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Colorate'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetType00
static int tolua_engineWin32_Nuclear_Effect_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectType tolua_ret = (Nuclear::Nuclear_EffectType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayMode of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetPlayMode00
static int tolua_engineWin32_Nuclear_Effect_GetPlayMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayMode'", NULL);
#endif
  {
   Nuclear::NuclearPlayMode tolua_ret = (Nuclear::NuclearPlayMode)  self->GetPlayMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLoopNum of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetLoopNum00
static int tolua_engineWin32_Nuclear_Effect_GetLoopNum00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLoopNum'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLoopNum();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLoopNum'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayTime of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetPlayTime00
static int tolua_engineWin32_Nuclear_Effect_GetPlayTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetPlayTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLoopNum of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetLoopNum00
static int tolua_engineWin32_Nuclear_Effect_SetLoopNum00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  int loopNum = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLoopNum'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetLoopNum(loopNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLoopNum'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetPlayTime of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetPlayTime00
static int tolua_engineWin32_Nuclear_Effect_SetPlayTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  DWORD time = ((DWORD)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetPlayTime'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetPlayTime(time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetPlayTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayOnceTime of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetPlayOnceTime00
static int tolua_engineWin32_Nuclear_Effect_GetPlayOnceTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Effect* self = (const Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayOnceTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetPlayOnceTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayOnceTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBase of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetBase00
static int tolua_engineWin32_Nuclear_Effect_GetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBase* base = ((Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBase'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBase(*base);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundType of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetSoundType00
static int tolua_engineWin32_Nuclear_Effect_SetSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  unsigned char type = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundType'", NULL);
#endif
  {
   self->SetSoundType(type);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundType of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetSoundType00
static int tolua_engineWin32_Nuclear_Effect_GetSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSoundPriority of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_SetSoundPriority00
static int tolua_engineWin32_Nuclear_Effect_SetSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
  short priority = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSoundPriority'", NULL);
#endif
  {
   self->SetSoundPriority(priority);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundPriority of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_GetSoundPriority00
static int tolua_engineWin32_Nuclear_Effect_GetSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundPriority'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetSoundPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveAudio of class  Nuclear::Effect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Effect_RemoveAudio00
static int tolua_engineWin32_Nuclear_Effect_RemoveAudio00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Effect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Effect* self = (Nuclear::Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveAudio'", NULL);
#endif
  {
   self->RemoveAudio();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveAudio'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pt0 of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__LINE_pt0
static int tolua_get_Nuclear__LINE_pt0(lua_State* tolua_S)
{
  Nuclear::LINE* self = (Nuclear::LINE*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pt0'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->pt0,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: pt0 of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__LINE_pt0
static int tolua_set_Nuclear__LINE_pt0(lua_State* tolua_S)
{
  Nuclear::LINE* self = (Nuclear::LINE*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pt0'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->pt0 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pt1 of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__LINE_pt1
static int tolua_get_Nuclear__LINE_pt1(lua_State* tolua_S)
{
  Nuclear::LINE* self = (Nuclear::LINE*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pt1'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->pt1,"Nuclear::NuclearPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: pt1 of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__LINE_pt1
static int tolua_set_Nuclear__LINE_pt1(lua_State* tolua_S)
{
  Nuclear::LINE* self = (Nuclear::LINE*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pt1'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->pt1 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new00
static int tolua_engineWin32_Nuclear_LINE_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new00_local
static int tolua_engineWin32_Nuclear_LINE_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new01
static int tolua_engineWin32_Nuclear_LINE_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint point0 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)(point0));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_LINE_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new01_local
static int tolua_engineWin32_Nuclear_LINE_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint point0 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)(point0));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_LINE_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new02
static int tolua_engineWin32_Nuclear_LINE_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint point0 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearPoint point1 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)(point0,point1));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_LINE_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::LINE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_LINE_new02_local
static int tolua_engineWin32_Nuclear_LINE_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::LINE",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearPoint point0 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearPoint point1 = *((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::LINE* tolua_ret = (Nuclear::LINE*)  Mtolua_new((Nuclear::LINE)(point0,point1));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::LINE");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_LINE_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pointCent of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_pointCent
static int tolua_get_Nuclear__PSModifyParam_m_pointCent(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointCent'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_pointCent,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pointCent of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_pointCent
static int tolua_set_Nuclear__PSModifyParam_m_pointCent(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointCent'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pointCent = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fEmitterSpinAngle of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fEmitterSpinAngle
static int tolua_get_Nuclear__PSModifyParam_m_fEmitterSpinAngle(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fEmitterSpinAngle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fEmitterSpinAngle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fEmitterSpinAngle of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fEmitterSpinAngle
static int tolua_set_Nuclear__PSModifyParam_m_fEmitterSpinAngle(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fEmitterSpinAngle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fEmitterSpinAngle = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pointObject of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_pointObject
static int tolua_get_Nuclear__PSModifyParam_m_pointObject(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointObject'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_pointObject,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pointObject of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_pointObject
static int tolua_set_Nuclear__PSModifyParam_m_pointObject(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointObject'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pointObject = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fEmissionScale of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fEmissionScale
static int tolua_get_Nuclear__PSModifyParam_m_fEmissionScale(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fEmissionScale'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fEmissionScale);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fEmissionScale of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fEmissionScale
static int tolua_set_Nuclear__PSModifyParam_m_fEmissionScale(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fEmissionScale'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fEmissionScale = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fLineLength of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fLineLength
static int tolua_get_Nuclear__PSModifyParam_m_fLineLength(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fLineLength'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fLineLength);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fLineLength of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fLineLength
static int tolua_set_Nuclear__PSModifyParam_m_fLineLength(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fLineLength'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fLineLength = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fRctWidth of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fRctWidth
static int tolua_get_Nuclear__PSModifyParam_m_fRctWidth(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fRctWidth'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fRctWidth);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fRctWidth of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fRctWidth
static int tolua_set_Nuclear__PSModifyParam_m_fRctWidth(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fRctWidth'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fRctWidth = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fRctHeight of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fRctHeight
static int tolua_get_Nuclear__PSModifyParam_m_fRctHeight(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fRctHeight'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fRctHeight);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fRctHeight of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fRctHeight
static int tolua_set_Nuclear__PSModifyParam_m_fRctHeight(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fRctHeight'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fRctHeight = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_scaleType of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_scaleType
static int tolua_get_Nuclear__PSModifyParam_m_scaleType(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_scaleType'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_scaleType);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_scaleType of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_scaleType
static int tolua_set_Nuclear__PSModifyParam_m_scaleType(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_scaleType'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_scaleType = ((Nuclear::Nuclear_EffectScaleType) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fParticleSizeCoef of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fParticleSizeCoef
static int tolua_get_Nuclear__PSModifyParam_m_fParticleSizeCoef(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fParticleSizeCoef'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fParticleSizeCoef);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fParticleSizeCoef of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fParticleSizeCoef
static int tolua_set_Nuclear__PSModifyParam_m_fParticleSizeCoef(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fParticleSizeCoef'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fParticleSizeCoef = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fParticlePosCoef of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fParticlePosCoef
static int tolua_get_Nuclear__PSModifyParam_m_fParticlePosCoef(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fParticlePosCoef'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fParticlePosCoef);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fParticlePosCoef of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fParticlePosCoef
static int tolua_set_Nuclear__PSModifyParam_m_fParticlePosCoef(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fParticlePosCoef'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fParticlePosCoef = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fpoint0 of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fpoint0
static int tolua_get_Nuclear__PSModifyParam_m_fpoint0(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fpoint0'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_fpoint0,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fpoint0 of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fpoint0
static int tolua_set_Nuclear__PSModifyParam_m_fpoint0(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fpoint0'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fpoint0 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fpoint1 of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fpoint1
static int tolua_get_Nuclear__PSModifyParam_m_fpoint1(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fpoint1'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_fpoint1,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fpoint1 of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fpoint1
static int tolua_set_Nuclear__PSModifyParam_m_fpoint1(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fpoint1'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fpoint1 = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_fLineEmitterRotate of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_fLineEmitterRotate
static int tolua_get_Nuclear__PSModifyParam_m_fLineEmitterRotate(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fLineEmitterRotate'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_fLineEmitterRotate);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_fLineEmitterRotate of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_fLineEmitterRotate
static int tolua_set_Nuclear__PSModifyParam_m_fLineEmitterRotate(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_fLineEmitterRotate'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_fLineEmitterRotate = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_dwColor of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSModifyParam_m_dwColor
static int tolua_get_Nuclear__PSModifyParam_m_dwColor(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_dwColor'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_dwColor);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_dwColor of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSModifyParam_m_dwColor
static int tolua_set_Nuclear__PSModifyParam_m_dwColor(lua_State* tolua_S)
{
  Nuclear::PSModifyParam* self = (Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_dwColor'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_dwColor = ((DWORD)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSModifyParam_new00
static int tolua_engineWin32_Nuclear_PSModifyParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSModifyParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSModifyParam* tolua_ret = (Nuclear::PSModifyParam*)  Mtolua_new((Nuclear::PSModifyParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSModifyParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::PSModifyParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSModifyParam_new00_local
static int tolua_engineWin32_Nuclear_PSModifyParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSModifyParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSModifyParam* tolua_ret = (Nuclear::PSModifyParam*)  Mtolua_new((Nuclear::PSModifyParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSModifyParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_psModifyParam of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_psModifyParam
static int tolua_get_Nuclear__PSParameter_m_psModifyParam(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_psModifyParam'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_psModifyParam,"Nuclear::PSModifyParam");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_psModifyParam of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_psModifyParam
static int tolua_set_Nuclear__PSParameter_m_psModifyParam(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_psModifyParam'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::PSModifyParam",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_psModifyParam = *((Nuclear::PSModifyParam*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: time of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_time
static int tolua_get_Nuclear__PSParameter_time(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'time'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->time);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: time of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_time
static int tolua_set_Nuclear__PSParameter_time(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'time'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->time = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: layer of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_layer
static int tolua_get_Nuclear__PSParameter_layer(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'layer'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->layer);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: layer of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_layer
static int tolua_set_Nuclear__PSParameter_layer(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'layer'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->layer = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_bScreenCoord of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_bScreenCoord
static int tolua_get_Nuclear__PSParameter_m_bScreenCoord(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bScreenCoord'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->m_bScreenCoord);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_bScreenCoord of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_bScreenCoord
static int tolua_set_Nuclear__PSParameter_m_bScreenCoord(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bScreenCoord'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_bScreenCoord = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: cycle of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_cycle
static int tolua_get_Nuclear__PSParameter_cycle(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'cycle'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->cycle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: cycle of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_cycle
static int tolua_set_Nuclear__PSParameter_cycle(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'cycle'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->cycle = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: autorender of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_autorender
static int tolua_get_Nuclear__PSParameter_autorender(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'autorender'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->autorender);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: autorender of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_autorender
static int tolua_set_Nuclear__PSParameter_autorender(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'autorender'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->autorender = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_bVertexRHWflag of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_bVertexRHWflag
static int tolua_get_Nuclear__PSParameter_m_bVertexRHWflag(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bVertexRHWflag'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->m_bVertexRHWflag);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_bVertexRHWflag of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_bVertexRHWflag
static int tolua_set_Nuclear__PSParameter_m_bVertexRHWflag(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bVertexRHWflag'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_bVertexRHWflag = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_bModifyLineEmitter of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_bModifyLineEmitter
static int tolua_get_Nuclear__PSParameter_m_bModifyLineEmitter(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bModifyLineEmitter'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_bModifyLineEmitter);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_bModifyLineEmitter of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_bModifyLineEmitter
static int tolua_set_Nuclear__PSParameter_m_bModifyLineEmitter(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bModifyLineEmitter'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_bModifyLineEmitter = ((BOOL)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_ptLineEmitterStrt of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_ptLineEmitterStrt
static int tolua_get_Nuclear__PSParameter_m_ptLineEmitterStrt(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_ptLineEmitterStrt'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_ptLineEmitterStrt,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_ptLineEmitterStrt of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_ptLineEmitterStrt
static int tolua_set_Nuclear__PSParameter_m_ptLineEmitterStrt(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_ptLineEmitterStrt'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_ptLineEmitterStrt = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_ptLineEmitterEnd of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSParameter_m_ptLineEmitterEnd
static int tolua_get_Nuclear__PSParameter_m_ptLineEmitterEnd(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_ptLineEmitterEnd'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_ptLineEmitterEnd,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_ptLineEmitterEnd of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSParameter_m_ptLineEmitterEnd
static int tolua_set_Nuclear__PSParameter_m_ptLineEmitterEnd(lua_State* tolua_S)
{
  Nuclear::PSParameter* self = (Nuclear::PSParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_ptLineEmitterEnd'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_ptLineEmitterEnd = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSParameter_new00
static int tolua_engineWin32_Nuclear_PSParameter_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSParameter",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSParameter* tolua_ret = (Nuclear::PSParameter*)  Mtolua_new((Nuclear::PSParameter)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSParameter");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::PSParameter */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSParameter_new00_local
static int tolua_engineWin32_Nuclear_PSParameter_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSParameter",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSParameter* tolua_ret = (Nuclear::PSParameter*)  Mtolua_new((Nuclear::PSParameter)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSParameter");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_rctMaxBox of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_rctMaxBox
static int tolua_get_Nuclear__PSINFO_m_rctMaxBox(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_rctMaxBox'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_rctMaxBox,"Nuclear::NuclearRect");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_rctMaxBox of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_rctMaxBox
static int tolua_set_Nuclear__PSINFO_m_rctMaxBox(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_rctMaxBox'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_rctMaxBox = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pointCent of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_pointCent
static int tolua_get_Nuclear__PSINFO_m_pointCent(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointCent'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_pointCent,"Nuclear::NuclearFPoint");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pointCent of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_pointCent
static int tolua_set_Nuclear__PSINFO_m_pointCent(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pointCent'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pointCent = *((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_moveType of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_moveType
static int tolua_get_Nuclear__PSINFO_m_moveType(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_moveType'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_moveType);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_moveType of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_moveType
static int tolua_set_Nuclear__PSINFO_m_moveType(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_moveType'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_moveType = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_emisType of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_emisType
static int tolua_get_Nuclear__PSINFO_m_emisType(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_emisType'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_emisType);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_emisType of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_emisType
static int tolua_set_Nuclear__PSINFO_m_emisType(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_emisType'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_emisType = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_nPSLConfigReq of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_nPSLConfigReq
static int tolua_get_Nuclear__PSINFO_m_nPSLConfigReq(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPSLConfigReq'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_nPSLConfigReq);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_nPSLConfigReq of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_nPSLConfigReq
static int tolua_set_Nuclear__PSINFO_m_nPSLConfigReq(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPSLConfigReq'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_nPSLConfigReq = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_bCycle of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__PSINFO_m_bCycle
static int tolua_get_Nuclear__PSINFO_m_bCycle(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bCycle'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->m_bCycle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_bCycle of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__PSINFO_m_bCycle
static int tolua_set_Nuclear__PSINFO_m_bCycle(lua_State* tolua_S)
{
  Nuclear::PSINFO* self = (Nuclear::PSINFO*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_bCycle'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_bCycle = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSINFO_new00
static int tolua_engineWin32_Nuclear_PSINFO_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSINFO",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSINFO* tolua_ret = (Nuclear::PSINFO*)  Mtolua_new((Nuclear::PSINFO)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSINFO");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::PSINFO */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PSINFO_new00_local
static int tolua_engineWin32_Nuclear_PSINFO_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::PSINFO",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::PSINFO* tolua_ret = (Nuclear::PSINFO*)  Mtolua_new((Nuclear::PSINFO)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::PSINFO");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_delete00
static int tolua_engineWin32_Nuclear_IParticleEffect_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyObjectPoint of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_ModifyObjectPoint00
static int tolua_engineWin32_Nuclear_IParticleEffect_ModifyObjectPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyObjectPoint'", NULL);
#endif
  {
   self->ModifyObjectPoint(*pt);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyObjectPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyLineLength of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_ModifyLineLength00
static int tolua_engineWin32_Nuclear_IParticleEffect_ModifyLineLength00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float length = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyLineLength'", NULL);
#endif
  {
   self->ModifyLineLength(length);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyLineLength'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyRectWH of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_ModifyRectWH00
static int tolua_engineWin32_Nuclear_IParticleEffect_ModifyRectWH00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float width = ((float)  tolua_tonumber(tolua_S,2,0));
  float height = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyRectWH'", NULL);
#endif
  {
   self->ModifyRectWH(width,height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyRectWH'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRctBlindAreas of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetRctBlindAreas00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetRctBlindAreas00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<Nuclear::NuclearRect>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const std::vector<Nuclear::NuclearRect>* vet = ((const std::vector<Nuclear::NuclearRect>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRctBlindAreas'", NULL);
#endif
  {
   self->SetRctBlindAreas(*vet);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRctBlindAreas'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCycleMode of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetCycleMode00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetCycleMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPParticleEffectCycleMode mode = ((Nuclear::XPParticleEffectCycleMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCycleMode'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCycleMode(mode);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCycleMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCycleMode of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetCycleMode00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetCycleMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IParticleEffect* self = (const Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCycleMode'", NULL);
#endif
  {
   Nuclear::XPParticleEffectCycleMode tolua_ret = (Nuclear::XPParticleEffectCycleMode)  self->GetCycleMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCycleMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSysLife of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetSysLife00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetSysLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float time = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSysLife'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSysLife(time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSysLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSysLife of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetSysLife00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetSysLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSysLife'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetSysLife();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSysLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEmitterLinkPoint of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetEmitterLinkPoint00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetEmitterLinkPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  int type = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEmitterLinkPoint'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetEmitterLinkPoint(*pt,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEmitterLinkPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEmitterLinkPoint of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetEmitterLinkPoint00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetEmitterLinkPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFPoint* pt = ((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  int type = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEmitterLinkPoint'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetEmitterLinkPoint(*pt,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEmitterLinkPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetNumActiveParticles of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetNumActiveParticles00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetNumActiveParticles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IParticleEffect* self = (const Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetNumActiveParticles'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetNumActiveParticles();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetNumActiveParticles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleMaxLife of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetParticleMaxLife00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetParticleMaxLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IParticleEffect* self = (const Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleMaxLife'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetParticleMaxLife();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleMaxLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpecialPsTexture of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsTexture00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
   int ShapesTexture = ((  int)  tolua_tonumber(tolua_S,2,0));
  float fu = ((float)  tolua_tonumber(tolua_S,3,1.0f));
  float fv = ((float)  tolua_tonumber(tolua_S,4,1.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpecialPsTexture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSpecialPsTexture(ShapesTexture,fu,fv);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpecialPsTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpecialPSTextureHandle of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_GetSpecialPSTextureHandle00
static int tolua_engineWin32_Nuclear_IParticleEffect_GetSpecialPSTextureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IParticleEffect* self = (const Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpecialPSTextureHandle'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetSpecialPSTextureHandle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpecialPSTextureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpecialPsScale of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsScale00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float fcx = ((float)  tolua_tonumber(tolua_S,2,1.0f));
  float fcy = ((float)  tolua_tonumber(tolua_S,3,1.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpecialPsScale'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSpecialPsScale(fcx,fcy);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpecialPsScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSilentTime of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_SetSilentTime00
static int tolua_engineWin32_Nuclear_IParticleEffect_SetSilentTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float ftime = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSilentTime'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSilentTime(ftime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSilentTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ConvertToIEffect of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect00
static int tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IParticleEffect* self = (Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ConvertToIEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->ConvertToIEffect();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ConvertToIEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ConvertToIEffect of class  Nuclear::IParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect01
static int tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::IParticleEffect* self = (const Nuclear::IParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ConvertToIEffect'", NULL);
#endif
  {
   const Nuclear::IEffect* tolua_ret = (const Nuclear::IEffect*)  self->ConvertToIEffect();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::IEffect");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_delete00
static int tolua_engineWin32_Nuclear_ParticleEffect_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScaleType of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetScaleType00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetScaleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectScaleType t = ((Nuclear::Nuclear_EffectScaleType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScaleType'", NULL);
#endif
  {
   self->SetScaleType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScaleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScaleType of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetScaleType00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetScaleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScaleType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectScaleType tolua_ret = (Nuclear::Nuclear_EffectScaleType)  self->GetScaleType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScaleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnReady of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_OnReady00
static int tolua_engineWin32_Nuclear_ParticleEffect_OnReady00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  bool success = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnReady'", NULL);
#endif
  {
   self->OnReady(success);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnReady'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AssureResource of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_AssureResource00
static int tolua_engineWin32_Nuclear_ParticleEffect_AssureResource00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  bool async = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AssureResource'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectAssureResResult tolua_ret = (Nuclear::Nuclear_EffectAssureResResult)  self->AssureResource(async);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AssureResource'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Release of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_Release00
static int tolua_engineWin32_Nuclear_ParticleEffect_Release00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Release'", NULL);
#endif
  {
   self->Release();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Release'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetType of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetType00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectType tolua_ret = (Nuclear::Nuclear_EffectType)  self->GetType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEffectBindType of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetEffectBindType00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_EffectBindType t = ((Nuclear::Nuclear_EffectBindType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEffectBindType'", NULL);
#endif
  {
   self->SetEffectBindType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectBindType of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetEffectBindType00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetEffectBindType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectBindType'", NULL);
#endif
  {
   Nuclear::Nuclear_EffectBindType tolua_ret = (Nuclear::Nuclear_EffectBindType)  self->GetEffectBindType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectBindType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScreenCrood of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetScreenCrood00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetScreenCrood00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScreenCrood'", NULL);
#endif
  {
   self->SetScreenCrood(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScreenCrood'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsScreenCrood of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_IsScreenCrood00
static int tolua_engineWin32_Nuclear_ParticleEffect_IsScreenCrood00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsScreenCrood'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsScreenCrood();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsScreenCrood'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetLocation00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* location = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(*location);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_Render00
static int tolua_engineWin32_Nuclear_ParticleEffect_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Canvas* canvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,2,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Render(canvas,realRender);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CollectRender of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_CollectRender00
static int tolua_engineWin32_Nuclear_ParticleEffect_CollectRender00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CollectRender'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CollectRender();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CollectRender'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLoopNum of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetLoopNum00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetLoopNum00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  int loopNum = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLoopNum'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetLoopNum(loopNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLoopNum'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetPlayTime of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetPlayTime00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetPlayTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  DWORD time = ((DWORD)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetPlayTime'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetPlayTime(time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetPlayTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCycleMode of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetCycleMode00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetCycleMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPParticleEffectCycleMode mode = ((Nuclear::XPParticleEffectCycleMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCycleMode'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCycleMode(mode);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCycleMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCycleMode of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetCycleMode00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetCycleMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCycleMode'", NULL);
#endif
  {
   Nuclear::XPParticleEffectCycleMode tolua_ret = (Nuclear::XPParticleEffectCycleMode)  self->GetCycleMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCycleMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSysLife of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetSysLife00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetSysLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float time = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSysLife'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSysLife(time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSysLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSysLife of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetSysLife00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetSysLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSysLife'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetSysLife();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSysLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEmitterLinkPoint of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetEmitterLinkPoint00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetEmitterLinkPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  int type = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEmitterLinkPoint'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetEmitterLinkPoint(*pt,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEmitterLinkPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEmitterLinkPoint of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetEmitterLinkPoint00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetEmitterLinkPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFPoint* pt = ((Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  int type = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEmitterLinkPoint'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetEmitterLinkPoint(*pt,type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEmitterLinkPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Play of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_Play00
static int tolua_engineWin32_Nuclear_ParticleEffect_Play00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Play'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Play();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Play'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPlayOnceTime of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetPlayOnceTime00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetPlayOnceTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPlayOnceTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetPlayOnceTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPlayOnceTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBase of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetBase00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetBase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearBase",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBase* base = ((Nuclear::NuclearBase*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBase'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetBase(*base);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetVertexColor of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetVertexColor00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetVertexColor'", NULL);
#endif
  {
   self->SetVertexColor(color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTransparent of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetTransparent00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetTransparent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float alpha = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTransparent'", NULL);
#endif
  {
   self->SetTransparent(alpha);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTransparent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Colorate of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_Colorate00
static int tolua_engineWin32_Nuclear_ParticleEffect_Colorate00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearVector4",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearVector4* color = ((const Nuclear::NuclearVector4*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Colorate'", NULL);
#endif
  {
   self->Colorate(*color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Colorate'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetColorate of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetColorate00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetColorate00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetColorate'", NULL);
#endif
  {
   const Nuclear::NuclearVector4& tolua_ret = (const Nuclear::NuclearVector4&)  self->GetColorate();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearVector4");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColorate'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetVertexColor of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetVertexColor00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetVertexColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetVertexColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetVertexColor();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetVertexColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTransparent of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetTransparent00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetTransparent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTransparent'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetTransparent();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTransparent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TryConvertToParticle of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticle00
static int tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TryConvertToParticle'", NULL);
#endif
  {
   const Nuclear::IParticleEffect* tolua_ret = (const Nuclear::IParticleEffect*)  self->TryConvertToParticle();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::IParticleEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TryConvertToParticle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TryConvertToParticleEffect of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticleEffect00
static int tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticleEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TryConvertToParticleEffect'", NULL);
#endif
  {
   const Nuclear::ParticleEffect* tolua_ret = (const Nuclear::ParticleEffect*)  self->TryConvertToParticleEffect();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::ParticleEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TryConvertToParticleEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyObjectPoint of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_ModifyObjectPoint00
static int tolua_engineWin32_Nuclear_ParticleEffect_ModifyObjectPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFPoint* pt = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyObjectPoint'", NULL);
#endif
  {
   self->ModifyObjectPoint(*pt);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyObjectPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyLineLength of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_ModifyLineLength00
static int tolua_engineWin32_Nuclear_ParticleEffect_ModifyLineLength00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float length = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyLineLength'", NULL);
#endif
  {
   self->ModifyLineLength(length);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyLineLength'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ModifyRectWH of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_ModifyRectWH00
static int tolua_engineWin32_Nuclear_ParticleEffect_ModifyRectWH00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float width = ((float)  tolua_tonumber(tolua_S,2,0));
  float height = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ModifyRectWH'", NULL);
#endif
  {
   self->ModifyRectWH(width,height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ModifyRectWH'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetNumActiveParticles of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetNumActiveParticles00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetNumActiveParticles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetNumActiveParticles'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetNumActiveParticles();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetNumActiveParticles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleSystemInfo of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemInfo00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleSystemInfo'", NULL);
#endif
  {
   Nuclear::PSINFO tolua_ret = (Nuclear::PSINFO)  self->GetParticleSystemInfo();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::PSINFO)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::PSINFO");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::PSINFO));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::PSINFO");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleSystemInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleSystemParameter of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemParameter00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemParameter00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleSystemParameter'", NULL);
#endif
  {
   const Nuclear::PSParameter& tolua_ret = (const Nuclear::PSParameter&)  self->GetParticleSystemParameter();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::PSParameter");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleSystemParameter'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleMaxLife of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetParticleMaxLife00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetParticleMaxLife00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleMaxLife'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetParticleMaxLife();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleMaxLife'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpecialPsTexture of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsTexture00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
   int ShapesTexture = ((  int)  tolua_tonumber(tolua_S,2,0));
  float fu = ((float)  tolua_tonumber(tolua_S,3,1));
  float fv = ((float)  tolua_tonumber(tolua_S,4,1));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpecialPsTexture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSpecialPsTexture(ShapesTexture,fu,fv);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpecialPsTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpecialPSTextureHandle of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_GetSpecialPSTextureHandle00
static int tolua_engineWin32_Nuclear_ParticleEffect_GetSpecialPSTextureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ParticleEffect* self = (const Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpecialPSTextureHandle'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetSpecialPSTextureHandle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpecialPSTextureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpecialPsScale of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsScale00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float fcx = ((float)  tolua_tonumber(tolua_S,2,1));
  float fcy = ((float)  tolua_tonumber(tolua_S,3,1));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpecialPsScale'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSpecialPsScale(fcx,fcy);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpecialPsScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSilentTime of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_SetSilentTime00
static int tolua_engineWin32_Nuclear_ParticleEffect_SetSilentTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
  float ftime = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSilentTime'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSilentTime(ftime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSilentTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ConvertToIEffect of class  Nuclear::ParticleEffect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ParticleEffect_ConvertToIEffect00
static int tolua_engineWin32_Nuclear_ParticleEffect_ConvertToIEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ParticleEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ParticleEffect* self = (Nuclear::ParticleEffect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ConvertToIEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->ConvertToIEffect();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ConvertToIEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnEvents of class  Nuclear::SpriteEventNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteEventNotify_OnEvents00
static int tolua_engineWin32_Nuclear_SpriteEventNotify_OnEvents00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteEventNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const std::vector<int>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteEventNotify* self = (Nuclear::SpriteEventNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  const std::vector<int>* eventIDs = ((const std::vector<int>*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnEvents'", NULL);
#endif
  {
   self->OnEvents(pSprite,*eventIDs);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnEvents'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnPlayFrame of class  Nuclear::SpriteNotify */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_SpriteNotify_OnPlayFrame00
static int tolua_engineWin32_Nuclear_SpriteNotify_OnPlayFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::SpriteNotify",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::SpriteNotify* self = (Nuclear::SpriteNotify*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::ISprite* pSprite = ((Nuclear::ISprite*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring actionName = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int frame = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnPlayFrame'", NULL);
#endif
  {
   self->OnPlayFrame(pSprite,actionName,frame);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actionName);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnPlayFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_delete00
static int tolua_engineWin32_Nuclear_ISprite_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RegisterFrameNotify of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_RegisterFrameNotify00
static int tolua_engineWin32_Nuclear_ISprite_RegisterFrameNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::SpriteNotify",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::SpriteNotify* pNotify = ((Nuclear::SpriteNotify*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring actionName = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int frame = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RegisterFrameNotify'", NULL);
#endif
  {
   self->RegisterFrameNotify(pNotify,actionName,frame);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actionName);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RegisterFrameNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DeregisterFrameNotify of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_DeregisterFrameNotify00
static int tolua_engineWin32_Nuclear_ISprite_DeregisterFrameNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::SpriteNotify",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::SpriteNotify* pNotify = ((Nuclear::SpriteNotify*)  tolua_tousertype(tolua_S,2,0));
  const std::wstring actionName = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int frame = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DeregisterFrameNotify'", NULL);
#endif
  {
   self->DeregisterFrameNotify(pNotify,actionName,frame);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actionName);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeregisterFrameNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableStepSound of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_EnableStepSound00
static int tolua_engineWin32_Nuclear_ISprite_EnableStepSound00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableStepSound'", NULL);
#endif
  {
   self->EnableStepSound(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableStepSound'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsStepSoundEnable of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsStepSoundEnable00
static int tolua_engineWin32_Nuclear_ISprite_IsStepSoundEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsStepSoundEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsStepSoundEnable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsStepSoundEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ClearAllNotify of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_ClearAllNotify00
static int tolua_engineWin32_Nuclear_ISprite_ClearAllNotify00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ClearAllNotify'", NULL);
#endif
  {
   self->ClearAllNotify();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClearAllNotify'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSoundActorName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetSoundActorName00
static int tolua_engineWin32_Nuclear_ISprite_GetSoundActorName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSoundActorName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetSoundActorName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSoundActorName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpAllActionNames of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_DumpAllActionNames00
static int tolua_engineWin32_Nuclear_ISprite_DumpAllActionNames00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"std::vector<std::wstring>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  std::vector<std::wstring>* actions = ((std::vector<std::wstring>*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpAllActionNames'", NULL);
#endif
  {
   self->DumpAllActionNames(*actions);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpAllActionNames'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScale of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetScale00
static int tolua_engineWin32_Nuclear_ISprite_SetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  float scale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScale'", NULL);
#endif
  {
   self->SetScale(scale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScale of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetScale00
static int tolua_engineWin32_Nuclear_ISprite_GetScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLocation of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetLocation00
static int tolua_engineWin32_Nuclear_ISprite_SetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* location = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLocation'", NULL);
#endif
  {
   self->SetLocation(*location);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLocation of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetLocation00
static int tolua_engineWin32_Nuclear_ISprite_GetLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLocation'", NULL);
#endif
  {
    Nuclear::NuclearPoint tolua_ret = (  Nuclear::NuclearPoint)  self->GetLocation();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDirection00
static int tolua_engineWin32_Nuclear_ISprite_SetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearDirection direction = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(direction);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDirection of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetDirection00
static int tolua_engineWin32_Nuclear_ISprite_GetDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDirection'", NULL);
#endif
  {
   Nuclear::NuclearDirection tolua_ret = (Nuclear::NuclearDirection)  self->GetDirection();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetVectorDirection of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetVectorDirection00
static int tolua_engineWin32_Nuclear_ISprite_GetVectorDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetVectorDirection'", NULL);
#endif
  {
   Nuclear::NuclearFPoint tolua_ret = (Nuclear::NuclearFPoint)  self->GetVectorDirection();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearFPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearFPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearFPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetVectorDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UseRenderTarget of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_UseRenderTarget00
static int tolua_engineWin32_Nuclear_ISprite_UseRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UseRenderTarget'", NULL);
#endif
  {
   self->UseRenderTarget(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UseRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsUseRenderTarget of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsUseRenderTarget00
static int tolua_engineWin32_Nuclear_ISprite_IsUseRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsUseRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsUseRenderTarget();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsUseRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetVisible of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetVisible00
static int tolua_engineWin32_Nuclear_ISprite_SetVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetVisible'", NULL);
#endif
  {
   self->SetVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsVisiable of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsVisiable00
static int tolua_engineWin32_Nuclear_ISprite_IsVisiable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsVisiable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsVisiable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsVisiable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEntityVisible of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetEntityVisible00
static int tolua_engineWin32_Nuclear_ISprite_SetEntityVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEntityVisible'", NULL);
#endif
  {
   self->SetEntityVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEntityVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEntityVisible of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsEntityVisible00
static int tolua_engineWin32_Nuclear_ISprite_IsEntityVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEntityVisible'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEntityVisible();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEntityVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitleVisible of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetTitleVisible00
static int tolua_engineWin32_Nuclear_ISprite_SetTitleVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool v = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitleVisible'", NULL);
#endif
  {
   self->SetTitleVisible(v);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitleVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTitleVisible of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsTitleVisible00
static int tolua_engineWin32_Nuclear_ISprite_IsTitleVisible00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTitleVisible'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTitleVisible();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTitleVisible'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetAlpha00
static int tolua_engineWin32_Nuclear_ISprite_SetAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  unsigned char a = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAlpha'", NULL);
#endif
  {
   self->SetAlpha(a);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetAlpha00
static int tolua_engineWin32_Nuclear_ISprite_GetAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAlpha'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetAlpha();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsCoveredAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsCoveredAlpha00
static int tolua_engineWin32_Nuclear_ISprite_IsCoveredAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsCoveredAlpha'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsCoveredAlpha();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsCoveredAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCoveredAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetCoveredAlpha00
static int tolua_engineWin32_Nuclear_ISprite_SetCoveredAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCoveredAlpha'", NULL);
#endif
  {
   self->SetCoveredAlpha(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCoveredAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSolidMask of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsSolidMask00
static int tolua_engineWin32_Nuclear_ISprite_IsSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSolidMask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSolidMask();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSolidMask of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetSolidMask00
static int tolua_engineWin32_Nuclear_ISprite_SetSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSolidMask'", NULL);
#endif
  {
   self->SetSolidMask(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsUpdateEveryFrame of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsUpdateEveryFrame00
static int tolua_engineWin32_Nuclear_ISprite_IsUpdateEveryFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsUpdateEveryFrame'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsUpdateEveryFrame();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsUpdateEveryFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetUpdateEveryFrame of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetUpdateEveryFrame00
static int tolua_engineWin32_Nuclear_ISprite_SetUpdateEveryFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetUpdateEveryFrame'", NULL);
#endif
  {
   self->SetUpdateEveryFrame(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetUpdateEveryFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitle of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetTitle00
static int tolua_engineWin32_Nuclear_ISprite_SetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearTitleAlign align = ((Nuclear::NuclearTitleAlign) (int)  tolua_tonumber(tolua_S,3,Nuclear::XPTA_DEFAULT));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitle'", NULL);
#endif
  {
   self->SetTitle(handle,align);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitle of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTitle00
static int tolua_engineWin32_Nuclear_ISprite_GetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitle'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->GetTitle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: UnsetTitle of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_UnsetTitle00
static int tolua_engineWin32_Nuclear_ISprite_UnsetTitle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'UnsetTitle'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->UnsetTitle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UnsetTitle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitleSize of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetTitleSize00
static int tolua_engineWin32_Nuclear_ISprite_SetTitleSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int width = ((int)  tolua_tonumber(tolua_S,2,0));
  int height = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitleSize'", NULL);
#endif
  {
   self->SetTitleSize(width,height);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitleSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitleWidth of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTitleWidth00
static int tolua_engineWin32_Nuclear_ISprite_GetTitleWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitleWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTitleWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitleWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitleHeight of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTitleHeight00
static int tolua_engineWin32_Nuclear_ISprite_GetTitleHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitleHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTitleHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitleHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTitleBindSocket of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetTitleBindSocket00
static int tolua_engineWin32_Nuclear_ISprite_SetTitleBindSocket00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring socket = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTitleBindSocket'", NULL);
#endif
  {
   self->SetTitleBindSocket(socket);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)socket);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTitleBindSocket'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTitleBindSocket of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTitleBindSocket00
static int tolua_engineWin32_Nuclear_ISprite_GetTitleBindSocket00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTitleBindSocket'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetTitleBindSocket();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTitleBindSocket'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBubbleItemOffset of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetBubbleItemOffset00
static int tolua_engineWin32_Nuclear_ISprite_GetBubbleItemOffset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBubbleItemOffset'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetBubbleItemOffset();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBubbleItemOffset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectPos of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetEffectPos00
static int tolua_engineWin32_Nuclear_ISprite_GetEffectPos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectPos'", NULL);
#endif
  {
   const Nuclear::NuclearPoint& tolua_ret = (const Nuclear::NuclearPoint&)  self->GetEffectPos();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"const Nuclear::NuclearPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectPos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetModel of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetModel00
static int tolua_engineWin32_Nuclear_ISprite_SetModel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetModel'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetModel(modelname,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetModel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetModel of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetModel01
static int tolua_engineWin32_Nuclear_ISprite_SetModel01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetModel'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetModel(modelname);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ISprite_SetModel00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetModelName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetModelName00
static int tolua_engineWin32_Nuclear_ISprite_GetModelName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetModelName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetModelName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetModelName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetComponent of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetComponent00
static int tolua_engineWin32_Nuclear_ISprite_SetComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_iscppwstring(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int scid = ((int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring resource = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  std::wstring wsLayerName = ((std::wstring)  tolua_tocppwstring(tolua_S,5,L""));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetComponent'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetComponent(scid,resource,color,wsLayerName);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)resource);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetComponent of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetComponent00
static int tolua_engineWin32_Nuclear_ISprite_GetComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int scid = ((int)  tolua_tonumber(tolua_S,2,0));
  std::wstring resource = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetComponent'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetComponent(scid,resource);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)resource);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetComponentColor of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetComponentColor00
static int tolua_engineWin32_Nuclear_ISprite_GetComponentColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int scid = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearColor* color = ((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetComponentColor'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetComponentColor(scid,*color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetComponentColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRideName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetRideName00
static int tolua_engineWin32_Nuclear_ISprite_SetRideName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRideName'", NULL);
#endif
  {
   self->SetRideName(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRideName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMinMaxEffectAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetMinMaxEffectAlpha00
static int tolua_engineWin32_Nuclear_ISprite_SetMinMaxEffectAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  float minalpha = ((float)  tolua_tonumber(tolua_S,2,0));
  float maxalpha = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMinMaxEffectAlpha'", NULL);
#endif
  {
   self->SetMinMaxEffectAlpha(minalpha,maxalpha);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMinMaxEffectAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMinEffectAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetMinEffectAlpha00
static int tolua_engineWin32_Nuclear_ISprite_GetMinEffectAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMinEffectAlpha'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetMinEffectAlpha();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMinEffectAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaxEffectAlpha of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetMaxEffectAlpha00
static int tolua_engineWin32_Nuclear_ISprite_GetMaxEffectAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaxEffectAlpha'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetMaxEffectAlpha();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxEffectAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PrefetchAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_PrefetchAction00
static int tolua_engineWin32_Nuclear_ISprite_PrefetchAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PrefetchAction'", NULL);
#endif
  {
   Nuclear::NuclearPrefetchResult tolua_ret = (Nuclear::NuclearPrefetchResult)  self->PrefetchAction(action_name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PrefetchAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: HoldAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_HoldAction00
static int tolua_engineWin32_Nuclear_ISprite_HoldAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HoldAction'", NULL);
#endif
  {
   self->HoldAction(action_name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HoldAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_ReleaseAction00
static int tolua_engineWin32_Nuclear_ISprite_ReleaseAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseAction'", NULL);
#endif
  {
   self->ReleaseAction(action_name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetHoldLastFrame of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetHoldLastFrame00
static int tolua_engineWin32_Nuclear_ISprite_SetHoldLastFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool bHoldLastFrame = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetHoldLastFrame'", NULL);
#endif
  {
   self->SetHoldLastFrame(bHoldLastFrame);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetHoldLastFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDefaultAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDefaultAction00
static int tolua_engineWin32_Nuclear_ISprite_SetDefaultAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::XPSPRITE_ACTION_LOAD_TYPE type = ((Nuclear::XPSPRITE_ACTION_LOAD_TYPE) (int)  tolua_tonumber(tolua_S,3,0));
  float fScaleForTotalTime = ((float)  tolua_tonumber(tolua_S,4,0));
  bool bHoldLastFrame = ((bool)  tolua_toboolean(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDefaultAction'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetDefaultAction(action_name,type,fScaleForTotalTime,bHoldLastFrame);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDefaultAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDefaultAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetDefaultAction00
static int tolua_engineWin32_Nuclear_ISprite_GetDefaultAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDefaultAction'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetDefaultAction();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDefaultAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayAction of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_PlayAction00
static int tolua_engineWin32_Nuclear_ISprite_PlayAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  Nuclear::XPSPRITE_ACTION_LOAD_TYPE type = ((Nuclear::XPSPRITE_ACTION_LOAD_TYPE) (int)  tolua_tonumber(tolua_S,3,0));
  float fScaleForTotalTime = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayAction'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PlayAction(action_name,type,fScaleForTotalTime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurActionName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetCurActionName00
static int tolua_engineWin32_Nuclear_ISprite_GetCurActionName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurActionName'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetCurActionName();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurActionName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionTimeByName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetActionTimeByName00
static int tolua_engineWin32_Nuclear_ISprite_GetActionTimeByName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  float time = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionTimeByName'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetActionTimeByName(action_name,time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
   tolua_pushnumber(tolua_S,(lua_Number)time);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionTimeByName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurrentFrame of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetCurrentFrame00
static int tolua_engineWin32_Nuclear_ISprite_GetCurrentFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurrentFrame'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetCurrentFrame();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurrentFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTotalFrame of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTotalFrame00
static int tolua_engineWin32_Nuclear_ISprite_GetTotalFrame00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTotalFrame'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTotalFrame();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTotalFrame'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBindFile of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetBindFile00
static int tolua_engineWin32_Nuclear_ISprite_SetBindFile00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int id = ((int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring bindFile = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBindFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetBindFile(id,bindFile);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)bindFile);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBindFile'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBindFile of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetBindFile00
static int tolua_engineWin32_Nuclear_ISprite_GetBindFile00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int id = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBindFile'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetBindFile(id);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBindFile'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDurativeEffect of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDurativeEffect00
static int tolua_engineWin32_Nuclear_ISprite_SetDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDurativeEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetDurativeEffect(effect_name,*relpos,flag);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetContinueEffect of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetContinueEffect00
static int tolua_engineWin32_Nuclear_ISprite_SetContinueEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring headEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring midEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const std::wstring endEffect = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  int continueTime = ((int)  tolua_tonumber(tolua_S,5,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,6,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetContinueEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetContinueEffect(headEffect,midEffect,endEffect,continueTime,*relpos,flag);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)headEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)midEffect);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)endEffect);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetContinueEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveDurativeEffect of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_RemoveDurativeEffect00
static int tolua_engineWin32_Nuclear_ISprite_RemoveDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveDurativeEffect'", NULL);
#endif
  {
   self->RemoveDurativeEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ChangeEffectOffset of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_ChangeEffectOffset00
static int tolua_engineWin32_Nuclear_ISprite_ChangeEffectOffset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ChangeEffectOffset'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ChangeEffectOffset(pEffect,*relpos);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ChangeEffectOffset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEffect of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_PlayEffect00
static int tolua_engineWin32_Nuclear_ISprite_PlayEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  int dx = ((int)  tolua_tonumber(tolua_S,3,0));
  int dy = ((int)  tolua_tonumber(tolua_S,4,0));
  int times = ((int)  tolua_tonumber(tolua_S,5,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,6,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,7,0));
  int TimeMode = ((int)  tolua_tonumber(tolua_S,8,0));
  int iRot = ((int)  tolua_tonumber(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEffect(effect_name,dx,dy,times,flag,soundtype,TimeMode,iRot);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEffect of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_PlayEffect01
static int tolua_engineWin32_Nuclear_ISprite_PlayEffect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  int times = ((int)  tolua_tonumber(tolua_S,4,0));
  const std::wstring hostname = ((const std::wstring)  tolua_tocppwstring(tolua_S,5,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEffect(effect_name,*relpos,times,hostname,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)hostname);
  }
 }
 return 3;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ISprite_PlayEffect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableShadow of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_EnableShadow00
static int tolua_engineWin32_Nuclear_ISprite_EnableShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableShadow'", NULL);
#endif
  {
   self->EnableShadow(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableShadow of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsEnableShadow00
static int tolua_engineWin32_Nuclear_ISprite_IsEnableShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableShadow'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableShadow();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TeleportWithBlur of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_TeleportWithBlur00
static int tolua_engineWin32_Nuclear_ISprite_TeleportWithBlur00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* point = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int telTime = ((int)  tolua_tonumber(tolua_S,3,0));
  int blurTime = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TeleportWithBlur'", NULL);
#endif
  {
   self->TeleportWithBlur(*point,telTime,blurTime);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TeleportWithBlur'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTurnDir of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetTurnDir00
static int tolua_engineWin32_Nuclear_ISprite_SetTurnDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int iDir = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTurnDir'", NULL);
#endif
  {
   self->SetTurnDir(iDir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTurnDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTurnDir of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetTurnDir00
static int tolua_engineWin32_Nuclear_ISprite_GetTurnDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTurnDir'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTurnDir();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTurnDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetHighlight of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetHighlight00
static int tolua_engineWin32_Nuclear_ISprite_SetHighlight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetHighlight'", NULL);
#endif
  {
   self->SetHighlight(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetHighlight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsHighlight of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsHighlight00
static int tolua_engineWin32_Nuclear_ISprite_IsHighlight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsHighlight'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsHighlight();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsHighlight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMouseTestMode of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetMouseTestMode00
static int tolua_engineWin32_Nuclear_ISprite_SetMouseTestMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Nuclear_Mouse_TestMode m = ((Nuclear::Nuclear_Mouse_TestMode) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMouseTestMode'", NULL);
#endif
  {
   self->SetMouseTestMode(m);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMouseTestMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMouseTestMode of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetMouseTestMode00
static int tolua_engineWin32_Nuclear_ISprite_GetMouseTestMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMouseTestMode'", NULL);
#endif
  {
   Nuclear::Nuclear_Mouse_TestMode tolua_ret = (Nuclear::Nuclear_Mouse_TestMode)  self->GetMouseTestMode();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMouseTestMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetActionSoundPriority of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetActionSoundPriority00
static int tolua_engineWin32_Nuclear_ISprite_SetActionSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  short priority = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetActionSoundPriority'", NULL);
#endif
  {
   self->SetActionSoundPriority(priority);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetActionSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionSoundPriority of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetActionSoundPriority00
static int tolua_engineWin32_Nuclear_ISprite_GetActionSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionSoundPriority'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetActionSoundPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMoveSpeed of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetMoveSpeed00
static int tolua_engineWin32_Nuclear_ISprite_SetMoveSpeed00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  float speed = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMoveSpeed'", NULL);
#endif
  {
   self->SetMoveSpeed(speed);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMoveSpeed'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMoveSpeed of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetMoveSpeed00
static int tolua_engineWin32_Nuclear_ISprite_GetMoveSpeed00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMoveSpeed'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetMoveSpeed();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMoveSpeed'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: StopMove of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_StopMove00
static int tolua_engineWin32_Nuclear_ISprite_StopMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'StopMove'", NULL);
#endif
  {
   self->StopMove();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StopMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMoving of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsMoving00
static int tolua_engineWin32_Nuclear_ISprite_IsMoving00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMoving'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMoving();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMoving'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMoveSuspended of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetMoveSuspended00
static int tolua_engineWin32_Nuclear_ISprite_SetMoveSuspended00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool moveSuspended = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMoveSuspended'", NULL);
#endif
  {
   self->SetMoveSuspended(moveSuspended);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMoveSuspended'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMoveSuspended of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsMoveSuspended00
static int tolua_engineWin32_Nuclear_ISprite_IsMoveSuspended00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMoveSuspended'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMoveSuspended();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMoveSuspended'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: MoveTo of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_MoveTo00
static int tolua_engineWin32_Nuclear_ISprite_MoveTo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,5,"const Nuclear::CSIZE",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,6,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int targetX = ((int)  tolua_tonumber(tolua_S,2,0));
  int targetY = ((int)  tolua_tonumber(tolua_S,3,0));
  int range = ((int)  tolua_tonumber(tolua_S,4,0));
  const Nuclear::CSIZE* size = ((const Nuclear::CSIZE*)  tolua_tousertype(tolua_S,5,0));
  bool straight = ((bool)  tolua_toboolean(tolua_S,6,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'MoveTo'", NULL);
#endif
  {
   self->MoveTo(targetX,targetY,range,size,straight);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MoveTo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: MoveTo of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_MoveTo01
static int tolua_engineWin32_Nuclear_ISprite_MoveTo01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"const Nuclear::CSIZE",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* target = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int range = ((int)  tolua_tonumber(tolua_S,3,0));
  const Nuclear::CSIZE* size = ((const Nuclear::CSIZE*)  tolua_tousertype(tolua_S,4,0));
  bool straight = ((bool)  tolua_toboolean(tolua_S,5,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'MoveTo'", NULL);
#endif
  {
   self->MoveTo(*target,range,size,straight);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ISprite_MoveTo00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: StartShake of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_StartShake00
static int tolua_engineWin32_Nuclear_ISprite_StartShake00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'StartShake'", NULL);
#endif
  {
   self->StartShake();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StartShake'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: StopShake of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_StopShake00
static int tolua_engineWin32_Nuclear_ISprite_StopShake00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'StopShake'", NULL);
#endif
  {
   self->StopShake();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StopShake'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCurveMove of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetCurveMove00
static int tolua_engineWin32_Nuclear_ISprite_SetCurveMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCurveMove'", NULL);
#endif
  {
   self->SetCurveMove(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCurveMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: KeepMoveTrail of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_KeepMoveTrail00
static int tolua_engineWin32_Nuclear_ISprite_KeepMoveTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  bool keep = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'KeepMoveTrail'", NULL);
#endif
  {
   self->KeepMoveTrail(keep);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'KeepMoveTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsKeepMoveTrail of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsKeepMoveTrail00
static int tolua_engineWin32_Nuclear_ISprite_IsKeepMoveTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsKeepMoveTrail'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsKeepMoveTrail();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsKeepMoveTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMoveMask of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetMoveMask00
static int tolua_engineWin32_Nuclear_ISprite_SetMoveMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  unsigned int mask = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMoveMask'", NULL);
#endif
  {
   self->SetMoveMask(mask);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMoveMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicLocation of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetLogicLocation00
static int tolua_engineWin32_Nuclear_ISprite_GetLogicLocation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::ISprite* self = (const Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicLocation'", NULL);
#endif
  {
    Nuclear::NuclearPoint tolua_ret = (  Nuclear::NuclearPoint)  self->GetLogicLocation();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPoint)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPoint));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPoint");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicLocation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDirection01
static int tolua_engineWin32_Nuclear_ISprite_SetDirection01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int targetx = ((int)  tolua_tonumber(tolua_S,2,0));
  int targety = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(targetx,targety);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ISprite_SetDirection00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDirection of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDirection02
static int tolua_engineWin32_Nuclear_ISprite_SetDirection02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* target = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDirection'", NULL);
#endif
  {
   self->SetDirection(*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_ISprite_SetDirection01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: InAttackRange of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_InAttackRange00
static int tolua_engineWin32_Nuclear_ISprite_InAttackRange00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* target = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  int range = ((int)  tolua_tonumber(tolua_S,3,0));
  unsigned int mask = ((unsigned int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'InAttackRange'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->InAttackRange(*target,range,mask);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InAttackRange'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetComponentAniReleaseFlag of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetComponentAniReleaseFlag00
static int tolua_engineWin32_Nuclear_ISprite_SetComponentAniReleaseFlag00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPaniReleaseFlag flag = ((Nuclear::NuclearPaniReleaseFlag) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetComponentAniReleaseFlag'", NULL);
#endif
  {
   self->SetComponentAniReleaseFlag(flag);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetComponentAniReleaseFlag'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerCount of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetLayerCount00
static int tolua_engineWin32_Nuclear_ISprite_GetLayerCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLayerCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerIndexByName of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetLayerIndexByName00
static int tolua_engineWin32_Nuclear_ISprite_GetLayerIndexByName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  std::wstring wsName = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerIndexByName'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLayerIndexByName(wsName);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerIndexByName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLayerNameByIndex of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetLayerNameByIndex00
static int tolua_engineWin32_Nuclear_ISprite_GetLayerNameByIndex00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int iIndex = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLayerNameByIndex'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetLayerNameByIndex(iIndex);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLayerNameByIndex'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsPartLayer of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_IsPartLayer00
static int tolua_engineWin32_Nuclear_ISprite_IsPartLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int iIndex = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsPartLayer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsPartLayer(iIndex);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsPartLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDyePartIndex of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_SetDyePartIndex00
static int tolua_engineWin32_Nuclear_ISprite_SetDyePartIndex00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int part = ((int)  tolua_tonumber(tolua_S,2,0));
  int index = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDyePartIndex'", NULL);
#endif
  {
   self->SetDyePartIndex(part,index);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDyePartIndex'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDyeEnable of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetDyeEnable00
static int tolua_engineWin32_Nuclear_ISprite_GetDyeEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDyeEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetDyeEnable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDyeEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDyePartCount of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetDyePartCount00
static int tolua_engineWin32_Nuclear_ISprite_GetDyePartCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDyePartCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetDyePartCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDyePartCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDyeProjCount of class  Nuclear::ISprite */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_ISprite_GetDyeProjCount00
static int tolua_engineWin32_Nuclear_ISprite_GetDyeProjCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::ISprite",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::ISprite* self = (Nuclear::ISprite*)  tolua_tousertype(tolua_S,1,0);
  int part = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDyeProjCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetDyeProjCount(part);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDyeProjCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::GUObject */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GUObject_new00
static int tolua_engineWin32_Nuclear_GUObject_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::GUObject",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::GUObject* tolua_ret = (Nuclear::GUObject*)  Mtolua_new((Nuclear::GUObject)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::GUObject");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::GUObject */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GUObject_new00_local
static int tolua_engineWin32_Nuclear_GUObject_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::GUObject",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::GUObject* tolua_ret = (Nuclear::GUObject*)  Mtolua_new((Nuclear::GUObject)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::GUObject");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGUID of class  Nuclear::GUObject */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GUObject_GetGUID00
static int tolua_engineWin32_Nuclear_GUObject_GetGUID00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::GUObject",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::GUObject* self = (Nuclear::GUObject*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGUID'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetGUID();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGUID'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::GUObject */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GUObject_delete00
static int tolua_engineWin32_Nuclear_GUObject_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::GUObject",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::GUObject* self = (Nuclear::GUObject*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderMid of class  Nuclear::Renderable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderable_RenderMid00
static int tolua_engineWin32_Nuclear_Renderable_RenderMid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderable",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* self = (Nuclear::Renderable*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Canvas* canvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,2,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderMid'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->RenderMid(canvas,realRender);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderMid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::Renderable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderable_Render00
static int tolua_engineWin32_Nuclear_Renderable_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderable",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* self = (Nuclear::Renderable*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Canvas* canvas = ((Nuclear::Canvas*)  tolua_tousertype(tolua_S,2,0));
  bool realRender = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Render(canvas,realRender);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderBeforeMid of class  Nuclear::Renderable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderable_RenderBeforeMid00
static int tolua_engineWin32_Nuclear_Renderable_RenderBeforeMid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderable",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* self = (Nuclear::Renderable*)  tolua_tousertype(tolua_S,1,0);
  bool realRender = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderBeforeMid'", NULL);
#endif
  {
   self->RenderBeforeMid(realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderBeforeMid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RenderSpriteOnly of class  Nuclear::Renderable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderable_RenderSpriteOnly00
static int tolua_engineWin32_Nuclear_Renderable_RenderSpriteOnly00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderable",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* self = (Nuclear::Renderable*)  tolua_tousertype(tolua_S,1,0);
  bool realRender = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderSpriteOnly'", NULL);
#endif
  {
   self->RenderSpriteOnly(realRender);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderSpriteOnly'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::Renderable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderable_delete00
static int tolua_engineWin32_Nuclear_Renderable_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* self = (Nuclear::Renderable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pr of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawElement_m_pr_ptr
static int tolua_get_Nuclear__DrawElement_m_pr_ptr(lua_State* tolua_S)
{
  Nuclear::DrawElement* self = (Nuclear::DrawElement*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pr'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->m_pr,"Nuclear::Renderable");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pr of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawElement_m_pr_ptr
static int tolua_set_Nuclear__DrawElement_m_pr_ptr(lua_State* tolua_S)
{
  Nuclear::DrawElement* self = (Nuclear::DrawElement*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pr'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Nuclear::Renderable",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pr = ((Nuclear::Renderable*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pos of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawElement_m_pos
static int tolua_get_Nuclear__DrawElement_m_pos(lua_State* tolua_S)
{
  Nuclear::DrawElement* self = (Nuclear::DrawElement*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pos'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->m_pos,"Nuclear::NuclearRect");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pos of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawElement_m_pos
static int tolua_set_Nuclear__DrawElement_m_pos(lua_State* tolua_S)
{
  Nuclear::DrawElement* self = (Nuclear::DrawElement*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pos'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearRect",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pos = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawElement_new00
static int tolua_engineWin32_Nuclear_DrawElement_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawElement",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderable",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* pr = ((Nuclear::Renderable*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect pos = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::DrawElement* tolua_ret = (Nuclear::DrawElement*)  Mtolua_new((Nuclear::DrawElement)(pr,pos));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawElement");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::DrawElement */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawElement_new00_local
static int tolua_engineWin32_Nuclear_DrawElement_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawElement",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderable",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderable* pr = ((Nuclear::Renderable*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect pos = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::DrawElement* tolua_ret = (Nuclear::DrawElement*)  Mtolua_new((Nuclear::DrawElement)(pr,pos));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawElement");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Draw of class  Nuclear::Canvas */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Canvas_Draw00
static int tolua_engineWin32_Nuclear_Canvas_Draw00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::Renderable",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearRect",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Canvas* self = (Nuclear::Canvas*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::Renderable* pr = ((Nuclear::Renderable*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearRect pos = *((Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Draw'", NULL);
#endif
  {
   self->Draw(pr,pos);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Draw'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Clear of class  Nuclear::Canvas */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Canvas_Clear00
static int tolua_engineWin32_Nuclear_Canvas_Clear00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Canvas",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Canvas* self = (Nuclear::Canvas*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Clear'", NULL);
#endif
  {
   self->Clear();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Clear'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: szWindowTitle of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_szWindowTitle_ptr
static int tolua_get_Nuclear__EngineParameter_szWindowTitle_ptr(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'szWindowTitle'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->szWindowTitle,"wchar_t");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: szWindowTitle of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_szWindowTitle_ptr
static int tolua_set_Nuclear__EngineParameter_szWindowTitle_ptr(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'szWindowTitle'",NULL);
  if (!tolua_isusertype(tolua_S,2,"wchar_t",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->szWindowTitle = ((wchar_t*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: szClassName of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_szClassName_ptr
static int tolua_get_Nuclear__EngineParameter_szClassName_ptr(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'szClassName'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->szClassName,"wchar_t");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: szClassName of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_szClassName_ptr
static int tolua_set_Nuclear__EngineParameter_szClassName_ptr(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'szClassName'",NULL);
  if (!tolua_isusertype(tolua_S,2,"wchar_t",0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->szClassName = ((wchar_t*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: dmode of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_dmode
static int tolua_get_Nuclear__EngineParameter_dmode(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dmode'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->dmode,"Nuclear::NuclearDisplayMode");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: dmode of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_dmode
static int tolua_set_Nuclear__EngineParameter_dmode(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dmode'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearDisplayMode",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->dmode = *((Nuclear::NuclearDisplayMode*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bAsyncRead of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_bAsyncRead
static int tolua_get_Nuclear__EngineParameter_bAsyncRead(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bAsyncRead'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bAsyncRead);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bAsyncRead of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_bAsyncRead
static int tolua_set_Nuclear__EngineParameter_bAsyncRead(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bAsyncRead'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bAsyncRead = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bApplictionInBuild of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_bApplictionInBuild
static int tolua_get_Nuclear__EngineParameter_bApplictionInBuild(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bApplictionInBuild'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bApplictionInBuild);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bApplictionInBuild of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_bApplictionInBuild
static int tolua_set_Nuclear__EngineParameter_bApplictionInBuild(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bApplictionInBuild'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bApplictionInBuild = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bHasMaximizbox of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_bHasMaximizbox
static int tolua_get_Nuclear__EngineParameter_bHasMaximizbox(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bHasMaximizbox'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bHasMaximizbox);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bHasMaximizbox of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_bHasMaximizbox
static int tolua_set_Nuclear__EngineParameter_bHasMaximizbox(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bHasMaximizbox'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bHasMaximizbox = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bSizeBox of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_bSizeBox
static int tolua_get_Nuclear__EngineParameter_bSizeBox(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSizeBox'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bSizeBox);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bSizeBox of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_bSizeBox
static int tolua_set_Nuclear__EngineParameter_bSizeBox(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSizeBox'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bSizeBox = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bEnableMipMap of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_bEnableMipMap
static int tolua_get_Nuclear__EngineParameter_bEnableMipMap(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bEnableMipMap'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bEnableMipMap);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bEnableMipMap of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_bEnableMipMap
static int tolua_set_Nuclear__EngineParameter_bEnableMipMap(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bEnableMipMap'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bEnableMipMap = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: dwRenderFlags of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_dwRenderFlags
static int tolua_get_Nuclear__EngineParameter_dwRenderFlags(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dwRenderFlags'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->dwRenderFlags);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: dwRenderFlags of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_dwRenderFlags
static int tolua_set_Nuclear__EngineParameter_dwRenderFlags(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'dwRenderFlags'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->dwRenderFlags = ((DWORD)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: multiSampleType of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_multiSampleType
static int tolua_get_Nuclear__EngineParameter_multiSampleType(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'multiSampleType'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->multiSampleType);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: multiSampleType of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_multiSampleType
static int tolua_set_Nuclear__EngineParameter_multiSampleType(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'multiSampleType'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->multiSampleType = ((Nuclear::NuclearMultiSampleType) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: nAppInitStepCount of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__EngineParameter_nAppInitStepCount
static int tolua_get_Nuclear__EngineParameter_nAppInitStepCount(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nAppInitStepCount'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->nAppInitStepCount);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: nAppInitStepCount of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__EngineParameter_nAppInitStepCount
static int tolua_set_Nuclear__EngineParameter_nAppInitStepCount(lua_State* tolua_S)
{
  Nuclear::EngineParameter* self = (Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nAppInitStepCount'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->nAppInitStepCount = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineParameter_new00
static int tolua_engineWin32_Nuclear_EngineParameter_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::EngineParameter",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::EngineParameter* tolua_ret = (Nuclear::EngineParameter*)  Mtolua_new((Nuclear::EngineParameter)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EngineParameter");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::EngineParameter */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineParameter_new00_local
static int tolua_engineWin32_Nuclear_EngineParameter_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::EngineParameter",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::EngineParameter* tolua_ret = (Nuclear::EngineParameter*)  Mtolua_new((Nuclear::EngineParameter)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EngineParameter");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_delete00
static int tolua_engineWin32_Nuclear_IEngine_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScreenWidth of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetScreenWidth00
static int tolua_engineWin32_Nuclear_IEngine_GetScreenWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScreenWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetScreenWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScreenWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScreenHeight of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetScreenHeight00
static int tolua_engineWin32_Nuclear_IEngine_GetScreenHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScreenHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetScreenHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScreenHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineLayer of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineLayer00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"cocos2d::CCLayer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  cocos2d::CCLayer* aPLayer = ((cocos2d::CCLayer*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineLayer'", NULL);
#endif
  {
   self->SetEngineLayer(aPLayer);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEngineLayer of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetEngineLayer00
static int tolua_engineWin32_Nuclear_IEngine_GetEngineLayer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEngineLayer'", NULL);
#endif
  {
   cocos2d::CCLayer* tolua_ret = (cocos2d::CCLayer*)  self->GetEngineLayer();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"cocos2d::CCLayer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngineLayer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetInfoLogPath of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetInfoLogPath00
static int tolua_engineWin32_Nuclear_IEngine_SetInfoLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetInfoLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetInfoLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetInfoLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetErrorLogPath of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetErrorLogPath00
static int tolua_engineWin32_Nuclear_IEngine_SetErrorLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetErrorLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetErrorLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetErrorLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSegmpakLogPath of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetSegmpakLogPath00
static int tolua_engineWin32_Nuclear_IEngine_SetSegmpakLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSegmpakLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSegmpakLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSegmpakLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Run of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_Run00
static int tolua_engineWin32_Nuclear_IEngine_Run00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::EngineParameter",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::EngineParameter* ep = ((const Nuclear::EngineParameter*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Run'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Run(*ep);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Run'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Exit of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_Exit00
static int tolua_engineWin32_Nuclear_IEngine_Exit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Exit'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Exit();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Exit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnIdle of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_OnIdle00
static int tolua_engineWin32_Nuclear_IEngine_OnIdle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnIdle'", NULL);
#endif
  {
   self->OnIdle();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnIdle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTimeSpeedScale of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetGameTimeSpeedScale00
static int tolua_engineWin32_Nuclear_IEngine_SetGameTimeSpeedScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  float fScale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTimeSpeedScale'", NULL);
#endif
  {
   self->SetGameTimeSpeedScale(fScale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTimeSpeedScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGameTimeSpeedScale of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetGameTimeSpeedScale00
static int tolua_engineWin32_Nuclear_IEngine_GetGameTimeSpeedScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGameTimeSpeedScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetGameTimeSpeedScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGameTimeSpeedScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PutTask of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_PutTask00
static int tolua_engineWin32_Nuclear_IEngine_PutTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearRunnable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearRunnable* task = ((Nuclear::INuclearRunnable*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PutTask'", NULL);
#endif
  {
   self->PutTask(task);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PutTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ScheduleTimer of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_ScheduleTimer00
static int tolua_engineWin32_Nuclear_IEngine_ScheduleTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
  int period = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ScheduleTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ScheduleTimer(timer,period);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ScheduleTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CancelTimer of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_CancelTimer00
static int tolua_engineWin32_Nuclear_IEngine_CancelTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CancelTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CancelTimer(timer);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CancelTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorld of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetWorld00
static int tolua_engineWin32_Nuclear_IEngine_GetWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorld'", NULL);
#endif
  {
   Nuclear::IWorld* tolua_ret = (Nuclear::IWorld*)  self->GetWorld();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IWorld");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEnv of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetEnv00
static int tolua_engineWin32_Nuclear_IEngine_GetEnv00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEnv'", NULL);
#endif
  {
   Nuclear::IEnv* tolua_ret = (Nuclear::IEnv*)  self->GetEnv();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEnv");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEnv'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetApp of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetApp00
static int tolua_engineWin32_Nuclear_IEngine_GetApp00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetApp'", NULL);
#endif
  {
   Nuclear::IApp* tolua_ret = (Nuclear::IApp*)  self->GetApp();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IApp");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetApp'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderer of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetRenderer00
static int tolua_engineWin32_Nuclear_IEngine_GetRenderer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderer'", NULL);
#endif
  {
   Nuclear::Renderer* tolua_ret = (Nuclear::Renderer*)  self->GetRenderer();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Renderer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRenderer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIO of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetFileIO00
static int tolua_engineWin32_Nuclear_IEngine_GetFileIO00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIO'", NULL);
#endif
  {
   Nuclear::INuclearFileIO* tolua_ret = (Nuclear::INuclearFileIO*)  self->GetFileIO();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearFileIO");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIO'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateEngineSprite of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_CreateEngineSprite00
static int tolua_engineWin32_Nuclear_IEngine_CreateEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,3,0));
  bool isUISprite = ((bool)  tolua_toboolean(tolua_S,4,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateEngineSprite'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->CreateEngineSprite(modelname,async,isUISprite);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteModel of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteModel00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteModel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteModel'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetEngineSpriteModel(handle,modelname,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteModel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEngineSprite of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_ReleaseEngineSprite00
static int tolua_engineWin32_Nuclear_IEngine_ReleaseEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEngineSprite'", NULL);
#endif
  {
   self->ReleaseEngineSprite(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RendererEngineSprite of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_RendererEngineSprite00
static int tolua_engineWin32_Nuclear_IEngine_RendererEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RendererEngineSprite'", NULL);
#endif
  {
   self->RendererEngineSprite(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RendererEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteLoc of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteLoc00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteLoc00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteLoc'", NULL);
#endif
  {
   self->SetEngineSpriteLoc(handle,*loc);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteLoc'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDirection of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearDirection dir = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDirection'", NULL);
#endif
  {
   self->SetEngineSpriteDirection(handle,dir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDirection of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection01
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearPoint* target = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDirection'", NULL);
#endif
  {
   self->SetEngineSpriteDirection(handle,*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDefaultAction of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDefaultAction00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDefaultAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring actname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDefaultAction'", NULL);
#endif
  {
   self->SetEngineSpriteDefaultAction(handle,actname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDefaultAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteAction of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAction00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring actname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteAction'", NULL);
#endif
  {
   self->SetEngineSpriteAction(handle,actname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteComponent of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteComponent00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteComponent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  int scid = ((int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring resource = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteComponent'", NULL);
#endif
  {
   self->SetEngineSpriteComponent(handle,scid,resource,color);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)resource);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteComponent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableEngineSpriteShadow of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_EnableEngineSpriteShadow00
static int tolua_engineWin32_Nuclear_IEngine_EnableEngineSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  bool b = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableEngineSpriteShadow'", NULL);
#endif
  {
   self->EnableEngineSpriteShadow(handle,b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableEngineSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteScale of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteScale00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  float scale = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteScale'", NULL);
#endif
  {
   self->SetEngineSpriteScale(handle,scale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteAlpha of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAlpha00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  unsigned char alpha = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteAlpha'", NULL);
#endif
  {
   self->SetEngineSpriteAlpha(handle,alpha);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEngineSpriteActionTimeByName of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteActionTimeByName00
static int tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteActionTimeByName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  float time = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEngineSpriteActionTimeByName'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetEngineSpriteActionTimeByName(handle,action_name,time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
   tolua_pushnumber(tolua_S,(lua_Number)time);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngineSpriteActionTimeByName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDurativeEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDurativeEffect00
static int tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDurativeEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetEngineSpriteDurativeEffect(handle,effect_name,*relpos,flag);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEngineSpriteEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_PlayEngineSpriteEffect00
static int tolua_engineWin32_Nuclear_IEngine_PlayEngineSpriteEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int dx = ((int)  tolua_tonumber(tolua_S,4,0));
  int dy = ((int)  tolua_tonumber(tolua_S,5,0));
  int times = ((int)  tolua_tonumber(tolua_S,6,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,7,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEngineSpriteEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEngineSpriteEffect(handle,effect_name,dx,dy,times,flag,soundtype);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayEngineSpriteEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEngineSpriteDurativeEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_RemoveEngineSpriteDurativeEffect00
static int tolua_engineWin32_Nuclear_IEngine_RemoveEngineSpriteDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEngineSpriteDurativeEffect'", NULL);
#endif
  {
   self->RemoveEngineSpriteDurativeEffect(handle,pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEngineSpriteDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEngineSpriteBubbleItemOffset of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteBubbleItemOffset00
static int tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteBubbleItemOffset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEngineSpriteBubbleItemOffset'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetEngineSpriteBubbleItemOffset(handle);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngineSpriteBubbleItemOffset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableParticle of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_EnableParticle00
static int tolua_engineWin32_Nuclear_IEngine_EnableParticle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  bool flag = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableParticle'", NULL);
#endif
  {
   self->EnableParticle(flag);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableParticle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_CreateEffect00
static int tolua_engineWin32_Nuclear_IEngine_CreateEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring effectname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,3,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->CreateEffect(effectname,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effectname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_DrawEffect00
static int tolua_engineWin32_Nuclear_IEngine_DrawEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEffect'", NULL);
#endif
  {
   self->DrawEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_ReleaseEffect00
static int tolua_engineWin32_Nuclear_IEngine_ReleaseEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEffect'", NULL);
#endif
  {
   self->ReleaseEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: HoldEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_HoldEffect00
static int tolua_engineWin32_Nuclear_IEngine_HoldEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HoldEffect'", NULL);
#endif
  {
   self->HoldEffect(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HoldEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEffect of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_ReleaseEffect01
static int tolua_engineWin32_Nuclear_IEngine_ReleaseEffect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEffect'", NULL);
#endif
  {
   self->ReleaseEffect(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEngine_ReleaseEffect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: CaptureWorld of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_CaptureWorld00
static int tolua_engineWin32_Nuclear_IEngine_CaptureWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CaptureWorld'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->CaptureWorld();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CaptureWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCleanColor of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetCleanColor00
static int tolua_engineWin32_Nuclear_IEngine_SetCleanColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCleanColor'", NULL);
#endif
  {
   self->SetCleanColor(color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCleanColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWindowState of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetWindowState00
static int tolua_engineWin32_Nuclear_IEngine_GetWindowState00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWindowState'", NULL);
#endif
  {
   Nuclear::NuclearWindowState tolua_ret = (Nuclear::NuclearWindowState)  self->GetWindowState();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowState'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GCNow of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GCNow00
static int tolua_engineWin32_Nuclear_IEngine_GCNow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GCNow'", NULL);
#endif
  {
   self->GCNow();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GCNow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: setGCCooldown of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_setGCCooldown00
static int tolua_engineWin32_Nuclear_IEngine_setGCCooldown00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setGCCooldown'", NULL);
#endif
  {
   self->setGCCooldown(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'setGCCooldown'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ResetFPSCounter of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_ResetFPSCounter00
static int tolua_engineWin32_Nuclear_IEngine_ResetFPSCounter00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ResetFPSCounter'", NULL);
#endif
  {
   self->ResetFPSCounter();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ResetFPSCounter'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFPS of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetFPS00
static int tolua_engineWin32_Nuclear_IEngine_GetFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFPS'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetFPS();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLatestFPS of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetLatestFPS00
static int tolua_engineWin32_Nuclear_IEngine_GetLatestFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLatestFPS'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetLatestFPS();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLatestFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicWidth of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetLogicWidth00
static int tolua_engineWin32_Nuclear_IEngine_GetLogicWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicHeight of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetLogicHeight00
static int tolua_engineWin32_Nuclear_IEngine_GetLogicHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWidth of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetWidth00
static int tolua_engineWin32_Nuclear_IEngine_GetWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetHeight of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetHeight00
static int tolua_engineWin32_Nuclear_IEngine_GetHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTimeCount of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetTimeCount00
static int tolua_engineWin32_Nuclear_IEngine_GetTimeCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTimeCount'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetTimeCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTimeCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurMemSize of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetCurMemSize00
static int tolua_engineWin32_Nuclear_IEngine_GetCurMemSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurMemSize'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetCurMemSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurMemSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GeCurAvailableMemSize of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GeCurAvailableMemSize00
static int tolua_engineWin32_Nuclear_IEngine_GeCurAvailableMemSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GeCurAvailableMemSize'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GeCurAvailableMemSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GeCurAvailableMemSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepLoadTexture of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetStepLoadTexture00
static int tolua_engineWin32_Nuclear_IEngine_SetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepLoadTexture'", NULL);
#endif
  {
   self->SetStepLoadTexture(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepLoadTexture of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetStepLoadTexture00
static int tolua_engineWin32_Nuclear_IEngine_GetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEngine* self = (const Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepLoadTexture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetStepLoadTexture();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLimitFireThreadSecond of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_SetLimitFireThreadSecond00
static int tolua_engineWin32_Nuclear_IEngine_SetLimitFireThreadSecond00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
  int limitFireThreadCount = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLimitFireThreadSecond'", NULL);
#endif
  {
   self->SetLimitFireThreadSecond(limitFireThreadCount);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLimitFireThreadSecond'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLimitFireThreadSecond of class  Nuclear::IEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEngine_GetLimitFireThreadSecond00
static int tolua_engineWin32_Nuclear_IEngine_GetLimitFireThreadSecond00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEngine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEngine* self = (Nuclear::IEngine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLimitFireThreadSecond'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLimitFireThreadSecond();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLimitFireThreadSecond'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::GetEngine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GetEngine00
static int tolua_engineWin32_Nuclear_GetEngine00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnoobj(tolua_S,1,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::IEngine* tolua_ret = (Nuclear::IEngine*)  Nuclear::GetEngine();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEngine");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngine'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteManager of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetSpriteManager00
static int tolua_engineWin32_Nuclear_EngineBase_GetSpriteManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteManager'", NULL);
#endif
  {
   Nuclear::SpriteManager* tolua_ret = (Nuclear::SpriteManager*)  self->GetSpriteManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniManager of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetAniManager00
static int tolua_engineWin32_Nuclear_EngineBase_GetAniManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniManager'", NULL);
#endif
  {
   Nuclear::AniManager* tolua_ret = (Nuclear::AniManager*)  self->GetAniManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::AniManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetXPWorld of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetXPWorld00
static int tolua_engineWin32_Nuclear_EngineBase_GetXPWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetXPWorld'", NULL);
#endif
  {
   Nuclear::World* tolua_ret = (Nuclear::World*)  self->GetXPWorld();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::World");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetXPWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorldScale of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetWorldScale00
static int tolua_engineWin32_Nuclear_EngineBase_GetWorldScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorldScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetWorldScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorldScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectManager of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetEffectManager00
static int tolua_engineWin32_Nuclear_EngineBase_GetEffectManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectManager'", NULL);
#endif
  {
   Nuclear::EffectManager* tolua_ret = (Nuclear::EffectManager*)  self->GetEffectManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EffectManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderer of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetRenderer00
static int tolua_engineWin32_Nuclear_EngineBase_GetRenderer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderer'", NULL);
#endif
  {
   Nuclear::Renderer* tolua_ret = (Nuclear::Renderer*)  self->GetRenderer();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Renderer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRenderer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpritePictureHandle of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetSpritePictureHandle00
static int tolua_engineWin32_Nuclear_EngineBase_GetSpritePictureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpritePictureHandle'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetSpritePictureHandle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpritePictureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetConfigManager of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetConfigManager00
static int tolua_engineWin32_Nuclear_EngineBase_GetConfigManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetConfigManager'", NULL);
#endif
  {
   Nuclear::ConfigManager* tolua_ret = (Nuclear::ConfigManager*)  self->GetConfigManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ConfigManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetConfigManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetViewport of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetViewport00
static int tolua_engineWin32_Nuclear_EngineBase_GetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetViewport'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->GetViewport();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTick of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetTick00
static int tolua_engineWin32_Nuclear_EngineBase_GetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_Render00
static int tolua_engineWin32_Nuclear_EngineBase_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
  bool controlFPS = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(controlFPS);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGameTime of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetGameTime00
static int tolua_engineWin32_Nuclear_EngineBase_GetGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGameTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetGameTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsDaytime of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_IsDaytime00
static int tolua_engineWin32_Nuclear_EngineBase_IsDaytime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsDaytime'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsDaytime();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsDaytime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWaterDepth of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetWaterDepth00
static int tolua_engineWin32_Nuclear_EngineBase_GetWaterDepth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  unsigned int nDepth = ((unsigned int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWaterDepth'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetWaterDepth(*pt,nDepth);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)nDepth);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWaterDepth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetApp of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_GetApp00
static int tolua_engineWin32_Nuclear_EngineBase_GetApp00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetApp'", NULL);
#endif
  {
   Nuclear::IApp* tolua_ret = (Nuclear::IApp*)  self->GetApp();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IApp");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetApp'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsAsyncRead of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_IsAsyncRead00
static int tolua_engineWin32_Nuclear_EngineBase_IsAsyncRead00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::EngineBase* self = (const Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsAsyncRead'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsAsyncRead();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAsyncRead'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ScheduleTimer of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_ScheduleTimer00
static int tolua_engineWin32_Nuclear_EngineBase_ScheduleTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
  int period = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ScheduleTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ScheduleTimer(timer,period);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ScheduleTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CancelTimer of class  Nuclear::EngineBase */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_EngineBase_CancelTimer00
static int tolua_engineWin32_Nuclear_EngineBase_CancelTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::EngineBase",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::EngineBase* self = (Nuclear::EngineBase*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CancelTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CancelTimer(timer);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CancelTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScreenWidth of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetScreenWidth00
static int tolua_engineWin32_Nuclear_Engine_GetScreenWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScreenWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetScreenWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScreenWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetScreenHeight of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetScreenHeight00
static int tolua_engineWin32_Nuclear_Engine_GetScreenHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetScreenHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetScreenHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScreenHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicWidth of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetLogicWidth00
static int tolua_engineWin32_Nuclear_Engine_GetLogicWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicHeight of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetLogicHeight00
static int tolua_engineWin32_Nuclear_Engine_GetLogicHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Draw of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_Draw00
static int tolua_engineWin32_Nuclear_Engine_Draw00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Draw'", NULL);
#endif
  {
   self->Draw();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Draw'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetInstance of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetInstance00
static int tolua_engineWin32_Nuclear_Engine_GetInstance00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::Engine& tolua_ret = (Nuclear::Engine&)  Nuclear::Engine::GetInstance();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::Engine");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetInstance'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetInfoLogPath of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetInfoLogPath00
static int tolua_engineWin32_Nuclear_Engine_SetInfoLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetInfoLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetInfoLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetInfoLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetErrorLogPath of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetErrorLogPath00
static int tolua_engineWin32_Nuclear_Engine_SetErrorLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetErrorLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetErrorLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetErrorLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSegmpakLogPath of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetSegmpakLogPath00
static int tolua_engineWin32_Nuclear_Engine_SetSegmpakLogPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring fn = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSegmpakLogPath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetSegmpakLogPath(fn);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fn);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSegmpakLogPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurrentDirectory of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetCurrentDirectory00
static int tolua_engineWin32_Nuclear_Engine_GetCurrentDirectory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurrentDirectory'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetCurrentDirectory();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurrentDirectory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEnv of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetEnv00
static int tolua_engineWin32_Nuclear_Engine_GetEnv00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEnv'", NULL);
#endif
  {
   Nuclear::IEnv* tolua_ret = (Nuclear::IEnv*)  self->GetEnv();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEnv");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEnv'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Exit of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_Exit00
static int tolua_engineWin32_Nuclear_Engine_Exit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Exit'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Exit();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Exit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetGameTimeSpeedScale of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetGameTimeSpeedScale00
static int tolua_engineWin32_Nuclear_Engine_SetGameTimeSpeedScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  float fScale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetGameTimeSpeedScale'", NULL);
#endif
  {
   self->SetGameTimeSpeedScale(fScale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetGameTimeSpeedScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGameTimeSpeedScale of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetGameTimeSpeedScale00
static int tolua_engineWin32_Nuclear_Engine_GetGameTimeSpeedScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGameTimeSpeedScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetGameTimeSpeedScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGameTimeSpeedScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Render of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_Render00
static int tolua_engineWin32_Nuclear_Engine_Render00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  bool controlFPS = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Render'", NULL);
#endif
  {
   self->Render(controlFPS);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Render'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMultiSampleTypeEnable of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_IsMultiSampleTypeEnable00
static int tolua_engineWin32_Nuclear_Engine_IsMultiSampleTypeEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMultiSampleTypeEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMultiSampleTypeEnable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMultiSampleTypeEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PutTask of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_PutTask00
static int tolua_engineWin32_Nuclear_Engine_PutTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearRunnable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearRunnable* task = ((Nuclear::INuclearRunnable*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PutTask'", NULL);
#endif
  {
   self->PutTask(task);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PutTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ScheduleTimer of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_ScheduleTimer00
static int tolua_engineWin32_Nuclear_Engine_ScheduleTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
  int period = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ScheduleTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ScheduleTimer(timer,period);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ScheduleTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CancelTimer of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_CancelTimer00
static int tolua_engineWin32_Nuclear_Engine_CancelTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearTimer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearTimer* timer = ((Nuclear::INuclearTimer*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CancelTimer'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CancelTimer(timer);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CancelTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnIdle of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_OnIdle00
static int tolua_engineWin32_Nuclear_Engine_OnIdle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnIdle'", NULL);
#endif
  {
   self->OnIdle();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnIdle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSystemLevel of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetSystemLevel00
static int tolua_engineWin32_Nuclear_Engine_SetSystemLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearComputerConfigType l = ((Nuclear::NuclearComputerConfigType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSystemLevel'", NULL);
#endif
  {
   self->SetSystemLevel(l);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSystemLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIO of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetFileIO00
static int tolua_engineWin32_Nuclear_Engine_GetFileIO00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIO'", NULL);
#endif
  {
   Nuclear::INuclearFileIO* tolua_ret = (Nuclear::INuclearFileIO*)  self->GetFileIO();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::INuclearFileIO");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIO'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetApp of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetApp00
static int tolua_engineWin32_Nuclear_Engine_GetApp00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetApp'", NULL);
#endif
  {
   Nuclear::IApp* tolua_ret = (Nuclear::IApp*)  self->GetApp();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IApp");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetApp'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorld of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWorld00
static int tolua_engineWin32_Nuclear_Engine_GetWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorld'", NULL);
#endif
  {
   Nuclear::IWorld* tolua_ret = (Nuclear::IWorld*)  self->GetWorld();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IWorld");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorld of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWorld01
static int tolua_engineWin32_Nuclear_Engine_GetWorld01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorld'", NULL);
#endif
  {
   const Nuclear::IWorld* tolua_ret = (const Nuclear::IWorld*)  self->GetWorld();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::IWorld");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_GetWorld00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetXPWorld of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetXPWorld00
static int tolua_engineWin32_Nuclear_Engine_GetXPWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetXPWorld'", NULL);
#endif
  {
   Nuclear::World* tolua_ret = (Nuclear::World*)  self->GetXPWorld();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::World");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetXPWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWorldScale of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWorldScale00
static int tolua_engineWin32_Nuclear_Engine_GetWorldScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWorldScale'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetWorldScale();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWorldScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderer of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetRenderer00
static int tolua_engineWin32_Nuclear_Engine_GetRenderer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderer'", NULL);
#endif
  {
   Nuclear::Renderer* tolua_ret = (Nuclear::Renderer*)  self->GetRenderer();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Renderer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRenderer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetConfigManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetConfigManager00
static int tolua_engineWin32_Nuclear_Engine_GetConfigManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetConfigManager'", NULL);
#endif
  {
   Nuclear::ConfigManager* tolua_ret = (Nuclear::ConfigManager*)  self->GetConfigManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::ConfigManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetConfigManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSpriteManager00
static int tolua_engineWin32_Nuclear_Engine_GetSpriteManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteManager'", NULL);
#endif
  {
   const Nuclear::SpriteManager* tolua_ret = (const Nuclear::SpriteManager*)  self->GetSpriteManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::SpriteManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAniManager00
static int tolua_engineWin32_Nuclear_Engine_GetAniManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniManager'", NULL);
#endif
  {
   const Nuclear::AniManager* tolua_ret = (const Nuclear::AniManager*)  self->GetAniManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"const Nuclear::AniManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSystemResourceManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSystemResourceManager00
static int tolua_engineWin32_Nuclear_Engine_GetSystemResourceManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSystemResourceManager'", NULL);
#endif
  {
   Nuclear::SystemResourceManager* tolua_ret = (Nuclear::SystemResourceManager*)  self->GetSystemResourceManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SystemResourceManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSystemResourceManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpritePictureHandle of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSpritePictureHandle00
static int tolua_engineWin32_Nuclear_Engine_GetSpritePictureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpritePictureHandle'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetSpritePictureHandle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpritePictureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAlphaSpritePictureHandle of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAlphaSpritePictureHandle00
static int tolua_engineWin32_Nuclear_Engine_GetAlphaSpritePictureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAlphaSpritePictureHandle'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetAlphaSpritePictureHandle();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAlphaSpritePictureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFileIOManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetFileIOManager00
static int tolua_engineWin32_Nuclear_Engine_GetFileIOManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFileIOManager'", NULL);
#endif
  {
   Nuclear::NuclearFileIOManager* tolua_ret = (Nuclear::NuclearFileIOManager*)  self->GetFileIOManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFileIOManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFileIOManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSpriteManager01
static int tolua_engineWin32_Nuclear_Engine_GetSpriteManager01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteManager'", NULL);
#endif
  {
   Nuclear::SpriteManager* tolua_ret = (Nuclear::SpriteManager*)  self->GetSpriteManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::SpriteManager");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_GetSpriteManager00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAniManager01
static int tolua_engineWin32_Nuclear_Engine_GetAniManager01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniManager'", NULL);
#endif
  {
   Nuclear::AniManager* tolua_ret = (Nuclear::AniManager*)  self->GetAniManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::AniManager");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_GetAniManager00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEffectManager of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetEffectManager00
static int tolua_engineWin32_Nuclear_Engine_GetEffectManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEffectManager'", NULL);
#endif
  {
   Nuclear::EffectManager* tolua_ret = (Nuclear::EffectManager*)  self->GetEffectManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::EffectManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEffectManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPathFinder of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetPathFinder00
static int tolua_engineWin32_Nuclear_Engine_GetPathFinder00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPathFinder'", NULL);
#endif
  {
   astar::PathFinder* tolua_ret = (astar::PathFinder*)  self->GetPathFinder();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"astar::PathFinder");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPathFinder'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTick of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetTick00
static int tolua_engineWin32_Nuclear_Engine_GetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsAsyncRead of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_IsAsyncRead00
static int tolua_engineWin32_Nuclear_Engine_IsAsyncRead00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsAsyncRead'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsAsyncRead();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAsyncRead'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWaterDepth of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWaterDepth00
static int tolua_engineWin32_Nuclear_Engine_GetWaterDepth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* pt = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  unsigned int nDepth = ((unsigned int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWaterDepth'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetWaterDepth(*pt,nDepth);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)nDepth);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWaterDepth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableParticle of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_EnableParticle00
static int tolua_engineWin32_Nuclear_Engine_EnableParticle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  bool flag = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableParticle'", NULL);
#endif
  {
   self->EnableParticle(flag);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableParticle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetViewport of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetViewport00
static int tolua_engineWin32_Nuclear_Engine_GetViewport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetViewport'", NULL);
#endif
  {
   Nuclear::NuclearRect tolua_ret = (Nuclear::NuclearRect)  self->GetViewport();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearRect)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearRect));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearRect");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetViewport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteShadowParam of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSpriteShadowParam00
static int tolua_engineWin32_Nuclear_Engine_GetSpriteShadowParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  float shearX = ((float)  tolua_tonumber(tolua_S,2,0));
  float scalingY = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteShadowParam'", NULL);
#endif
  {
   self->GetSpriteShadowParam(shearX,scalingY);
   tolua_pushnumber(tolua_S,(lua_Number)shearX);
   tolua_pushnumber(tolua_S,(lua_Number)scalingY);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteShadowParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWindowState of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWindowState00
static int tolua_engineWin32_Nuclear_Engine_GetWindowState00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWindowState'", NULL);
#endif
  {
   Nuclear::NuclearWindowState tolua_ret = (Nuclear::NuclearWindowState)  self->GetWindowState();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowState'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTaskExecuteTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetTaskExecuteTime00
static int tolua_engineWin32_Nuclear_Engine_SetTaskExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
  int time = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTaskExecuteTime'", NULL);
#endif
  {
   self->SetTaskExecuteTime(type,time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTaskExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTaskExecuteTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetTaskExecuteTime00
static int tolua_engineWin32_Nuclear_Engine_GetTaskExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTaskExecuteTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTaskExecuteTime(type);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTaskExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetIOUpdateExecuteTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetIOUpdateExecuteTime00
static int tolua_engineWin32_Nuclear_Engine_SetIOUpdateExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetIOUpdateExecuteTime'", NULL);
#endif
  {
   self->SetIOUpdateExecuteTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetIOUpdateExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetIOUpdateExecuteTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetIOUpdateExecuteTime00
static int tolua_engineWin32_Nuclear_Engine_GetIOUpdateExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetIOUpdateExecuteTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetIOUpdateExecuteTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetIOUpdateExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAllSpriteCount of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAllSpriteCount00
static int tolua_engineWin32_Nuclear_Engine_GetAllSpriteCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAllSpriteCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAllSpriteCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAllSpriteCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTaskListCount of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetTaskListCount00
static int tolua_engineWin32_Nuclear_Engine_GetTaskListCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTaskListCount'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->GetTaskListCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTaskListCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetQueueOfIOTaskSize of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetQueueOfIOTaskSize00
static int tolua_engineWin32_Nuclear_Engine_GetQueueOfIOTaskSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetQueueOfIOTaskSize'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->GetQueueOfIOTaskSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetQueueOfIOTaskSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniPicGCTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetAniPicGCTime00
static int tolua_engineWin32_Nuclear_Engine_SetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniPicGCTime'", NULL);
#endif
  {
   self->SetAniPicGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniPicGCTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAniPicGCTime00
static int tolua_engineWin32_Nuclear_Engine_GetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniPicGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniPicGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniXapGCTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetAniXapGCTime00
static int tolua_engineWin32_Nuclear_Engine_SetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniXapGCTime'", NULL);
#endif
  {
   self->SetAniXapGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniXapGCTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetAniXapGCTime00
static int tolua_engineWin32_Nuclear_Engine_GetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniXapGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniXapGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnRendererRestore of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_OnRendererRestore00
static int tolua_engineWin32_Nuclear_Engine_OnRendererRestore00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnRendererRestore'", NULL);
#endif
  {
   self->OnRendererRestore();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnRendererRestore'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RunUserTask of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_RunUserTask00
static int tolua_engineWin32_Nuclear_Engine_RunUserTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RunUserTask'", NULL);
#endif
  {
   self->RunUserTask();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RunUserTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnTimer of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_OnTimer00
static int tolua_engineWin32_Nuclear_Engine_OnTimer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int iPeriod = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnTimer'", NULL);
#endif
  {
   self->OnTimer(iPeriod);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnTimer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetGameTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetGameTime00
static int tolua_engineWin32_Nuclear_Engine_GetGameTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetGameTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetGameTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGameTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableWade of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_IsEnableWade00
static int tolua_engineWin32_Nuclear_Engine_IsEnableWade00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableWade'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableWade();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableWade'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableWade of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEnableWade00
static int tolua_engineWin32_Nuclear_Engine_SetEnableWade00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableWade'", NULL);
#endif
  {
   self->SetEnableWade(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableWade'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: WindowToClient of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_WindowToClient00
static int tolua_engineWin32_Nuclear_Engine_WindowToClient00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPoint* point = ((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'WindowToClient'", NULL);
#endif
  {
   self->WindowToClient(*point);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WindowToClient'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateEngineSprite of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_CreateEngineSprite00
static int tolua_engineWin32_Nuclear_Engine_CreateEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,3,0));
  bool isUISprite = ((bool)  tolua_toboolean(tolua_S,4,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateEngineSprite'", NULL);
#endif
  {
   unsigned int tolua_ret = ( unsigned int)  self->CreateEngineSprite(modelname,async,isUISprite);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteModel of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteModel00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteModel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring modelname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteModel'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetEngineSpriteModel(handle,modelname,async);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)modelname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteModel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEngineSprite of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_ReleaseEngineSprite00
static int tolua_engineWin32_Nuclear_Engine_ReleaseEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEngineSprite'", NULL);
#endif
  {
   self->ReleaseEngineSprite(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RendererEngineSprite of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_RendererEngineSprite00
static int tolua_engineWin32_Nuclear_Engine_RendererEngineSprite00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RendererEngineSprite'", NULL);
#endif
  {
   self->RendererEngineSprite(handle);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RendererEngineSprite'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteLoc of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteLoc00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteLoc00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearPoint* loc = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteLoc'", NULL);
#endif
  {
   self->SetEngineSpriteLoc(handle,*loc);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteLoc'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDirection of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearDirection dir = ((Nuclear::NuclearDirection) (int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDirection'", NULL);
#endif
  {
   self->SetEngineSpriteDirection(handle,dir);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDirection'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDirection of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection01
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearPoint* target = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDirection'", NULL);
#endif
  {
   self->SetEngineSpriteDirection(handle,*target);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDefaultAction of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDefaultAction00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDefaultAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring actname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDefaultAction'", NULL);
#endif
  {
   self->SetEngineSpriteDefaultAction(handle,actname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDefaultAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteAction of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAction00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAction00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring actname = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteAction'", NULL);
#endif
  {
   self->SetEngineSpriteAction(handle,actname);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)actname);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteAction'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableEngineSpriteShadow of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_EnableEngineSpriteShadow00
static int tolua_engineWin32_Nuclear_Engine_EnableEngineSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  bool b = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableEngineSpriteShadow'", NULL);
#endif
  {
   self->EnableEngineSpriteShadow(handle,b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableEngineSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteScale of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteScale00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteScale00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  float scale = ((float)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteScale'", NULL);
#endif
  {
   self->SetEngineSpriteScale(handle,scale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteScale'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteAlpha of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  unsigned char alpha = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteAlpha'", NULL);
#endif
  {
   self->SetEngineSpriteAlpha(handle,alpha);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEngineSpriteActionTimeByName of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetEngineSpriteActionTimeByName00
static int tolua_engineWin32_Nuclear_Engine_GetEngineSpriteActionTimeByName00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  float time = ((float)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEngineSpriteActionTimeByName'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetEngineSpriteActionTimeByName(handle,action_name,time);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
   tolua_pushnumber(tolua_S,(lua_Number)time);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngineSpriteActionTimeByName'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteDurativeEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDurativeEffect00
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  const Nuclear::NuclearPoint* relpos = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteDurativeEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->SetEngineSpriteDurativeEffect(handle,effect_name,*relpos,flag);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEngineSpriteDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PlayEngineSpriteEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_PlayEngineSpriteEffect00
static int tolua_engineWin32_Nuclear_Engine_PlayEngineSpriteEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring effect_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  int dx = ((int)  tolua_tonumber(tolua_S,4,0));
  int dy = ((int)  tolua_tonumber(tolua_S,5,0));
  int times = ((int)  tolua_tonumber(tolua_S,6,0));
  unsigned int flag = ((unsigned int)  tolua_tonumber(tolua_S,7,0));
  unsigned char soundtype = ((unsigned char)  tolua_tonumber(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PlayEngineSpriteEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->PlayEngineSpriteEffect(handle,effect_name,dx,dy,times,flag,soundtype);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effect_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlayEngineSpriteEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: RemoveEngineSpriteDurativeEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_RemoveEngineSpriteDurativeEffect00
static int tolua_engineWin32_Nuclear_Engine_RemoveEngineSpriteDurativeEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RemoveEngineSpriteDurativeEffect'", NULL);
#endif
  {
   self->RemoveEngineSpriteDurativeEffect(handle,pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RemoveEngineSpriteDurativeEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEngineSpriteBubbleItemOffset of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetEngineSpriteBubbleItemOffset00
static int tolua_engineWin32_Nuclear_Engine_GetEngineSpriteBubbleItemOffset00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEngineSpriteBubbleItemOffset'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetEngineSpriteBubbleItemOffset(handle);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEngineSpriteBubbleItemOffset'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_CreateEffect00
static int tolua_engineWin32_Nuclear_Engine_CreateEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring effectname = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool async = ((bool)  tolua_toboolean(tolua_S,3,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateEffect'", NULL);
#endif
  {
   Nuclear::IEffect* tolua_ret = (Nuclear::IEffect*)  self->CreateEffect(effectname,async);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IEffect");
   tolua_pushcppwstring(tolua_S,(const wchar_t*)effectname);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_DrawEffect00
static int tolua_engineWin32_Nuclear_Engine_DrawEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEffect'", NULL);
#endif
  {
   self->DrawEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_ReleaseEffect00
static int tolua_engineWin32_Nuclear_Engine_ReleaseEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::IEffect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::IEffect* pEffect = ((Nuclear::IEffect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEffect'", NULL);
#endif
  {
   self->ReleaseEffect(pEffect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: HoldEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_HoldEffect00
static int tolua_engineWin32_Nuclear_Engine_HoldEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HoldEffect'", NULL);
#endif
  {
   self->HoldEffect(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HoldEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseEffect of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_ReleaseEffect01
static int tolua_engineWin32_Nuclear_Engine_ReleaseEffect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseEffect'", NULL);
#endif
  {
   self->ReleaseEffect(name);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)name);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_ReleaseEffect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: CaptureWorld of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_CaptureWorld00
static int tolua_engineWin32_Nuclear_Engine_CaptureWorld00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CaptureWorld'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->CaptureWorld();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CaptureWorld'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCleanColor of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetCleanColor00
static int tolua_engineWin32_Nuclear_Engine_SetCleanColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCleanColor'", NULL);
#endif
  {
   self->SetCleanColor(color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCleanColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCleanColor of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetCleanColor00
static int tolua_engineWin32_Nuclear_Engine_GetCleanColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCleanColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetCleanColor();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCleanColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GCNow of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GCNow00
static int tolua_engineWin32_Nuclear_Engine_GCNow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GCNow'", NULL);
#endif
  {
   self->GCNow();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GCNow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: setGCCooldown of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_setGCCooldown00
static int tolua_engineWin32_Nuclear_Engine_setGCCooldown00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setGCCooldown'", NULL);
#endif
  {
   self->setGCCooldown(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'setGCCooldown'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSmoothDeltaLimit of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaLimit00
static int tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int uiSmoothDeltaLimit = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSmoothDeltaLimit'", NULL);
#endif
  {
   self->SetSmoothDeltaLimit(uiSmoothDeltaLimit);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSmoothDeltaLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSmoothDeltaLimit of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaLimit00
static int tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSmoothDeltaLimit'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetSmoothDeltaLimit();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSmoothDeltaLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEngineSpriteAlpha of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha01
static int tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int handle = (( unsigned int)  tolua_tonumber(tolua_S,2,0));
  unsigned char alpha = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEngineSpriteAlpha'", NULL);
#endif
  {
   self->SetEngineSpriteAlpha(handle,alpha);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSmoothDeltaCount of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaCount00
static int tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  unsigned int uiSmoothDeltaCount = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSmoothDeltaCount'", NULL);
#endif
  {
   self->SetSmoothDeltaCount(uiSmoothDeltaCount);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSmoothDeltaCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSmoothDeltaCount of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaCount00
static int tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSmoothDeltaCount'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetSmoothDeltaCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSmoothDeltaCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicWidth of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetLogicWidth01
static int tolua_engineWin32_Nuclear_Engine_GetLogicWidth01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_GetLogicWidth00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicHeight of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetLogicHeight01
static int tolua_engineWin32_Nuclear_Engine_GetLogicHeight01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLogicHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Engine_GetLogicHeight00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetWidth of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetWidth00
static int tolua_engineWin32_Nuclear_Engine_GetWidth00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetWidth'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWidth'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetHeight of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetHeight00
static int tolua_engineWin32_Nuclear_Engine_GetHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTimeCount of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetTimeCount00
static int tolua_engineWin32_Nuclear_Engine_GetTimeCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTimeCount'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetTimeCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTimeCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurMemSize of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetCurMemSize00
static int tolua_engineWin32_Nuclear_Engine_GetCurMemSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurMemSize'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetCurMemSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurMemSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GeCurAvailableMemSize of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GeCurAvailableMemSize00
static int tolua_engineWin32_Nuclear_Engine_GeCurAvailableMemSize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GeCurAvailableMemSize'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GeCurAvailableMemSize();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GeCurAvailableMemSize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurDeltaTime of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetCurDeltaTime00
static int tolua_engineWin32_Nuclear_Engine_GetCurDeltaTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurDeltaTime'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetCurDeltaTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurDeltaTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepLoadTexture of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetStepLoadTexture00
static int tolua_engineWin32_Nuclear_Engine_SetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepLoadTexture'", NULL);
#endif
  {
   self->SetStepLoadTexture(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepLoadTexture of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetStepLoadTexture00
static int tolua_engineWin32_Nuclear_Engine_GetStepLoadTexture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Engine* self = (const Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepLoadTexture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetStepLoadTexture();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepLoadTexture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLimitFireThreadSecond of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_SetLimitFireThreadSecond00
static int tolua_engineWin32_Nuclear_Engine_SetLimitFireThreadSecond00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
  int limitFireThreadCount = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLimitFireThreadSecond'", NULL);
#endif
  {
   self->SetLimitFireThreadSecond(limitFireThreadCount);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLimitFireThreadSecond'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLimitFireThreadSecond of class  Nuclear::Engine */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Engine_GetLimitFireThreadSecond00
static int tolua_engineWin32_Nuclear_Engine_GetLimitFireThreadSecond00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Engine",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Engine* self = (Nuclear::Engine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLimitFireThreadSecond'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetLimitFireThreadSecond();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLimitFireThreadSecond'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_delete00
static int tolua_engineWin32_Nuclear_IEnv_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDisplayMode of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetDisplayMode00
static int tolua_engineWin32_Nuclear_IEnv_GetDisplayMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDisplayMode'", NULL);
#endif
  {
   Nuclear::NuclearDisplayMode tolua_ret = (Nuclear::NuclearDisplayMode)  self->GetDisplayMode();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearDisplayMode)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearDisplayMode));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDisplayMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurrentMultiSampleType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetCurrentMultiSampleType00
static int tolua_engineWin32_Nuclear_IEnv_GetCurrentMultiSampleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurrentMultiSampleType'", NULL);
#endif
  {
   Nuclear::NuclearMultiSampleType tolua_ret = (Nuclear::NuclearMultiSampleType)  self->GetCurrentMultiSampleType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurrentMultiSampleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsMultiSampleTypeEnable of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsMultiSampleTypeEnable00
static int tolua_engineWin32_Nuclear_IEnv_IsMultiSampleTypeEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsMultiSampleTypeEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsMultiSampleTypeEnable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMultiSampleTypeEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSoundInited of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsSoundInited00
static int tolua_engineWin32_Nuclear_IEnv_IsSoundInited00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSoundInited'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSoundInited();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSoundInited'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCurrentDirectory of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetCurrentDirectory00
static int tolua_engineWin32_Nuclear_IEnv_GetCurrentDirectory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCurrentDirectory'", NULL);
#endif
  {
   const std::wstring tolua_ret = (const std::wstring)  self->GetCurrentDirectory();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurrentDirectory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetCursorPosition of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetCursorPosition00
static int tolua_engineWin32_Nuclear_IEnv_SetCursorPosition00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearPoint* point = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetCursorPosition'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetCursorPosition(*point);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCursorPosition'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCursorPosition of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetCursorPosition00
static int tolua_engineWin32_Nuclear_IEnv_GetCursorPosition00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearPoint* point = ((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetCursorPosition'", NULL);
#endif
  {
   self->GetCursorPosition(*point);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorPosition'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: EnableRenderDuringLoading of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_EnableRenderDuringLoading00
static int tolua_engineWin32_Nuclear_IEnv_EnableRenderDuringLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EnableRenderDuringLoading'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->EnableRenderDuringLoading(b);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EnableRenderDuringLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderDuringLoading of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsRenderDuringLoading00
static int tolua_engineWin32_Nuclear_IEnv_IsRenderDuringLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderDuringLoading'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderDuringLoading();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderDuringLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetConsoleInfo of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetConsoleInfo00
static int tolua_engineWin32_Nuclear_IEnv_SetConsoleInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearConsoleInfo eInfo = ((Nuclear::NuclearConsoleInfo) (int)  tolua_tonumber(tolua_S,2,0));
  bool bOn = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetConsoleInfo'", NULL);
#endif
  {
   self->SetConsoleInfo(eInfo,bOn);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetConsoleInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestConsoleInfo of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_TestConsoleInfo00
static int tolua_engineWin32_Nuclear_IEnv_TestConsoleInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearConsoleInfo eInfo = ((Nuclear::NuclearConsoleInfo) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestConsoleInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestConsoleInfo(eInfo);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestConsoleInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameStateInfo of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetFrameStateInfo00
static int tolua_engineWin32_Nuclear_IEnv_SetFrameStateInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
  bool bOn = ((bool)  tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameStateInfo'", NULL);
#endif
  {
   self->SetFrameStateInfo(type,bOn);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameStateInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: TestFrameStateInfo of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_TestFrameStateInfo00
static int tolua_engineWin32_Nuclear_IEnv_TestFrameStateInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TestFrameStateInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->TestFrameStateInfo(type);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TestFrameStateInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetFrameStateColor of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetFrameStateColor00
static int tolua_engineWin32_Nuclear_IEnv_SetFrameStateColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetFrameStateColor'", NULL);
#endif
  {
   self->SetFrameStateColor(type,color);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetFrameStateColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFrameStateColor of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetFrameStateColor00
static int tolua_engineWin32_Nuclear_IEnv_GetFrameStateColor00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearFrameStatType type = ((Nuclear::NuclearFrameStatType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFrameStateColor'", NULL);
#endif
  {
   Nuclear::NuclearColor tolua_ret = (Nuclear::NuclearColor)  self->GetFrameStateColor(type);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearColor)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearColor));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearColor");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFrameStateColor'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetDynamicMapLoading of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetDynamicMapLoading00
static int tolua_engineWin32_Nuclear_IEnv_SetDynamicMapLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetDynamicMapLoading'", NULL);
#endif
  {
   self->SetDynamicMapLoading(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDynamicMapLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsDynamicMapLoading of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsDynamicMapLoading00
static int tolua_engineWin32_Nuclear_IEnv_IsDynamicMapLoading00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsDynamicMapLoading'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsDynamicMapLoading();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsDynamicMapLoading'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetControlFPS of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetControlFPS00
static int tolua_engineWin32_Nuclear_IEnv_SetControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetControlFPS'", NULL);
#endif
  {
   self->SetControlFPS(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsControlFPS of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsControlFPS00
static int tolua_engineWin32_Nuclear_IEnv_IsControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsControlFPS'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsControlFPS();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetControlFPS of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetControlFPS01
static int tolua_engineWin32_Nuclear_IEnv_SetControlFPS01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
  int fps = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetControlFPS'", NULL);
#endif
  {
   self->SetControlFPS(type,fps);
  }
 }
 return 0;
tolua_lerror:
 return tolua_engineWin32_Nuclear_IEnv_SetControlFPS00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetControlFPS of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetControlFPS00
static int tolua_engineWin32_Nuclear_IEnv_GetControlFPS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetControlFPS'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetControlFPS(type);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetControlFPS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTaskExecuteTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetTaskExecuteTime00
static int tolua_engineWin32_Nuclear_IEnv_SetTaskExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
  int time = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTaskExecuteTime'", NULL);
#endif
  {
   self->SetTaskExecuteTime(type,time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTaskExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTaskExecuteTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetTaskExecuteTime00
static int tolua_engineWin32_Nuclear_IEnv_GetTaskExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearWindowState type = ((Nuclear::NuclearWindowState) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTaskExecuteTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTaskExecuteTime(type);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTaskExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetIOUpdateExecuteTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetIOUpdateExecuteTime00
static int tolua_engineWin32_Nuclear_IEnv_SetIOUpdateExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int time = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetIOUpdateExecuteTime'", NULL);
#endif
  {
   self->SetIOUpdateExecuteTime(time);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetIOUpdateExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetIOUpdateExecuteTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetIOUpdateExecuteTime00
static int tolua_engineWin32_Nuclear_IEnv_GetIOUpdateExecuteTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetIOUpdateExecuteTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetIOUpdateExecuteTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetIOUpdateExecuteTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderNightEffectByShader of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectByShader00
static int tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectByShader00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderNightEffectByShader'", NULL);
#endif
  {
   self->SetRenderNightEffectByShader(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderNightEffectByShader'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderNightEffectByShader of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectByShader00
static int tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectByShader00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderNightEffectByShader'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderNightEffectByShader();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderNightEffectByShader'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderNightEffectWithRenderTarget of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectWithRenderTarget00
static int tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectWithRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderNightEffectWithRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderNightEffectWithRenderTarget();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderNightEffectWithRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderNightEffectWithRenderTarget of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectWithRenderTarget00
static int tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectWithRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderNightEffectWithRenderTarget'", NULL);
#endif
  {
   self->SetRenderNightEffectWithRenderTarget(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderNightEffectWithRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableMaskPic of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsEnableMaskPic00
static int tolua_engineWin32_Nuclear_IEnv_IsEnableMaskPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableMaskPic'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableMaskPic();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableMaskPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableMaskPic of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnableMaskPic00
static int tolua_engineWin32_Nuclear_IEnv_SetEnableMaskPic00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableMaskPic'", NULL);
#endif
  {
   self->SetEnableMaskPic(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableMaskPic'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderSpriteShadow of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsRenderSpriteShadow00
static int tolua_engineWin32_Nuclear_IEnv_IsRenderSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderSpriteShadow'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderSpriteShadow();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderSpriteShadow of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetRenderSpriteShadow00
static int tolua_engineWin32_Nuclear_IEnv_SetRenderSpriteShadow00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderSpriteShadow'", NULL);
#endif
  {
   self->SetRenderSpriteShadow(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderSpriteShadow'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsBlurForTeleport of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsBlurForTeleport00
static int tolua_engineWin32_Nuclear_IEnv_IsBlurForTeleport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsBlurForTeleport'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsBlurForTeleport();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsBlurForTeleport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBlurForTeleport of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetBlurForTeleport00
static int tolua_engineWin32_Nuclear_IEnv_SetBlurForTeleport00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBlurForTeleport'", NULL);
#endif
  {
   self->SetBlurForTeleport(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBlurForTeleport'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableSurfaceCache of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnableSurfaceCache00
static int tolua_engineWin32_Nuclear_IEnv_SetEnableSurfaceCache00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableSurfaceCache'", NULL);
#endif
  {
   self->SetEnableSurfaceCache(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableSurfaceCache'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableSurfaceCache of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsEnableSurfaceCache00
static int tolua_engineWin32_Nuclear_IEnv_IsEnableSurfaceCache00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableSurfaceCache'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableSurfaceCache();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableSurfaceCache'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSyncBeforeWater of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsSyncBeforeWater00
static int tolua_engineWin32_Nuclear_IEnv_IsSyncBeforeWater00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSyncBeforeWater'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSyncBeforeWater();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSyncBeforeWater'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSyncBeforeWater of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetSyncBeforeWater00
static int tolua_engineWin32_Nuclear_IEnv_SetSyncBeforeWater00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSyncBeforeWater'", NULL);
#endif
  {
   self->SetSyncBeforeWater(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSyncBeforeWater'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableSortMapObjects of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnableSortMapObjects00
static int tolua_engineWin32_Nuclear_IEnv_SetEnableSortMapObjects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableSortMapObjects'", NULL);
#endif
  {
   self->SetEnableSortMapObjects(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableSortMapObjects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableSortMapObjects of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsEnableSortMapObjects00
static int tolua_engineWin32_Nuclear_IEnv_IsEnableSortMapObjects00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableSortMapObjects'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableSortMapObjects();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableSortMapObjects'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableLinkedObjs of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnableLinkedObjs00
static int tolua_engineWin32_Nuclear_IEnv_SetEnableLinkedObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableLinkedObjs'", NULL);
#endif
  {
   self->SetEnableLinkedObjs(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableLinkedObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableLinkedObjs of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsEnableLinkedObjs00
static int tolua_engineWin32_Nuclear_IEnv_IsEnableLinkedObjs00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableLinkedObjs'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableLinkedObjs();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableLinkedObjs'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSystemLevel of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetSystemLevel00
static int tolua_engineWin32_Nuclear_IEnv_GetSystemLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSystemLevel'", NULL);
#endif
  {
   Nuclear::NuclearComputerConfigType tolua_ret = (Nuclear::NuclearComputerConfigType)  self->GetSystemLevel();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSystemLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ShowSpritePath of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_ShowSpritePath00
static int tolua_engineWin32_Nuclear_IEnv_ShowSpritePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ShowSpritePath'", NULL);
#endif
  {
   self->ShowSpritePath(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowSpritePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ShowSpriteTrail of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_ShowSpriteTrail00
static int tolua_engineWin32_Nuclear_IEnv_ShowSpriteTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ShowSpriteTrail'", NULL);
#endif
  {
   self->ShowSpriteTrail(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowSpriteTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ShowMapGrid of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_ShowMapGrid00
static int tolua_engineWin32_Nuclear_IEnv_ShowMapGrid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ShowMapGrid'", NULL);
#endif
  {
   self->ShowMapGrid(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowMapGrid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowSpritePath of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsShowSpritePath00
static int tolua_engineWin32_Nuclear_IEnv_IsShowSpritePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowSpritePath'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowSpritePath();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowSpritePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowSpriteTrail of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsShowSpriteTrail00
static int tolua_engineWin32_Nuclear_IEnv_IsShowSpriteTrail00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowSpriteTrail'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowSpriteTrail();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowSpriteTrail'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsShowMapGrid of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsShowMapGrid00
static int tolua_engineWin32_Nuclear_IEnv_IsShowMapGrid00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsShowMapGrid'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsShowMapGrid();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsShowMapGrid'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMapMazeMask of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMapMazeMask00
static int tolua_engineWin32_Nuclear_IEnv_SetMapMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  unsigned int tolua_var_2 = ((unsigned int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMapMazeMask'", NULL);
#endif
  {
   self->SetMapMazeMask(tolua_var_2);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMapMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMapMazeMask of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetMapMazeMask00
static int tolua_engineWin32_Nuclear_IEnv_GetMapMazeMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMapMazeMask'", NULL);
#endif
  {
   unsigned int tolua_ret = (unsigned int)  self->GetMapMazeMask();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMapMazeMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniPicGCTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetAniPicGCTime00
static int tolua_engineWin32_Nuclear_IEnv_SetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniPicGCTime'", NULL);
#endif
  {
   self->SetAniPicGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniPicGCTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetAniPicGCTime00
static int tolua_engineWin32_Nuclear_IEnv_GetAniPicGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniPicGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniPicGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniPicGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAniXapGCTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetAniXapGCTime00
static int tolua_engineWin32_Nuclear_IEnv_SetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAniXapGCTime'", NULL);
#endif
  {
   self->SetAniXapGCTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAniXapGCTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetAniXapGCTime00
static int tolua_engineWin32_Nuclear_IEnv_GetAniXapGCTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAniXapGCTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAniXapGCTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAniXapGCTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMax3DEffectComponentCount of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMax3DEffectComponentCount00
static int tolua_engineWin32_Nuclear_IEnv_SetMax3DEffectComponentCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int count = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMax3DEffectComponentCount'", NULL);
#endif
  {
   self->SetMax3DEffectComponentCount(count);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMax3DEffectComponentCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteTranslucentType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetSpriteTranslucentType00
static int tolua_engineWin32_Nuclear_IEnv_GetSpriteTranslucentType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteTranslucentType'", NULL);
#endif
  {
   Nuclear::NuclearSpriteTranslucentType tolua_ret = (Nuclear::NuclearSpriteTranslucentType)  self->GetSpriteTranslucentType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteTranslucentType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteTranslucentType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetSpriteTranslucentType00
static int tolua_engineWin32_Nuclear_IEnv_SetSpriteTranslucentType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearSpriteTranslucentType t = ((Nuclear::NuclearSpriteTranslucentType) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteTranslucentType'", NULL);
#endif
  {
   self->SetSpriteTranslucentType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteTranslucentType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaskAlpha of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetMaskAlpha00
static int tolua_engineWin32_Nuclear_IEnv_GetMaskAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaskAlpha'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetMaskAlpha();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaskAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaskAlpha of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMaskAlpha00
static int tolua_engineWin32_Nuclear_IEnv_SetMaskAlpha00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  float f = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaskAlpha'", NULL);
#endif
  {
   self->SetMaskAlpha(f);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaskAlpha'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsRenderSolidMask of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsRenderSolidMask00
static int tolua_engineWin32_Nuclear_IEnv_IsRenderSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsRenderSolidMask'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsRenderSolidMask();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRenderSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderSolidMask of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetRenderSolidMask00
static int tolua_engineWin32_Nuclear_IEnv_SetRenderSolidMask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderSolidMask'", NULL);
#endif
  {
   self->SetRenderSolidMask(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderSolidMask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAvailableMultiSampleType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetAvailableMultiSampleType00
static int tolua_engineWin32_Nuclear_IEnv_GetAvailableMultiSampleType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"std::vector<Nuclear::NuclearMultiSampleType>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool window = ((bool)  tolua_toboolean(tolua_S,2,0));
  bool isMode16 = ((bool)  tolua_toboolean(tolua_S,3,0));
  std::vector<Nuclear::NuclearMultiSampleType>* types = ((std::vector<Nuclear::NuclearMultiSampleType>*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAvailableMultiSampleType'", NULL);
#endif
  {
   self->GetAvailableMultiSampleType(window,isMode16,*types);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAvailableMultiSampleType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsSmoothMove of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsSmoothMove00
static int tolua_engineWin32_Nuclear_IEnv_IsSmoothMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsSmoothMove'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsSmoothMove();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsSmoothMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSmoothMove of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetSmoothMove00
static int tolua_engineWin32_Nuclear_IEnv_SetSmoothMove00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSmoothMove'", NULL);
#endif
  {
   self->SetSmoothMove(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSmoothMove'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMinDelta of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetMinDelta00
static int tolua_engineWin32_Nuclear_IEnv_GetMinDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMinDelta'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMinDelta();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMinDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMinDelta of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMinDelta00
static int tolua_engineWin32_Nuclear_IEnv_SetMinDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMinDelta'", NULL);
#endif
  {
   self->SetMinDelta(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMinDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaxDiffDelta of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetMaxDiffDelta00
static int tolua_engineWin32_Nuclear_IEnv_GetMaxDiffDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaxDiffDelta'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMaxDiffDelta();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxDiffDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaxDiffDelta of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMaxDiffDelta00
static int tolua_engineWin32_Nuclear_IEnv_SetMaxDiffDelta00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaxDiffDelta'", NULL);
#endif
  {
   self->SetMaxDiffDelta(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaxDiffDelta'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetMaxDiffFromAvg of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetMaxDiffFromAvg00
static int tolua_engineWin32_Nuclear_IEnv_GetMaxDiffFromAvg00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetMaxDiffFromAvg'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetMaxDiffFromAvg();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxDiffFromAvg'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetMaxDiffFromAvg of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetMaxDiffFromAvg00
static int tolua_engineWin32_Nuclear_IEnv_SetMaxDiffFromAvg00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  short d = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetMaxDiffFromAvg'", NULL);
#endif
  {
   self->SetMaxDiffFromAvg(d);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetMaxDiffFromAvg'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsEnableWade of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_IsEnableWade00
static int tolua_engineWin32_Nuclear_IEnv_IsEnableWade00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsEnableWade'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsEnableWade();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsEnableWade'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnableWade of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnableWade00
static int tolua_engineWin32_Nuclear_IEnv_SetEnableWade00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  bool b = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnableWade'", NULL);
#endif
  {
   self->SetEnableWade(b);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnableWade'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetUnloadMapBGSoundFadeOutTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetUnloadMapBGSoundFadeOutTime00
static int tolua_engineWin32_Nuclear_IEnv_GetUnloadMapBGSoundFadeOutTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetUnloadMapBGSoundFadeOutTime'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetUnloadMapBGSoundFadeOutTime();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetUnloadMapBGSoundFadeOutTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetUnloadMapBGSoundFadeOutTime of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetUnloadMapBGSoundFadeOutTime00
static int tolua_engineWin32_Nuclear_IEnv_SetUnloadMapBGSoundFadeOutTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int t = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetUnloadMapBGSoundFadeOutTime'", NULL);
#endif
  {
   self->SetUnloadMapBGSoundFadeOutTime(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetUnloadMapBGSoundFadeOutTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBGMType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetBGMType00
static int tolua_engineWin32_Nuclear_IEnv_GetBGMType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBGMType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetBGMType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBGMType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetBGMType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetBGMType00
static int tolua_engineWin32_Nuclear_IEnv_SetBGMType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetBGMType'", NULL);
#endif
  {
   self->SetBGMType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetBGMType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetEnvSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetEnvSoundType00
static int tolua_engineWin32_Nuclear_IEnv_GetEnvSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetEnvSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetEnvSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetEnvSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetEnvSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetEnvSoundType00
static int tolua_engineWin32_Nuclear_IEnv_SetEnvSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetEnvSoundType'", NULL);
#endif
  {
   self->SetEnvSoundType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetEnvSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetStepSoundType00
static int tolua_engineWin32_Nuclear_IEnv_GetStepSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetStepSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetStepSoundType00
static int tolua_engineWin32_Nuclear_IEnv_SetStepSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepSoundType'", NULL);
#endif
  {
   self->SetStepSoundType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetActionSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetActionSoundType00
static int tolua_engineWin32_Nuclear_IEnv_GetActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetActionSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->GetActionSoundType(action_name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetActionSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetActionSoundType00
static int tolua_engineWin32_Nuclear_IEnv_SetActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring action_name = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetActionSoundType'", NULL);
#endif
  {
   self->SetActionSoundType(action_name,t);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)action_name);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Get3DSpriteActionSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_Get3DSpriteActionSoundType00
static int tolua_engineWin32_Nuclear_IEnv_Get3DSpriteActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Get3DSpriteActionSoundType'", NULL);
#endif
  {
   unsigned char tolua_ret = (unsigned char)  self->Get3DSpriteActionSoundType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Get3DSpriteActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Set3DSpriteActionSoundType of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_Set3DSpriteActionSoundType00
static int tolua_engineWin32_Nuclear_IEnv_Set3DSpriteActionSoundType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  unsigned char t = ((unsigned char)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Set3DSpriteActionSoundType'", NULL);
#endif
  {
   self->Set3DSpriteActionSoundType(t);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Set3DSpriteActionSoundType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetStepSoundPriority of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetStepSoundPriority00
static int tolua_engineWin32_Nuclear_IEnv_GetStepSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetStepSoundPriority'", NULL);
#endif
  {
   short tolua_ret = (short)  self->GetStepSoundPriority();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetStepSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetStepSoundPriority of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetStepSoundPriority00
static int tolua_engineWin32_Nuclear_IEnv_SetStepSoundPriority00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  short p = ((short)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetStepSoundPriority'", NULL);
#endif
  {
   self->SetStepSoundPriority(p);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStepSoundPriority'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSpriteMoveSmoothLimit of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetSpriteMoveSmoothLimit00
static int tolua_engineWin32_Nuclear_IEnv_SetSpriteMoveSmoothLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  int iLimit = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSpriteMoveSmoothLimit'", NULL);
#endif
  {
   self->SetSpriteMoveSmoothLimit(iLimit);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSpriteMoveSmoothLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSpriteMoveSmoothLimit of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetSpriteMoveSmoothLimit00
static int tolua_engineWin32_Nuclear_IEnv_GetSpriteMoveSmoothLimit00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSpriteMoveSmoothLimit'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetSpriteMoveSmoothLimit();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSpriteMoveSmoothLimit'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLogicToWorldScaleX of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_GetLogicToWorldScaleX00
static int tolua_engineWin32_Nuclear_IEnv_GetLogicToWorldScaleX00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::IEnv* self = (const Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetLogicToWorldScaleX'", NULL);
#endif
  {
   float tolua_ret = (float)  self->GetLogicToWorldScaleX();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLogicToWorldScaleX'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLogicToWorldScaleX of class  Nuclear::IEnv */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IEnv_SetLogicToWorldScaleX00
static int tolua_engineWin32_Nuclear_IEnv_SetLogicToWorldScaleX00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IEnv",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IEnv* self = (Nuclear::IEnv*)  tolua_tousertype(tolua_S,1,0);
  float fScale = ((float)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLogicToWorldScaleX'", NULL);
#endif
  {
   self->SetLogicToWorldScaleX(fScale);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLogicToWorldScaleX'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: handle of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_handle
static int tolua_get_Nuclear__DrawPictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->handle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: handle of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_handle
static int tolua_set_Nuclear__DrawPictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->handle = ((  int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pRect of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_pRect_ptr
static int tolua_get_Nuclear__DrawPictureParam_pRect_ptr(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pRect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pRect,"const Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pMatrix of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_pMatrix_ptr
static int tolua_get_Nuclear__DrawPictureParam_pMatrix_ptr(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pMatrix'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pMatrix,"const Nuclear::NuclearMatrix3");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pColor of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_pColor_ptr
static int tolua_get_Nuclear__DrawPictureParam_pColor_ptr(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pColor'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pColor,"const Nuclear::NuclearColor");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: colorCount of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_colorCount
static int tolua_get_Nuclear__DrawPictureParam_colorCount(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'colorCount'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->colorCount);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: colorCount of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_colorCount
static int tolua_set_Nuclear__DrawPictureParam_colorCount(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'colorCount'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->colorCount = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: blend of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_blend
static int tolua_get_Nuclear__DrawPictureParam_blend(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blend'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->blend);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: blend of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_blend
static int tolua_set_Nuclear__DrawPictureParam_blend(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blend'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->blend = ((Nuclear::NuclearTextureBlendMode) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pSrcrect of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_pSrcrect_ptr
static int tolua_get_Nuclear__DrawPictureParam_pSrcrect_ptr(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pSrcrect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pSrcrect,"const Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bSpecAlpha of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_bSpecAlpha
static int tolua_get_Nuclear__DrawPictureParam_bSpecAlpha(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSpecAlpha'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bSpecAlpha);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bSpecAlpha of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_bSpecAlpha
static int tolua_set_Nuclear__DrawPictureParam_bSpecAlpha(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSpecAlpha'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bSpecAlpha = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bUseBW of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_bUseBW
static int tolua_get_Nuclear__DrawPictureParam_bUseBW(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bUseBW'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bUseBW);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bUseBW of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_bUseBW
static int tolua_set_Nuclear__DrawPictureParam_bUseBW(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bUseBW'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bUseBW = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fGreyPercent of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_fGreyPercent
static int tolua_get_Nuclear__DrawPictureParam_fGreyPercent(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fGreyPercent'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->fGreyPercent);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fGreyPercent of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_fGreyPercent
static int tolua_set_Nuclear__DrawPictureParam_fGreyPercent(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fGreyPercent'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fGreyPercent = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fRedPercent of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawPictureParam_fRedPercent
static int tolua_get_Nuclear__DrawPictureParam_fRedPercent(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fRedPercent'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->fRedPercent);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fRedPercent of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawPictureParam_fRedPercent
static int tolua_set_Nuclear__DrawPictureParam_fRedPercent(lua_State* tolua_S)
{
  Nuclear::DrawPictureParam* self = (Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fRedPercent'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fRedPercent = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawPictureParam_new00
static int tolua_engineWin32_Nuclear_DrawPictureParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawPictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawPictureParam* tolua_ret = (Nuclear::DrawPictureParam*)  Mtolua_new((Nuclear::DrawPictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawPictureParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::DrawPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawPictureParam_new00_local
static int tolua_engineWin32_Nuclear_DrawPictureParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawPictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawPictureParam* tolua_ret = (Nuclear::DrawPictureParam*)  Mtolua_new((Nuclear::DrawPictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawPictureParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: handle of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_handle
static int tolua_get_Nuclear__DrawEllipsePictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->handle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: handle of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_handle
static int tolua_set_Nuclear__DrawEllipsePictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->handle = ((  int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: x of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_x
static int tolua_get_Nuclear__DrawEllipsePictureParam_x(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->x);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: x of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_x
static int tolua_set_Nuclear__DrawEllipsePictureParam_x(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->x = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: y of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_y
static int tolua_get_Nuclear__DrawEllipsePictureParam_y(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->y);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: y of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_y
static int tolua_set_Nuclear__DrawEllipsePictureParam_y(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->y = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rx of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_rx
static int tolua_get_Nuclear__DrawEllipsePictureParam_rx(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rx'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->rx);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rx of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_rx
static int tolua_set_Nuclear__DrawEllipsePictureParam_rx(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rx'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rx = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: ry of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_ry
static int tolua_get_Nuclear__DrawEllipsePictureParam_ry(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ry'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->ry);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: ry of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_ry
static int tolua_set_Nuclear__DrawEllipsePictureParam_ry(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ry'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->ry = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: u0 of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_u0
static int tolua_get_Nuclear__DrawEllipsePictureParam_u0(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u0'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->u0);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: u0 of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_u0
static int tolua_set_Nuclear__DrawEllipsePictureParam_u0(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'u0'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->u0 = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: v0 of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_v0
static int tolua_get_Nuclear__DrawEllipsePictureParam_v0(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v0'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->v0);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: v0 of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_v0
static int tolua_set_Nuclear__DrawEllipsePictureParam_v0(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'v0'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->v0 = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: ru of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_ru
static int tolua_get_Nuclear__DrawEllipsePictureParam_ru(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ru'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->ru);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: ru of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_ru
static int tolua_set_Nuclear__DrawEllipsePictureParam_ru(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ru'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->ru = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rv of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_rv
static int tolua_get_Nuclear__DrawEllipsePictureParam_rv(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rv'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->rv);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rv of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_rv
static int tolua_set_Nuclear__DrawEllipsePictureParam_rv(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rv'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rv = ((float)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: color of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_color
static int tolua_get_Nuclear__DrawEllipsePictureParam_color(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'color'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->color,"Nuclear::NuclearColor");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: color of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_color
static int tolua_set_Nuclear__DrawEllipsePictureParam_color(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'color'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: TextureMode of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_TextureMode
static int tolua_get_Nuclear__DrawEllipsePictureParam_TextureMode(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'TextureMode'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->TextureMode);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: TextureMode of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_TextureMode
static int tolua_set_Nuclear__DrawEllipsePictureParam_TextureMode(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'TextureMode'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->TextureMode = ((Nuclear::NuclearTextureAddRess) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: borderColor of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawEllipsePictureParam_borderColor
static int tolua_get_Nuclear__DrawEllipsePictureParam_borderColor(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'borderColor'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)&self->borderColor,"Nuclear::NuclearColor");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: borderColor of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawEllipsePictureParam_borderColor
static int tolua_set_Nuclear__DrawEllipsePictureParam_borderColor(lua_State* tolua_S)
{
  Nuclear::DrawEllipsePictureParam* self = (Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'borderColor'",NULL);
  if ((tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearColor",0,&tolua_err)))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->borderColor = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00
static int tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawEllipsePictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawEllipsePictureParam* tolua_ret = (Nuclear::DrawEllipsePictureParam*)  Mtolua_new((Nuclear::DrawEllipsePictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawEllipsePictureParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::DrawEllipsePictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00_local
static int tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawEllipsePictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawEllipsePictureParam* tolua_ret = (Nuclear::DrawEllipsePictureParam*)  Mtolua_new((Nuclear::DrawEllipsePictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawEllipsePictureParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: handle of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_handle
static int tolua_get_Nuclear__DrawBatchPictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->handle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: handle of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_handle
static int tolua_set_Nuclear__DrawBatchPictureParam_handle(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'handle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->handle = ((  int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: secHandle of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_secHandle
static int tolua_get_Nuclear__DrawBatchPictureParam_secHandle(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'secHandle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->secHandle);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: secHandle of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_secHandle
static int tolua_set_Nuclear__DrawBatchPictureParam_secHandle(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'secHandle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->secHandle = ((  int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pRect of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_pRect_ptr
static int tolua_get_Nuclear__DrawBatchPictureParam_pRect_ptr(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pRect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pRect,"const Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: rectCount of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_rectCount
static int tolua_get_Nuclear__DrawBatchPictureParam_rectCount(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rectCount'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->rectCount);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: rectCount of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_rectCount
static int tolua_set_Nuclear__DrawBatchPictureParam_rectCount(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rectCount'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->rectCount = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pMatrix of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_pMatrix_ptr
static int tolua_get_Nuclear__DrawBatchPictureParam_pMatrix_ptr(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pMatrix'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pMatrix,"const Nuclear::NuclearMatrix3");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pColor of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_pColor_ptr
static int tolua_get_Nuclear__DrawBatchPictureParam_pColor_ptr(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pColor'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pColor,"const Nuclear::NuclearColor");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: colorCount of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_colorCount
static int tolua_get_Nuclear__DrawBatchPictureParam_colorCount(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'colorCount'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->colorCount);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: colorCount of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_colorCount
static int tolua_set_Nuclear__DrawBatchPictureParam_colorCount(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'colorCount'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->colorCount = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: blend of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_blend
static int tolua_get_Nuclear__DrawBatchPictureParam_blend(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blend'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->blend);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: blend of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_blend
static int tolua_set_Nuclear__DrawBatchPictureParam_blend(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blend'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->blend = ((Nuclear::NuclearTextureBlendMode) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pSrcrect of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_pSrcrect_ptr
static int tolua_get_Nuclear__DrawBatchPictureParam_pSrcrect_ptr(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pSrcrect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pSrcrect,"const Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: pSecSrcRect of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_pSecSrcRect_ptr
static int tolua_get_Nuclear__DrawBatchPictureParam_pSecSrcRect_ptr(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pSecSrcRect'",NULL);
#endif
   tolua_pushusertype(tolua_S,(void*)self->pSecSrcRect,"const Nuclear::NuclearFRectt");
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bSameuv of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_bSameuv
static int tolua_get_Nuclear__DrawBatchPictureParam_bSameuv(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSameuv'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bSameuv);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bSameuv of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_bSameuv
static int tolua_set_Nuclear__DrawBatchPictureParam_bSameuv(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSameuv'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bSameuv = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bSecSameuv of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_bSecSameuv
static int tolua_get_Nuclear__DrawBatchPictureParam_bSecSameuv(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSecSameuv'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bSecSameuv);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bSecSameuv of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_bSecSameuv
static int tolua_set_Nuclear__DrawBatchPictureParam_bSecSameuv(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSecSameuv'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bSecSameuv = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: bSpecAlpha of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__DrawBatchPictureParam_bSpecAlpha
static int tolua_get_Nuclear__DrawBatchPictureParam_bSpecAlpha(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSpecAlpha'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->bSpecAlpha);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: bSpecAlpha of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__DrawBatchPictureParam_bSpecAlpha
static int tolua_set_Nuclear__DrawBatchPictureParam_bSpecAlpha(lua_State* tolua_S)
{
  Nuclear::DrawBatchPictureParam* self = (Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bSpecAlpha'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->bSpecAlpha = ((bool)  tolua_toboolean(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00
static int tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawBatchPictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawBatchPictureParam* tolua_ret = (Nuclear::DrawBatchPictureParam*)  Mtolua_new((Nuclear::DrawBatchPictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawBatchPictureParam");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00_local
static int tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawBatchPictureParam",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::DrawBatchPictureParam* tolua_ret = (Nuclear::DrawBatchPictureParam*)  Mtolua_new((Nuclear::DrawBatchPictureParam)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawBatchPictureParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01
static int tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawBatchPictureParam",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::DrawPictureParam* dpp = ((const Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::DrawBatchPictureParam* tolua_ret = (Nuclear::DrawBatchPictureParam*)  Mtolua_new((Nuclear::DrawBatchPictureParam)(*dpp));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawBatchPictureParam");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::DrawBatchPictureParam */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01_local
static int tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::DrawBatchPictureParam",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::DrawPictureParam* dpp = ((const Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::DrawBatchPictureParam* tolua_ret = (Nuclear::DrawBatchPictureParam*)  Mtolua_new((Nuclear::DrawBatchPictureParam)(*dpp));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::DrawBatchPictureParam");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* get function: Z of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__Renderer_Z
static int tolua_get_Nuclear__Renderer_Z(lua_State* tolua_S)
{
  tolua_pushnumber(tolua_S,(lua_Number)Nuclear::Renderer::Z);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_delete00
static int tolua_engineWin32_Nuclear_Renderer_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawLine of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawLine00
static int tolua_engineWin32_Nuclear_Renderer_DrawLine00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x1 = ((float)  tolua_tonumber(tolua_S,2,0));
  float y1 = ((float)  tolua_tonumber(tolua_S,3,0));
  float x2 = ((float)  tolua_tonumber(tolua_S,4,0));
  float y2 = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawLine'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawLine(x1,y1,x2,y2,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawLine'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBox of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawBox00
static int tolua_engineWin32_Nuclear_Renderer_DrawBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,8,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x1 = ((float)  tolua_tonumber(tolua_S,2,0));
  float y1 = ((float)  tolua_tonumber(tolua_S,3,0));
  float x2 = ((float)  tolua_tonumber(tolua_S,4,0));
  float y2 = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,8,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBox'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBox(x1,y1,x2,y2,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawCircle of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawCircle00
static int tolua_engineWin32_Nuclear_Renderer_DrawCircle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float r = ((float)  tolua_tonumber(tolua_S,4,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,5,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,6,Nuclear::XPFM_SOLIDFILL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawCircle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawCircle(x,y,r,color,fillmode);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawCircle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPictureFromNativePath of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath00
static int tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_iscppstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const std::string nativepath = ((const std::string)  tolua_tocppstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPictureFromNativePath'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPictureFromNativePath(nativepath);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppstring(tolua_S,(const char*)nativepath);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadPictureFromNativePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawPicture00
static int tolua_engineWin32_Nuclear_Renderer_DrawPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearFRectt* rect = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(handle,*rect,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile00
static int tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveTextureToFile'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnResetDevice of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_OnResetDevice00
static int tolua_engineWin32_Nuclear_Renderer_OnResetDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnResetDevice'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->OnResetDevice();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnResetDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDisplayMode of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetDisplayMode00
static int tolua_engineWin32_Nuclear_Renderer_GetDisplayMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Renderer* self = (const Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDisplayMode'", NULL);
#endif
  {
   Nuclear::NuclearDisplayMode tolua_ret = (Nuclear::NuclearDisplayMode)  self->GetDisplayMode();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearDisplayMode)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearDisplayMode));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDisplayMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_Destroy00
static int tolua_engineWin32_Nuclear_Renderer_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   self->Destroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScissorRect of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SetScissorRect00
static int tolua_engineWin32_Nuclear_Renderer_SetScissorRect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* pRect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScissorRect'", NULL);
#endif
  {
   self->SetScissorRect(pRect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScissorRect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawLine of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawLine01
static int tolua_engineWin32_Nuclear_Renderer_DrawLine01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* line = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawLine'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawLine(*line,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawLine00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawLine of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawLine02
static int tolua_engineWin32_Nuclear_Renderer_DrawLine02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* lines = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  int n = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawLine'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawLine(lines,n,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawLine01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangle of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawTriangle00
static int tolua_engineWin32_Nuclear_Renderer_DrawTriangle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,8,&tolua_err) || !tolua_isusertype(tolua_S,8,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x1 = ((float)  tolua_tonumber(tolua_S,2,0));
  float y1 = ((float)  tolua_tonumber(tolua_S,3,0));
  float x2 = ((float)  tolua_tonumber(tolua_S,4,0));
  float y2 = ((float)  tolua_tonumber(tolua_S,5,0));
  float x3 = ((float)  tolua_tonumber(tolua_S,6,0));
  float y3 = ((float)  tolua_tonumber(tolua_S,7,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangle(x1,y1,x2,y2,x3,y3,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBox of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawBox01
static int tolua_engineWin32_Nuclear_Renderer_DrawBox01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* rect = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,4,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,5,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBox'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBox(*rect,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawBox00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBox of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawBox02
static int tolua_engineWin32_Nuclear_Renderer_DrawBox02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,6,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* rects = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  int n = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,6,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBox'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBox(rects,n,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawBox01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawFan of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawFan00
static int tolua_engineWin32_Nuclear_Renderer_DrawFan00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,8,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float r = ((float)  tolua_tonumber(tolua_S,4,0));
  float fTheta = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,8,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawFan'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawFan(x,y,r,fTheta,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawFan'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipseFan of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawEllipseFan00
static int tolua_engineWin32_Nuclear_Renderer_DrawEllipseFan00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,10,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float rx = ((float)  tolua_tonumber(tolua_S,4,0));
  float ry = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  float fStartAngle = ((float)  tolua_tonumber(tolua_S,8,0.0f));
  float fEndAngle = ((float)  tolua_tonumber(tolua_S,9,0.0f));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,10,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipseFan'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipseFan(x,y,rx,ry,color,fillmode,fStartAngle,fEndAngle,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipseFan'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipse of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawEllipse00
static int tolua_engineWin32_Nuclear_Renderer_DrawEllipse00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float rx = ((float)  tolua_tonumber(tolua_S,4,0));
  float ry = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  float fAngle = ((float)  tolua_tonumber(tolua_S,8,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipse'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipse(x,y,rx,ry,color,fillmode,fAngle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipse'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangleList of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawTriangleList00
static int tolua_engineWin32_Nuclear_Renderer_DrawTriangleList00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearTCVertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearTCVertex* pVertexs = ((const Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,2,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangleList'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangleList(pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangleList'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipsePicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture00
static int tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,9,&tolua_err) || !tolua_isusertype(tolua_S,9,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  float x = ((float)  tolua_tonumber(tolua_S,3,0));
  float y = ((float)  tolua_tonumber(tolua_S,4,0));
  float rx = ((float)  tolua_tonumber(tolua_S,5,0));
  float ry = ((float)  tolua_tonumber(tolua_S,6,0));
  float u0 = ((float)  tolua_tonumber(tolua_S,7,0));
  float v0 = ((float)  tolua_tonumber(tolua_S,8,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipsePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipsePicture(handle,x,y,rx,ry,u0,v0,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipsePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipsePicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture01
static int tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawEllipsePictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawEllipsePictureParam* param = ((const Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipsePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipsePicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPictureFromNativePath of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath01
static int tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_iscppstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const std::string nativepath = ((const std::string)  tolua_tocppstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPictureFromNativePath'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPictureFromNativePath(nativepath);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppstring(tolua_S,(const char*)nativepath);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_LoadPicture00
static int tolua_engineWin32_Nuclear_Renderer_LoadPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPicture'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPicture(filename);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CachePicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_CachePicture00
static int tolua_engineWin32_Nuclear_Renderer_CachePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int pic = ((  int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CachePicture'", NULL);
#endif
  {
   self->CachePicture(pic,filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CachePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CacheInMemory of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_CacheInMemory00
static int tolua_engineWin32_Nuclear_Renderer_CacheInMemory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CacheInMemory'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CacheInMemory();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CacheInMemory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawPicture01
static int tolua_engineWin32_Nuclear_Renderer_DrawPicture01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawPictureParam* param = ((const Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawPicture00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreePicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_FreePicture00
static int tolua_engineWin32_Nuclear_Renderer_FreePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->FreePicture(handle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBatchPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawBatchPicture00
static int tolua_engineWin32_Nuclear_Renderer_DrawBatchPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawBatchPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawBatchPictureParam* param = ((const Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBatchPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBatchPicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawBatchPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawPicture02
static int tolua_engineWin32_Nuclear_Renderer_DrawPicture02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearFRectt* rect = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(handle,*rect,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawPicture01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateRenderTarget of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_CreateRenderTarget00
static int tolua_engineWin32_Nuclear_Renderer_CreateRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  int iWidth = ((int)  tolua_tonumber(tolua_S,2,0));
  int iHeight = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearTextureFormat texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateRenderTarget'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->CreateRenderTarget(iWidth,iHeight,texfmt);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeRenderTarget of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_FreeRenderTarget00
static int tolua_engineWin32_Nuclear_Renderer_FreeRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int hRenderTarget = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->FreeRenderTarget(hRenderTarget);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PushRenderTarget of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_PushRenderTarget00
static int tolua_engineWin32_Nuclear_Renderer_PushRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int hRenderTarget = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PushRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PushRenderTarget(hRenderTarget);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PopRenderTarget of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_PopRenderTarget00
static int tolua_engineWin32_Nuclear_Renderer_PopRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PopRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PopRenderTarget();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SelectRenderEffect of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SelectRenderEffect00
static int tolua_engineWin32_Nuclear_Renderer_SelectRenderEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPRENDER_EFFECT xpre = ((Nuclear::XPRENDER_EFFECT) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SelectRenderEffect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SelectRenderEffect(xpre);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SelectRenderEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShaderParam of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SetShaderParam00
static int tolua_engineWin32_Nuclear_Renderer_SetShaderParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPRENDER_EFFECT xpre = ((Nuclear::XPRENDER_EFFECT) (int)  tolua_tonumber(tolua_S,2,0));
  const void* pParam = ((const void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShaderParam'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetShaderParam(xpre,pParam);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShaderParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderEffect of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetRenderEffect00
static int tolua_engineWin32_Nuclear_Renderer_GetRenderEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderEffect'", NULL);
#endif
  {
   Nuclear::XPRENDER_EFFECT tolua_ret = (Nuclear::XPRENDER_EFFECT)  self->GetRenderEffect();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRenderEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsAutoTestDevice of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_IsAutoTestDevice00
static int tolua_engineWin32_Nuclear_Renderer_IsAutoTestDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsAutoTestDevice'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsAutoTestDevice();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAutoTestDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAutoTestDevice of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SetAutoTestDevice00
static int tolua_engineWin32_Nuclear_Renderer_SetAutoTestDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  bool isAuto = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAutoTestDevice'", NULL);
#endif
  {
   self->SetAutoTestDevice(isAuto);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAutoTestDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRestoreTask of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SetRestoreTask00
static int tolua_engineWin32_Nuclear_Renderer_SetRestoreTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearRunnable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearRunnable* pTask = ((Nuclear::INuclearRunnable*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRestoreTask'", NULL);
#endif
  {
   self->SetRestoreTask(pTask);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRestoreTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetLostTask of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SetLostTask00
static int tolua_engineWin32_Nuclear_Renderer_SetLostTask00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::INuclearRunnable",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::INuclearRunnable* pTask = ((Nuclear::INuclearRunnable*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetLostTask'", NULL);
#endif
  {
   self->SetLostTask(pTask);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetLostTask'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAvailableTextureMem of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetAvailableTextureMem00
static int tolua_engineWin32_Nuclear_Renderer_GetAvailableTextureMem00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAvailableTextureMem'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAvailableTextureMem();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAvailableTextureMem'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTextureCapsNoPow2 of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_IsTextureCapsNoPow200
static int tolua_engineWin32_Nuclear_Renderer_IsTextureCapsNoPow200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTextureCapsNoPow2'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTextureCapsNoPow2();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTextureCapsNoPow2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleManager of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetParticleManager00
static int tolua_engineWin32_Nuclear_Renderer_GetParticleManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleManager'", NULL);
#endif
  {
   Nuclear::IParticleManager* tolua_ret = (Nuclear::IParticleManager*)  self->GetParticleManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IParticleManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFontManager of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetFontManager00
static int tolua_engineWin32_Nuclear_Renderer_GetFontManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFontManager'", NULL);
#endif
  {
   Nuclear::IFontManager* tolua_ret = (Nuclear::IFontManager*)  self->GetFontManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IFontManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFontManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile01
static int tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile02
static int tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearImageFileFormat filefmt = ((Nuclear::NuclearImageFileFormat) (int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,filefmt,path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile03
static int tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearImageFileFormat filefmt = ((Nuclear::NuclearImageFileFormat) (int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,filefmt,path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 2;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile04
static int tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::NuclearBuffer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearTextureFormat texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearImageFileFormat filefmt = ((Nuclear::NuclearImageFileFormat) (int)  tolua_tonumber(tolua_S,4,0));
  Nuclear::NuclearBuffer* outbuffer = ((Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,texfmt,filefmt,*outbuffer);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpAllPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DumpAllPicture00
static int tolua_engineWin32_Nuclear_Renderer_DumpAllPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpAllPicture'", NULL);
#endif
  {
   self->DumpAllPicture(path);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpAllPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPictureSizeInfo of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_GetPictureSizeInfo00
static int tolua_engineWin32_Nuclear_Renderer_GetPictureSizeInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPictureSizeInfo'", NULL);
#endif
  {
   Nuclear::NuclearPictureInfo tolua_ret = (Nuclear::NuclearPictureInfo)  self->GetPictureSizeInfo(handle);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearPictureInfo)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPictureInfo");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearPictureInfo));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearPictureInfo");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPictureSizeInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Renderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Renderer_DrawPicture03
static int tolua_engineWin32_Nuclear_Renderer_DrawPicture03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Renderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Renderer* self = (Nuclear::Renderer*)  tolua_tousertype(tolua_S,1,0);
   int picHandle = ((  int)  tolua_tonumber(tolua_S,2,0));
  float left = ((float)  tolua_tonumber(tolua_S,3,0));
  float top = ((float)  tolua_tonumber(tolua_S,4,0));
  float right = ((float)  tolua_tonumber(tolua_S,5,0));
  float bottom = ((float)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(picHandle,left,top,right,bottom);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Renderer_DrawPicture02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_delete00
static int tolua_engineWin32_Nuclear_IFontManager_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Release of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_Release00
static int tolua_engineWin32_Nuclear_IFontManager_Release00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Release'", NULL);
#endif
  {
   self->Release();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Release'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFontTypeHeight of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_GetFontTypeHeight00
static int tolua_engineWin32_Nuclear_IFontManager_GetFontTypeHeight00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
  int fontType = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFontTypeHeight'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFontTypeHeight(fontType);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFontTypeHeight'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFontTypeUnderlinePosition of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlinePosition00
static int tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlinePosition00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
  int fontType = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFontTypeUnderlinePosition'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFontTypeUnderlinePosition(fontType);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFontTypeUnderlinePosition'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFontTypeUnderlineThickness of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlineThickness00
static int tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlineThickness00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
  int fontType = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFontTypeUnderlineThickness'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetFontTypeUnderlineThickness(fontType);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFontTypeUnderlineThickness'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewText of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_NewText00
static int tolua_engineWin32_Nuclear_IFontManager_NewText00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LPCTSTR",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
  LPCTSTR text = *((LPCTSTR*)  tolua_tousertype(tolua_S,2,0));
  int fonttype = ((int)  tolua_tonumber(tolua_S,3,0));
  DWORD color = ((DWORD)  tolua_tonumber(tolua_S,4,0));
  DWORD gradualcolor = ((DWORD)  tolua_tonumber(tolua_S,5,0));
  DWORD bkColor = ((DWORD)  tolua_tonumber(tolua_S,6,0));
  bool bUnderline = ((bool)  tolua_toboolean(tolua_S,7,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewText'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->NewText(text,fonttype,color,gradualcolor,bkColor,bUnderline);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewText'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawText of class  Nuclear::IFontManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IFontManager_DrawText00
static int tolua_engineWin32_Nuclear_IFontManager_DrawText00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::IFontManager",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::IFontManager* self = (Nuclear::IFontManager*)  tolua_tousertype(tolua_S,1,0);
   int htb = ((  int)  tolua_tonumber(tolua_S,2,0));
  float x1 = ((float)  tolua_tonumber(tolua_S,3,0));
  float y1 = ((float)  tolua_tonumber(tolua_S,4,0));
  const Nuclear::NuclearFRectt* srcrect = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawText'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawText(htb,x1,y1,srcrect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawText'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_nPicWidth of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearPictureInfo_m_nPicWidth
static int tolua_get_Nuclear__NuclearPictureInfo_m_nPicWidth(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPicWidth'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_nPicWidth);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_nPicWidth of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearPictureInfo_m_nPicWidth
static int tolua_set_Nuclear__NuclearPictureInfo_m_nPicWidth(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPicWidth'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_nPicWidth = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_nPicHeight of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearPictureInfo_m_nPicHeight
static int tolua_get_Nuclear__NuclearPictureInfo_m_nPicHeight(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPicHeight'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_nPicHeight);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_nPicHeight of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearPictureInfo_m_nPicHeight
static int tolua_set_Nuclear__NuclearPictureInfo_m_nPicHeight(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_nPicHeight'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_nPicHeight = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_texfmt of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearPictureInfo_m_texfmt
static int tolua_get_Nuclear__NuclearPictureInfo_m_texfmt(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_texfmt'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_texfmt);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_texfmt of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearPictureInfo_m_texfmt
static int tolua_set_Nuclear__NuclearPictureInfo_m_texfmt(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_texfmt'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: m_pooltype of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearPictureInfo_m_pooltype
static int tolua_get_Nuclear__NuclearPictureInfo_m_pooltype(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pooltype'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->m_pooltype);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: m_pooltype of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearPictureInfo_m_pooltype
static int tolua_set_Nuclear__NuclearPictureInfo_m_pooltype(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'm_pooltype'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->m_pooltype = ((Nuclear::NuclearPoolType) (int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: fileuri of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_get_Nuclear__NuclearPictureInfo_fileuri
static int tolua_get_Nuclear__NuclearPictureInfo_fileuri(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fileuri'",NULL);
#endif
  tolua_pushcppwstring(tolua_S,(const wchar_t*)self->fileuri);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: fileuri of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_set_Nuclear__NuclearPictureInfo_fileuri
static int tolua_set_Nuclear__NuclearPictureInfo_fileuri(lua_State* tolua_S)
{
  Nuclear::NuclearPictureInfo* self = (Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fileuri'",NULL);
  if (!tolua_iscppwstring(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->fileuri = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPictureInfo_new00
static int tolua_engineWin32_Nuclear_NuclearPictureInfo_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPictureInfo",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearPictureInfo* tolua_ret = (Nuclear::NuclearPictureInfo*)  Mtolua_new((Nuclear::NuclearPictureInfo)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPictureInfo");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearPictureInfo */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearPictureInfo_new00_local
static int tolua_engineWin32_Nuclear_NuclearPictureInfo_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearPictureInfo",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearPictureInfo* tolua_ret = (Nuclear::NuclearPictureInfo*)  Mtolua_new((Nuclear::NuclearPictureInfo)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearPictureInfo");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_new00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* pFileIOMan = ((Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::Cocos2dRenderer* tolua_ret = (Nuclear::Cocos2dRenderer*)  Mtolua_new((Nuclear::Cocos2dRenderer)(pFileIOMan));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Cocos2dRenderer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_new00_local
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"Nuclear::NuclearFileIOManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearFileIOManager* pFileIOMan = ((Nuclear::NuclearFileIOManager*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::Cocos2dRenderer* tolua_ret = (Nuclear::Cocos2dRenderer*)  Mtolua_new((Nuclear::Cocos2dRenderer)(pFileIOMan));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::Cocos2dRenderer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_delete00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Create of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_Create00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_Create00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearDisplayMode",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearDisplayMode* dmode = ((const Nuclear::NuclearDisplayMode*)  tolua_tousertype(tolua_S,2,0));
  DWORD flags = ((DWORD)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearMultiSampleType mstype = ((Nuclear::NuclearMultiSampleType) (int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Create'", NULL);
#endif
  {
   Nuclear::XPCREATE_RENDERER_RESULT tolua_ret = (Nuclear::XPCREATE_RENDERER_RESULT)  self->Create(*dmode,flags,mstype);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Create'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Destroy of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_Destroy00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_Destroy00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Destroy'", NULL);
#endif
  {
   self->Destroy();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Destroy'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTextureEtc of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureEtc00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureEtc00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTextureEtc'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTextureEtc(handle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTextureEtc'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDisplayMode of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetDisplayMode00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetDisplayMode00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetDisplayMode'", NULL);
#endif
  {
   Nuclear::NuclearDisplayMode tolua_ret = (Nuclear::NuclearDisplayMode)  self->GetDisplayMode();
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((Nuclear::NuclearDisplayMode)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(Nuclear::NuclearDisplayMode));
     tolua_pushusertype(tolua_S,tolua_obj,"Nuclear::NuclearDisplayMode");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDisplayMode'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetScissorRect of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetScissorRect00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetScissorRect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearRect",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearRect* pRect = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetScissorRect'", NULL);
#endif
  {
   self->SetScissorRect(pRect);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScissorRect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetBackBuffer of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetBackBuffer00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetBackBuffer00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetBackBuffer'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->GetBackBuffer();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetBackBuffer'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawLine of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* line = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawLine'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawLine(*line,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawLine'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawLine of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* lines = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  int n = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawLine'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawLine(lines,n,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangle of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangle00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,8,&tolua_err) || !tolua_isusertype(tolua_S,8,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  float x1 = ((float)  tolua_tonumber(tolua_S,2,0));
  float y1 = ((float)  tolua_tonumber(tolua_S,3,0));
  float x2 = ((float)  tolua_tonumber(tolua_S,4,0));
  float y2 = ((float)  tolua_tonumber(tolua_S,5,0));
  float x3 = ((float)  tolua_tonumber(tolua_S,6,0));
  float y3 = ((float)  tolua_tonumber(tolua_S,7,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,8,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangle(x1,y1,x2,y2,x3,y3,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBox of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* rect = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,4,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,5,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBox'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBox(*rect,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawBox'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBox of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFRectt",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,6,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearFRectt* rects = ((const Nuclear::NuclearFRectt*)  tolua_tousertype(tolua_S,2,0));
  int n = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,5,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,6,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBox'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBox(rects,n,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipse of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipse00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipse00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float rx = ((float)  tolua_tonumber(tolua_S,4,0));
  float ry = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  float fAngle = ((float)  tolua_tonumber(tolua_S,8,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipse'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipse(x,y,rx,ry,color,fillmode,fAngle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipse'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawFan of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawFan00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawFan00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,8,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,9,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float r = ((float)  tolua_tonumber(tolua_S,4,0));
  float fTheta = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,8,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawFan'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawFan(x,y,r,fTheta,color,fillmode,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawFan'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipseFan of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipseFan00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipseFan00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,6,&tolua_err) || !tolua_isusertype(tolua_S,6,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isusertype(tolua_S,10,"const Nuclear::NuclearMatrix3",1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,11,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  float rx = ((float)  tolua_tonumber(tolua_S,4,0));
  float ry = ((float)  tolua_tonumber(tolua_S,5,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,6,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,7,Nuclear::XPFM_SOLIDFILL));
  float fStartAngle = ((float)  tolua_tonumber(tolua_S,8,0.0f));
  float fEndAngle = ((float)  tolua_tonumber(tolua_S,9,0.0f));
  const Nuclear::NuclearMatrix3* pMatrix = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,10,NULL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipseFan'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipseFan(x,y,rx,ry,color,fillmode,fStartAngle,fEndAngle,pMatrix);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipseFan'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPolygon of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPolygon00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPolygon00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<Nuclear::NuclearPoint>",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const std::vector<Nuclear::NuclearPoint>* pts = ((const std::vector<Nuclear::NuclearPoint>*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,4,Nuclear::XPFM_SOLIDFILL));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPolygon'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPolygon(*pts,color,fillmode);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawPolygon'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangles of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangles00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<Nuclear::NuclearTriangle>",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const std::vector<Nuclear::NuclearTriangle>* triangles = ((const std::vector<Nuclear::NuclearTriangle>*)  tolua_tousertype(tolua_S,2,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,3,0));
  Nuclear::NuclearFillMode fillmode = ((Nuclear::NuclearFillMode) (int)  tolua_tonumber(tolua_S,4,Nuclear::XPFM_WIREFRAME));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangles'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangles(*triangles,color,fillmode);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangleList of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleList00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleList00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearTCVertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::NuclearTCVertex* pVertexs = ((const Nuclear::NuclearTCVertex*)  tolua_tousertype(tolua_S,2,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangleList'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangleList(pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangleList'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipsePicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,9,&tolua_err) || !tolua_isusertype(tolua_S,9,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  float x = ((float)  tolua_tonumber(tolua_S,3,0));
  float y = ((float)  tolua_tonumber(tolua_S,4,0));
  float rx = ((float)  tolua_tonumber(tolua_S,5,0));
  float ry = ((float)  tolua_tonumber(tolua_S,6,0));
  float u0 = ((float)  tolua_tonumber(tolua_S,7,0));
  float v0 = ((float)  tolua_tonumber(tolua_S,8,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,9,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipsePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipsePicture(handle,x,y,rx,ry,u0,v0,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawEllipsePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawEllipsePicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawEllipsePictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawEllipsePictureParam* param = ((const Nuclear::DrawEllipsePictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawEllipsePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawEllipsePicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawPictureParam* param = ((const Nuclear::DrawPictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int picHandle = ((  int)  tolua_tonumber(tolua_S,2,0));
  float left = ((float)  tolua_tonumber(tolua_S,3,0));
  float top = ((float)  tolua_tonumber(tolua_S,4,0));
  float right = ((float)  tolua_tonumber(tolua_S,5,0));
  float bottom = ((float)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawPicture(picHandle,left,top,right,bottom);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreePicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->FreePicture(handle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SelectRenderEffect of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SelectRenderEffect00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SelectRenderEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPRENDER_EFFECT xpre = ((Nuclear::XPRENDER_EFFECT) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SelectRenderEffect'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SelectRenderEffect(xpre);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SelectRenderEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetShaderParam of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetShaderParam00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetShaderParam00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPRENDER_EFFECT xpre = ((Nuclear::XPRENDER_EFFECT) (int)  tolua_tonumber(tolua_S,2,0));
  const void* pParam = ((const void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetShaderParam'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SetShaderParam(xpre,pParam);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetShaderParam'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderEffect of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderEffect'", NULL);
#endif
  {
   Nuclear::XPRENDER_EFFECT tolua_ret = (Nuclear::XPRENDER_EFFECT)  self->GetRenderEffect();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRenderEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CreateRenderTarget of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_CreateRenderTarget00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_CreateRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  int iWidth = ((int)  tolua_tonumber(tolua_S,2,0));
  int iHeight = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearTextureFormat texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CreateRenderTarget'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->CreateRenderTarget(iWidth,iHeight,texfmt);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreeRenderTarget of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_FreeRenderTarget00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_FreeRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int hRenderTarget = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreeRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->FreeRenderTarget(hRenderTarget);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FreeRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PushRenderTarget of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_PushRenderTarget00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_PushRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int hRenderTarget = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PushRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PushRenderTarget(hRenderTarget);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: PopRenderTarget of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_PopRenderTarget00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_PopRenderTarget00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PopRenderTarget'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->PopRenderTarget();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopRenderTarget'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawBatchPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBatchPicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBatchPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::DrawBatchPictureParam",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const Nuclear::DrawBatchPictureParam* param = ((const Nuclear::DrawBatchPictureParam*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawBatchPicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawBatchPicture(*param);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawBatchPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPicture'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPicture(filename);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CachePicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_CachePicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_CachePicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int pic = ((  int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CachePicture'", NULL);
#endif
  {
   self->CachePicture(pic,filename);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CachePicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPictureFromMem of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromMem00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromMem00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"Nuclear::NuclearPictureInfo",1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
     !tolua_isboolean(tolua_S,7,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
     !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,10,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const void* data = ((const void*)  tolua_touserdata(tolua_S,2,0));
  int size = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearPictureInfo* pPicInfo = ((Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,4,NULL));
  Nuclear::NuclearTextureFormat texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,5,Nuclear::XPTEXFMT_DEFAULT));
  Nuclear::NuclearPoolType pooltype = ((Nuclear::NuclearPoolType) (int)  tolua_tonumber(tolua_S,6,Nuclear::XPPOOL_MANAGED));
  bool bCache = ((bool)  tolua_toboolean(tolua_S,7,true));
   int handle = ((  int)  tolua_tonumber(tolua_S,8,0));
  int iScale = ((int)  tolua_tonumber(tolua_S,9,100));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPictureFromMem'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPictureFromMem(data,size,pPicInfo,texfmt,pooltype,bCache,handle,iScale);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadPictureFromMem'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTextData of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextData00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextData00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const char* pChar = ((const char*)  tolua_tostring(tolua_S,2,0));
  const std::string font = ((const std::string)  tolua_tocppstring(tolua_S,3,0));
  int size = ((int)  tolua_tonumber(tolua_S,4,0));
  unsigned char* pData = ((unsigned char*)  tolua_tostring(tolua_S,5,0));
  int w = ((int)  tolua_tonumber(tolua_S,6,0));
  int h = ((int)  tolua_tonumber(tolua_S,7,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTextData'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetTextData(pChar,font,size,pData,w,h);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppstring(tolua_S,(const char*)font);
   tolua_pushstring(tolua_S,(const char*)pData);
   tolua_pushnumber(tolua_S,(lua_Number)w);
   tolua_pushnumber(tolua_S,(lua_Number)h);
  }
 }
 return 5;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTextData'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: NewPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_NewPicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_NewPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,4,"Nuclear::NuclearPictureInfo",1,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  int width = ((int)  tolua_tonumber(tolua_S,2,0));
  int height = ((int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::NuclearPictureInfo* pPicInfo = ((Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,4,NULL));
  Nuclear::NuclearTextureFormat texfmt = ((Nuclear::NuclearTextureFormat) (int)  tolua_tonumber(tolua_S,5,Nuclear::XPTEXFMT_DEFAULT));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'NewPicture'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->NewPicture(width,height,pPicInfo,texfmt);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: FreePicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'FreePicture'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->FreePicture(handle);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawText of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawText00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawText00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LPCTSTR",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"LPRECT",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  LPCTSTR text = *((LPCTSTR*)  tolua_tousertype(tolua_S,2,0));
  int nstr = ((int)  tolua_tonumber(tolua_S,3,0));
  LPRECT rect = *((LPRECT*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawText'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawText(text,nstr,rect,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawText'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTmpText of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTmpText00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTmpText00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LPCTSTR",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"LPRECT",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !tolua_isusertype(tolua_S,5,"Nuclear::NuclearColor",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  LPCTSTR text = *((LPCTSTR*)  tolua_tousertype(tolua_S,2,0));
  int nstr = ((int)  tolua_tonumber(tolua_S,3,0));
  LPRECT rect = *((LPRECT*)  tolua_tousertype(tolua_S,4,0));
  Nuclear::NuclearColor color = *((Nuclear::NuclearColor*)  tolua_tousertype(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTmpText'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTmpText(text,nstr,rect,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTmpText'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsAutoTestDevice of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_IsAutoTestDevice00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_IsAutoTestDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsAutoTestDevice'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsAutoTestDevice();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAutoTestDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAutoTestDevice of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAutoTestDevice00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAutoTestDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  bool isAuto = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAutoTestDevice'", NULL);
#endif
  {
   self->SetAutoTestDevice(isAuto);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAutoTestDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAlphaBlendEnable of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendEnable00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  bool f = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAlphaBlendEnable'", NULL);
#endif
  {
   self->SetAlphaBlendEnable(f);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAlphaBlendEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAlphaBlendEnable of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendEnable00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendEnable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAlphaBlendEnable'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetAlphaBlendEnable();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAlphaBlendEnable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAlphaBlendSrcType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendSrcType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendSrcType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPALPHABLEND_TYPE srcblend = ((Nuclear::XPALPHABLEND_TYPE) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAlphaBlendSrcType'", NULL);
#endif
  {
   self->SetAlphaBlendSrcType(srcblend);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAlphaBlendSrcType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAlphaBlendSrcType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendSrcType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendSrcType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAlphaBlendSrcType'", NULL);
#endif
  {
   Nuclear::XPALPHABLEND_TYPE tolua_ret = (Nuclear::XPALPHABLEND_TYPE)  self->GetAlphaBlendSrcType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAlphaBlendSrcType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetAlphaBlendDstType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendDstType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendDstType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPALPHABLEND_TYPE dstblend = ((Nuclear::XPALPHABLEND_TYPE) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetAlphaBlendDstType'", NULL);
#endif
  {
   self->SetAlphaBlendDstType(dstblend);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetAlphaBlendDstType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAlphaBlendDstType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendDstType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendDstType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAlphaBlendDstType'", NULL);
#endif
  {
   Nuclear::XPALPHABLEND_TYPE tolua_ret = (Nuclear::XPALPHABLEND_TYPE)  self->GetAlphaBlendDstType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAlphaBlendDstType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTextureColorBlendType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetTextureColorBlendType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetTextureColorBlendType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPTEXCOLORBLEND_TYPE colorop = ((Nuclear::XPTEXCOLORBLEND_TYPE) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTextureColorBlendType'", NULL);
#endif
  {
   self->SetTextureColorBlendType(colorop);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTextureColorBlendType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTextureColorBlendType of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextureColorBlendType00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextureColorBlendType00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTextureColorBlendType'", NULL);
#endif
  {
   Nuclear::XPTEXCOLORBLEND_TYPE tolua_ret = (Nuclear::XPTEXCOLORBLEND_TYPE)  self->GetTextureColorBlendType();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTextureColorBlendType'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetSeparateAlphaBlend of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetSeparateAlphaBlend00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetSeparateAlphaBlend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  bool f = ((bool)  tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetSeparateAlphaBlend'", NULL);
#endif
  {
   self->SetSeparateAlphaBlend(f);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetSeparateAlphaBlend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetSeparateAlphaBlend of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetSeparateAlphaBlend00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetSeparateAlphaBlend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetSeparateAlphaBlend'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetSeparateAlphaBlend();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetSeparateAlphaBlend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetRenderEffect of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SetRenderEffect00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SetRenderEffect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::XPRENDER_EFFECT re = ((Nuclear::XPRENDER_EFFECT) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetRenderEffect'", NULL);
#endif
  {
   self->SetRenderEffect(re);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetRenderEffect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRenderEffect of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRenderEffect'", NULL);
#endif
  {
   Nuclear::XPRENDER_EFFECT tolua_ret = (Nuclear::XPRENDER_EFFECT)  self->GetRenderEffect();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawTriangleFan of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleFan00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleFan00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearTCT1Vertex* pVertexs = ((const Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,3,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawTriangleFan'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawTriangleFan(handle,pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawTriangleFan'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawParticles of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearTCT1Vertex* pVertexs = ((const Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,3,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawParticles'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawParticles(handle,pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawParticles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DrawParticles of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearUTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const Nuclear::NuclearUTCT1Vertex* pVertexs = ((const Nuclear::NuclearUTCT1Vertex*)  tolua_tousertype(tolua_S,3,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawParticles'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->DrawParticles(handle,pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: CollectParticles of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_CollectParticles00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_CollectParticles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isusertype(tolua_S,5,"const Nuclear::NuclearTCT1Vertex",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,7,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::XPTEXCOLORBLEND_TYPE colorBlend = ((Nuclear::XPTEXCOLORBLEND_TYPE) (int)  tolua_tonumber(tolua_S,3,0));
  Nuclear::PSL_RENDSTATE alphaBlend = ((Nuclear::PSL_RENDSTATE) (int)  tolua_tonumber(tolua_S,4,0));
  const Nuclear::NuclearTCT1Vertex* pVertexs = ((const Nuclear::NuclearTCT1Vertex*)  tolua_tousertype(tolua_S,5,0));
  int nVertexNum = ((int)  tolua_tonumber(tolua_S,6,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'CollectParticles'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->CollectParticles(handle,colorBlend,alphaBlend,pVertexs,nVertexNum);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CollectParticles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: BatchDrawParticles of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_BatchDrawParticles00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_BatchDrawParticles00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BatchDrawParticles'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->BatchDrawParticles();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BatchDrawParticles'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPictureInfo of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearPictureInfo",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearPictureInfo* picinfo = ((Nuclear::NuclearPictureInfo*)  tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPictureInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetPictureInfo(handle,*picinfo);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPictureInfo'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPictureInfo of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo01
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  int pitch = ((int)  tolua_tonumber(tolua_S,3,0));
  int width = ((int)  tolua_tonumber(tolua_S,4,0));
  int height = ((int)  tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPictureInfo'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetPictureInfo(handle,pitch,width,height);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)pitch);
   tolua_pushnumber(tolua_S,(lua_Number)width);
   tolua_pushnumber(tolua_S,(lua_Number)height);
  }
 }
 return 4;
tolua_lerror:
 return tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetPictureHandle of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureHandle00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureHandle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::Cocos2dRenderer* self = (const Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  const std::wstring fileuri = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetPictureHandle'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->GetPictureHandle(handle,fileuri);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)fileuri);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetPictureHandle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAdapterDescription of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAdapterDescription00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAdapterDescription00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAdapterDescription'", NULL);
#endif
  {
   std::wstring tolua_ret = (std::wstring)  self->GetAdapterDescription();
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAdapterDescription'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAvailableTextureMem of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAvailableTextureMem00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAvailableTextureMem00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetAvailableTextureMem'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetAvailableTextureMem();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAvailableTextureMem'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsTextureCapsNoPow2 of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureCapsNoPow200
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureCapsNoPow200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'IsTextureCapsNoPow2'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->IsTextureCapsNoPow2();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsTextureCapsNoPow2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetParticleManager of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetParticleManager00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetParticleManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetParticleManager'", NULL);
#endif
  {
   Nuclear::IParticleManager* tolua_ret = (Nuclear::IParticleManager*)  self->GetParticleManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IParticleManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetParticleManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFontManager of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_GetFontManager00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_GetFontManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFontManager'", NULL);
#endif
  {
   Nuclear::IFontManager* tolua_ret = (Nuclear::IFontManager*)  self->GetFontManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::IFontManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFontManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SaveTextureToFile of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_SaveTextureToFile00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_SaveTextureToFile00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
   int handle = ((  int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearImageFileFormat filefmt = ((Nuclear::NuclearImageFileFormat) (int)  tolua_tonumber(tolua_S,3,0));
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SaveTextureToFile'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->SaveTextureToFile(handle,filefmt,path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SaveTextureToFile'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DumpAllPicture of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_DumpAllPicture00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_DumpAllPicture00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring path = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DumpAllPicture'", NULL);
#endif
  {
   self->DumpAllPicture(path);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)path);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DumpAllPicture'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: LoadPictureFromNativePath of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromNativePath00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromNativePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_iscppstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
  const std::string nativepath = ((const std::string)  tolua_tocppstring(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'LoadPictureFromNativePath'", NULL);
#endif
  {
    int tolua_ret = (  int)  self->LoadPictureFromNativePath(nativepath);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppstring(tolua_S,(const char*)nativepath);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LoadPictureFromNativePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: OnResetDevice of class  Nuclear::Cocos2dRenderer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cocos2dRenderer_OnResetDevice00
static int tolua_engineWin32_Nuclear_Cocos2dRenderer_OnResetDevice00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::Cocos2dRenderer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::Cocos2dRenderer* self = (Nuclear::Cocos2dRenderer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'OnResetDevice'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->OnResetDevice();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OnResetDevice'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: reserve of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_reserve00
static int tolua_engineWin32_Nuclear_NuclearOctets_reserve00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'reserve'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->reserve(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'reserve'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: replace of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_replace00
static int tolua_engineWin32_Nuclear_NuclearOctets_replace00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  const void* data = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'replace'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->replace(data,size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'replace'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_delete00
static int tolua_engineWin32_Nuclear_NuclearOctets_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: begin of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_begin00
static int tolua_engineWin32_Nuclear_NuclearOctets_begin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'begin'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->begin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'begin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: end of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_end00
static int tolua_engineWin32_Nuclear_NuclearOctets_end00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'end'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->end();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'end'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constbegin of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_constbegin00
static int tolua_engineWin32_Nuclear_NuclearOctets_constbegin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constbegin'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constbegin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constbegin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constend of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_constend00
static int tolua_engineWin32_Nuclear_NuclearOctets_constend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constend'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constend();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: size of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_size00
static int tolua_engineWin32_Nuclear_NuclearOctets_size00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'size'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->size();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'size'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: capacity of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_capacity00
static int tolua_engineWin32_Nuclear_NuclearOctets_capacity00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'capacity'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->capacity();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'capacity'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: clear of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_clear00
static int tolua_engineWin32_Nuclear_NuclearOctets_clear00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'clear'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->clear();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'clear'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: erase of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_erase00
static int tolua_engineWin32_Nuclear_NuclearOctets_erase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  void* x = ((void*)  tolua_touserdata(tolua_S,2,0));
  void* y = ((void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'erase'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->erase(x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'erase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_insert00
static int tolua_engineWin32_Nuclear_NuclearOctets_insert00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  size_t len = ((size_t)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->insert(pos,x,len);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'insert'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_insert01
static int tolua_engineWin32_Nuclear_NuclearOctets_insert01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->insert(pos,x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearOctets_insert00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: resize of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_resize00
static int tolua_engineWin32_Nuclear_NuclearOctets_resize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'resize'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->resize(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'resize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: clone of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_clone00
static int tolua_engineWin32_Nuclear_NuclearOctets_clone00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'clone'", NULL);
#endif
  {
   Nuclear::NuclearOctets* tolua_ret = (Nuclear::NuclearOctets*)  self->clone();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'clone'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRef of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_GetRef00
static int tolua_engineWin32_Nuclear_NuclearOctets_GetRef00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRef'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetRef();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRef'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTick of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_SetTick00
static int tolua_engineWin32_Nuclear_NuclearOctets_SetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
  int tick = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTick'", NULL);
#endif
  {
   self->SetTick(tick);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTick of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_GetTick00
static int tolua_engineWin32_Nuclear_NuclearOctets_GetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearOctets* self = (const Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: dump of class  Nuclear::NuclearOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearOctets_dump00
static int tolua_engineWin32_Nuclear_NuclearOctets_dump00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearOctets* self = (Nuclear::NuclearOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'dump'", NULL);
#endif
  {
   self->dump();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'dump'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: reserve of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_reserve00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_reserve00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'reserve'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->reserve(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'reserve'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: replace of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_replace00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_replace00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  const void* data = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'replace'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->replace(data,size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'replace'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_delete00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new00_local
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new01
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(x,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new01_local
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(x,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new02
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,3,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(x,y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new02_local
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,3,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(x,y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new03
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBufferOctets",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearBufferOctets* x = ((const Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(*x));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_new03_local
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBufferOctets",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearBufferOctets* x = ((const Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearBufferOctets* tolua_ret = (Nuclear::NuclearBufferOctets*)  Mtolua_new((Nuclear::NuclearBufferOctets)(*x));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBufferOctets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: begin of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_begin00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_begin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'begin'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->begin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'begin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: end of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_end00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_end00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'end'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->end();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'end'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constbegin of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_constbegin00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_constbegin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constbegin'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constbegin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constbegin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constend of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_constend00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_constend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constend'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constend();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: size of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_size00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_size00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'size'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->size();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'size'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: capacity of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_capacity00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_capacity00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'capacity'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->capacity();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'capacity'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: clear of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_clear00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_clear00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'clear'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->clear();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'clear'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: erase of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_erase00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_erase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  void* x = ((void*)  tolua_touserdata(tolua_S,2,0));
  void* y = ((void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'erase'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->erase(x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'erase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_insert00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_insert00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  size_t len = ((size_t)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->insert(pos,x,len);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'insert'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_insert01
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_insert01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->insert(pos,x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBufferOctets_insert00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: resize of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_resize00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_resize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'resize'", NULL);
#endif
  {
   Nuclear::NuclearOctets& tolua_ret = (Nuclear::NuclearOctets&)  self->resize(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'resize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: clone of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_clone00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_clone00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'clone'", NULL);
#endif
  {
   Nuclear::NuclearOctets* tolua_ret = (Nuclear::NuclearOctets*)  self->clone();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearOctets");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'clone'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRef of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_GetRef00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_GetRef00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRef'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetRef();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRef'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTick of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_SetTick00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_SetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
  int tick = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTick'", NULL);
#endif
  {
   self->SetTick(tick);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTick of class  Nuclear::NuclearBufferOctets */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBufferOctets_GetTick00
static int tolua_engineWin32_Nuclear_NuclearBufferOctets_GetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBufferOctets",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBufferOctets* self = (Nuclear::NuclearBufferOctets*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: reserve of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_reserve00
static int tolua_engineWin32_Nuclear_NuclearBuffer_reserve00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'reserve'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->reserve(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'reserve'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: replace of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_replace00
static int tolua_engineWin32_Nuclear_NuclearBuffer_replace00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  const void* data = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'replace'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->replace(data,size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'replace'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_delete00
static int tolua_engineWin32_Nuclear_NuclearBuffer_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new00
static int tolua_engineWin32_Nuclear_NuclearBuffer_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new00_local
static int tolua_engineWin32_Nuclear_NuclearBuffer_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new01
static int tolua_engineWin32_Nuclear_NuclearBuffer_new01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new01_local
static int tolua_engineWin32_Nuclear_NuclearBuffer_new01_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new00_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new02
static int tolua_engineWin32_Nuclear_NuclearBuffer_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(x,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new01(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new02_local
static int tolua_engineWin32_Nuclear_NuclearBuffer_new02_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  size_t size = ((size_t)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(x,size));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new01_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new03
static int tolua_engineWin32_Nuclear_NuclearBuffer_new03(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,3,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(x,y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new02(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new03_local
static int tolua_engineWin32_Nuclear_NuclearBuffer_new03_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const void* x = ((const void*)  tolua_touserdata(tolua_S,2,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,3,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(x,y));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new02_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new04
static int tolua_engineWin32_Nuclear_NuclearBuffer_new04(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBuffer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearBuffer* x = ((const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(*x));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new03(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_new04_local
static int tolua_engineWin32_Nuclear_NuclearBuffer_new04_local(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearBuffer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  const Nuclear::NuclearBuffer* x = ((const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearBuffer* tolua_ret = (Nuclear::NuclearBuffer*)  Mtolua_new((Nuclear::NuclearBuffer)(*x));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearBuffer");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_new03_local(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: swap of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_swap00
static int tolua_engineWin32_Nuclear_NuclearBuffer_swap00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"Nuclear::NuclearBuffer",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  Nuclear::NuclearBuffer* x = ((Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'swap'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->swap(*x);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'swap'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: normalbegin of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_normalbegin00
static int tolua_engineWin32_Nuclear_NuclearBuffer_normalbegin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'normalbegin'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->normalbegin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'normalbegin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: normalend of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_normalend00
static int tolua_engineWin32_Nuclear_NuclearBuffer_normalend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'normalend'", NULL);
#endif
  {
   void* tolua_ret = (void*)  self->normalend();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'normalend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constbegin of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_constbegin00
static int tolua_engineWin32_Nuclear_NuclearBuffer_constbegin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constbegin'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constbegin();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constbegin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: constend of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_constend00
static int tolua_engineWin32_Nuclear_NuclearBuffer_constend00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'constend'", NULL);
#endif
  {
   const void* tolua_ret = (const void*)  self->constend();
   tolua_pushuserdata(tolua_S,(void*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'constend'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: size of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_size00
static int tolua_engineWin32_Nuclear_NuclearBuffer_size00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'size'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->size();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'size'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: capacity of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_capacity00
static int tolua_engineWin32_Nuclear_NuclearBuffer_capacity00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'capacity'", NULL);
#endif
  {
   size_t tolua_ret = (size_t)  self->capacity();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'capacity'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: clear of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_clear00
static int tolua_engineWin32_Nuclear_NuclearBuffer_clear00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'clear'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->clear();
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'clear'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: erase of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_erase00
static int tolua_engineWin32_Nuclear_NuclearBuffer_erase00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  void* x = ((void*)  tolua_touserdata(tolua_S,2,0));
  void* y = ((void*)  tolua_touserdata(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'erase'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->erase(x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'erase'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_insert00
static int tolua_engineWin32_Nuclear_NuclearBuffer_insert00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  size_t len = ((size_t)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->insert(pos,x,len);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'insert'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: insert of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_insert01
static int tolua_engineWin32_Nuclear_NuclearBuffer_insert01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,2,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
     !tolua_isuserdata(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  void* pos = ((void*)  tolua_touserdata(tolua_S,2,0));
  const void* x = ((const void*)  tolua_touserdata(tolua_S,3,0));
  const void* y = ((const void*)  tolua_touserdata(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'insert'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->insert(pos,x,y);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_NuclearBuffer_insert00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* method: resize of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_resize00
static int tolua_engineWin32_Nuclear_NuclearBuffer_resize00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  size_t size = ((size_t)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'resize'", NULL);
#endif
  {
   Nuclear::NuclearBuffer& tolua_ret = (Nuclear::NuclearBuffer&)  self->resize(size);
    tolua_pushusertype(tolua_S,(void*)&tolua_ret,"Nuclear::NuclearBuffer");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'resize'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: dump of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_dump00
static int tolua_engineWin32_Nuclear_NuclearBuffer_dump00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'dump'", NULL);
#endif
  {
   self->dump();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'dump'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRefCount of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_GetRefCount00
static int tolua_engineWin32_Nuclear_NuclearBuffer_GetRefCount00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetRefCount'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetRefCount();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRefCount'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: SetTick of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_SetTick00
static int tolua_engineWin32_Nuclear_NuclearBuffer_SetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearBuffer* self = (Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
  int tick = ((int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SetTick'", NULL);
#endif
  {
   self->SetTick(tick);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTick of class  Nuclear::NuclearBuffer */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_NuclearBuffer_GetTick00
static int tolua_engineWin32_Nuclear_NuclearBuffer_GetTick00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearBuffer",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearBuffer* self = (const Nuclear::NuclearBuffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetTick'", NULL);
#endif
  {
   int tolua_ret = (int)  self->GetTick();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTick'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPSinCos */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPSinCos00
static int tolua_engineWin32_Nuclear_XPSinCos00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float radian = ((float)  tolua_tonumber(tolua_S,1,0));
  float sin = ((float)  tolua_tonumber(tolua_S,2,0));
  float cos = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::XPSinCos(radian,&sin,&cos);
   tolua_pushnumber(tolua_S,(lua_Number)sin);
   tolua_pushnumber(tolua_S,(lua_Number)cos);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPSinCos'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::TORADIANS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_TORADIANS00
static int tolua_engineWin32_Nuclear_TORADIANS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float p = ((float)  tolua_tonumber(tolua_S,1,0));
  {
   float tolua_ret = (float)  Nuclear::TORADIANS(p);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TORADIANS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::TOANGLE */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_TOANGLE00
static int tolua_engineWin32_Nuclear_TOANGLE00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float r = ((float)  tolua_tonumber(tolua_S,1,0));
  {
   float tolua_ret = (float)  Nuclear::TOANGLE(r);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TOANGLE'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPSIN */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPSIN00
static int tolua_engineWin32_Nuclear_XPSIN00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int angle = ((int)  tolua_tonumber(tolua_S,1,0));
  {
   float tolua_ret = (float)  Nuclear::XPSIN(angle);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPSIN'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPCOS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPCOS00
static int tolua_engineWin32_Nuclear_XPCOS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int angle = ((int)  tolua_tonumber(tolua_S,1,0));
  {
   float tolua_ret = (float)  Nuclear::XPCOS(angle);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPCOS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::GetGreatestDenominator */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GetGreatestDenominator00
static int tolua_engineWin32_Nuclear_GetGreatestDenominator00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int a1 = ((int)  tolua_tonumber(tolua_S,1,0));
  int a2 = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   int tolua_ret = (int)  Nuclear::GetGreatestDenominator(a1,a2);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetGreatestDenominator'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::GetLowestComMultiple */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GetLowestComMultiple00
static int tolua_engineWin32_Nuclear_GetLowestComMultiple00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int a1 = ((int)  tolua_tonumber(tolua_S,1,0));
  int a2 = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   int tolua_ret = (int)  Nuclear::GetLowestComMultiple(a1,a2);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLowestComMultiple'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::Cross */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Cross00
static int tolua_engineWin32_Nuclear_Cross00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const POINT",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const POINT",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const POINT* pt1 = ((const POINT*)  tolua_tousertype(tolua_S,1,0));
  const POINT* pt2 = ((const POINT*)  tolua_tousertype(tolua_S,2,0));
  {
   int tolua_ret = (int)  Nuclear::Cross(*pt1,*pt2);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cross'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::IsCross */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IsCross00
static int tolua_engineWin32_Nuclear_IsCross00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearPoint* p1 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearPoint* p2 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearPoint* q1 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  const Nuclear::NuclearPoint* q2 = ((const Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,4,0));
  {
   bool tolua_ret = (bool)  Nuclear::IsCross(*p1,*p2,*q1,*q2);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsCross'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPVec3TransformCoord */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPVec3TransformCoord00
static int tolua_engineWin32_Nuclear_XPVec3TransformCoord00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
   Nuclear::NuclearFPoint* pOut = ((  Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pV = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearMatrix3* pM = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,3,0));
  {
    Nuclear::NuclearFPoint* tolua_ret = (  Nuclear::NuclearFPoint*)  Nuclear::XPVec3TransformCoord(pOut,pV,pM);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPVec3TransformCoord'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPVec3TransformNormal */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPVec3TransformNormal00
static int tolua_engineWin32_Nuclear_XPVec3TransformNormal00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,3,"const Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
   Nuclear::NuclearFPoint* pOut = ((  Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pV = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  const Nuclear::NuclearMatrix3* pM = ((const Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,3,0));
  {
    Nuclear::NuclearFPoint* tolua_ret = (  Nuclear::NuclearFPoint*)  Nuclear::XPVec3TransformNormal(pOut,pV,pM);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearFPoint");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPVec3TransformNormal'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixZero */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixZero00
static int tolua_engineWin32_Nuclear_XPMatrixZero00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixZero(pOut);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixZero'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixIdentity */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixIdentity00
static int tolua_engineWin32_Nuclear_XPMatrixIdentity00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixIdentity(pOut);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixIdentity'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixRotationPoint */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixRotationPoint00
static int tolua_engineWin32_Nuclear_XPMatrixRotationPoint00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float radian = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixRotationPoint(pOut,pP,radian);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixRotationPoint'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixRotationOrigin */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixRotationOrigin00
static int tolua_engineWin32_Nuclear_XPMatrixRotationOrigin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  float radian = ((float)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixRotationOrigin(pOut,radian);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixRotationOrigin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixTranslation */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixTranslation00
static int tolua_engineWin32_Nuclear_XPMatrixTranslation00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  float x = ((float)  tolua_tonumber(tolua_S,2,0));
  float y = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixTranslation(pOut,x,y);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixTranslation'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixTranslation */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixTranslation01
static int tolua_engineWin32_Nuclear_XPMatrixTranslation01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixTranslation(pOut,pP);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_XPMatrixTranslation00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixShearX */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixShearX00
static int tolua_engineWin32_Nuclear_XPMatrixShearX00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float s = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixShearX(pOut,pP,s);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixShearX'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixShearX */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixShearX01
static int tolua_engineWin32_Nuclear_XPMatrixShearX01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  float s = ((float)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixShearX(pOut,s);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_XPMatrixShearX00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixShearY */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixShearY00
static int tolua_engineWin32_Nuclear_XPMatrixShearY00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float s = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixShearY(pOut,pP,s);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixShearY'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixShearY */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixShearY01
static int tolua_engineWin32_Nuclear_XPMatrixShearY01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  float s = ((float)  tolua_tonumber(tolua_S,2,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixShearY(pOut,s);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_XPMatrixShearY00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixScaling */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixScaling00
static int tolua_engineWin32_Nuclear_XPMatrixScaling00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* pP = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  float sx = ((float)  tolua_tonumber(tolua_S,3,0));
  float sy = ((float)  tolua_tonumber(tolua_S,4,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixScaling(pOut,pP,sx,sy);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixScaling'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixScaling */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixScaling01
static int tolua_engineWin32_Nuclear_XPMatrixScaling01(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  float sx = ((float)  tolua_tonumber(tolua_S,2,0));
  float sy = ((float)  tolua_tonumber(tolua_S,3,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixScaling(pOut,sx,sy);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
tolua_lerror:
 return tolua_engineWin32_Nuclear_XPMatrixScaling00(tolua_S);
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::XPMatrixMirrorY */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_XPMatrixMirrorY00
static int tolua_engineWin32_Nuclear_XPMatrixMirrorY00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"Nuclear::NuclearMatrix3",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  Nuclear::NuclearMatrix3* pOut = ((Nuclear::NuclearMatrix3*)  tolua_tousertype(tolua_S,1,0));
  {
   Nuclear::NuclearMatrix3* tolua_ret = (Nuclear::NuclearMatrix3*)  Nuclear::XPMatrixMirrorY(pOut);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Nuclear::NuclearMatrix3");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'XPMatrixMirrorY'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::GetMaxRect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_GetMaxRect00
static int tolua_engineWin32_Nuclear_GetMaxRect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const RECT",0,&tolua_err)) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const RECT* r = ((const RECT*)  tolua_tousertype(tolua_S,1,0));
  float s = ((float)  tolua_tonumber(tolua_S,2,0));
  {
   RECT tolua_ret = (RECT)  Nuclear::GetMaxRect(*r,s);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((RECT)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"RECT");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(RECT));
     tolua_pushusertype(tolua_S,tolua_obj,"RECT");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMaxRect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::IsPower2 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_IsPower200
static int tolua_engineWin32_Nuclear_IsPower200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int i = ((int)  tolua_tonumber(tolua_S,1,0));
  {
   bool tolua_ret = (bool)  Nuclear::IsPower2(i);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsPower2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::PartitionRectToPower2 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_PartitionRectToPower200
static int tolua_engineWin32_Nuclear_PartitionRectToPower200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearRect",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"std::vector<Nuclear::NuclearRect>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearRect* src = ((const Nuclear::NuclearRect*)  tolua_tousertype(tolua_S,1,0));
  std::vector<Nuclear::NuclearRect>* dst = ((std::vector<Nuclear::NuclearRect>*)  tolua_tousertype(tolua_S,2,0));
  {
   bool tolua_ret = (bool)  Nuclear::PartitionRectToPower2(*src,*dst);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PartitionRectToPower2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::TransToDiamondRadix */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_TransToDiamondRadix00
static int tolua_engineWin32_Nuclear_TransToDiamondRadix00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"Nuclear::NuclearPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int x = ((int)  tolua_tonumber(tolua_S,1,0));
  int y = ((int)  tolua_tonumber(tolua_S,2,0));
  Nuclear::NuclearPoint* pointInDiamonRadix = ((Nuclear::NuclearPoint*)  tolua_tousertype(tolua_S,3,0));
  {
   Nuclear::TransToDiamondRadix(x,y,*pointInDiamonRadix);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TransToDiamondRadix'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::distance */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_distance00
static int tolua_engineWin32_Nuclear_distance00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* from = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* to = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   float tolua_ret = (float)  Nuclear::distance(*from,*to);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'distance'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::distance2 */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_distance200
static int tolua_engineWin32_Nuclear_distance200(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* from = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* to = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   float tolua_ret = (float)  Nuclear::distance2(*from,*to);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'distance2'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::DotProduct */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_DotProduct00
static int tolua_engineWin32_Nuclear_DotProduct00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* v0 = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* v1 = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   float tolua_ret = (float)  Nuclear::DotProduct(*v0,*v1);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DotProduct'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::VectorLength */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_VectorLength00
static int tolua_engineWin32_Nuclear_VectorLength00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* v = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  {
   float tolua_ret = (float)  Nuclear::VectorLength(*v);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'VectorLength'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: Nuclear::Computer2VectorAngle */
#ifndef TOLUA_DISABLE_tolua_engineWin32_Nuclear_Computer2VectorAngle00
static int tolua_engineWin32_Nuclear_Computer2VectorAngle00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Nuclear::NuclearFPoint",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const Nuclear::NuclearFPoint* v1 = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,1,0));
  const Nuclear::NuclearFPoint* v2 = ((const Nuclear::NuclearFPoint*)  tolua_tousertype(tolua_S,2,0));
  {
   float tolua_ret = (float)  Nuclear::Computer2VectorAngle(*v1,*v2);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Computer2VectorAngle'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  LJFM::LJFMFS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFS_new00
static int tolua_engineWin32_LJFM_LJFMFS_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMFS",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LJFM::LJFMBF",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMBF* file = ((LJFM::LJFMBF*)  tolua_tousertype(tolua_S,2,0));
  {
   LJFM::LJFMFS* tolua_ret = (LJFM::LJFMFS*)  Mtolua_new((LJFM::LJFMFS)(*file));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMFS");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  LJFM::LJFMFS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFS_new00_local
static int tolua_engineWin32_LJFM_LJFMFS_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMFS",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LJFM::LJFMBF",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMBF* file = ((LJFM::LJFMBF*)  tolua_tousertype(tolua_S,2,0));
  {
   LJFM::LJFMFS* tolua_ret = (LJFM::LJFMFS*)  Mtolua_new((LJFM::LJFMFS)(*file));
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMFS");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  LJFM::LJFMFS */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFS_delete00
static int tolua_engineWin32_LJFM_LJFMFS_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMFS",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMFS* self = (LJFM::LJFMFS*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  LJFM::LJFMIF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMIF_new00
static int tolua_engineWin32_LJFM_LJFMIF_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMIF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   LJFM::LJFMIF* tolua_ret = (LJFM::LJFMIF*)  Mtolua_new((LJFM::LJFMIF)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMIF");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  LJFM::LJFMIF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMIF_new00_local
static int tolua_engineWin32_LJFM_LJFMIF_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMIF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   LJFM::LJFMIF* tolua_ret = (LJFM::LJFMIF*)  Mtolua_new((LJFM::LJFMIF)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMIF");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: delete of class  LJFM::LJFMIF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMIF_delete00
static int tolua_engineWin32_LJFM_LJFMIF_delete00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMIF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMIF* self = (LJFM::LJFMIF*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'delete'", NULL);
#endif
  Mtolua_delete(self);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'delete'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetLJFMFSManager of class  LJFM::LJFMFSManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFSManager_GetLJFMFSManager00
static int tolua_engineWin32_LJFM_LJFMFSManager_GetLJFMFSManager00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMFSManager",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   LJFM::LJFMFSManager* tolua_ret = (LJFM::LJFMFSManager*)  LJFM::LJFMFSManager::GetLJFMFSManager();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMFSManager");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetLJFMFSManager'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetFSPtr of class  LJFM::LJFMFSManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFSManager_GetFSPtr00
static int tolua_engineWin32_LJFM_LJFMFSManager_GetFSPtr00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMFSManager",0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"LJFM::LJFMBF",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMFSManager* self = (LJFM::LJFMFSManager*)  tolua_tousertype(tolua_S,1,0);
  LJFM::LJFMBF* tolua_var_3 = ((LJFM::LJFMBF*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'GetFSPtr'", NULL);
#endif
  {
   LJFM::LJFMFS* tolua_ret = (LJFM::LJFMFS*)  self->GetFSPtr(*tolua_var_3);
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMFS");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetFSPtr'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: ReleaseFSPtr of class  LJFM::LJFMFSManager */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMFSManager_ReleaseFSPtr00
static int tolua_engineWin32_LJFM_LJFMFSManager_ReleaseFSPtr00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMFSManager",0,&tolua_err) ||
     !tolua_isusertype(tolua_S,2,"LJFM::LJFMFS",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMFSManager* self = (LJFM::LJFMFSManager*)  tolua_tousertype(tolua_S,1,0);
  LJFM::LJFMFS* tolua_var_4 = ((LJFM::LJFMFS*)  tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ReleaseFSPtr'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->ReleaseFSPtr(tolua_var_4);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ReleaseFSPtr'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new of class  LJFM::LJFMF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMF_new00
static int tolua_engineWin32_LJFM_LJFMF_new00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   LJFM::LJFMF* tolua_ret = (LJFM::LJFMF*)  Mtolua_new((LJFM::LJFMF)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMF");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: new_local of class  LJFM::LJFMF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMF_new00_local
static int tolua_engineWin32_LJFM_LJFMF_new00_local(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   LJFM::LJFMF* tolua_ret = (LJFM::LJFMF*)  Mtolua_new((LJFM::LJFMF)());
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"LJFM::LJFMF");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'new'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Open of class  LJFM::LJFMF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMF_Open00
static int tolua_engineWin32_LJFM_LJFMF_Open00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* self = (LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0);
  const std::wstring filename = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  LJFM::FILE_MODE fm = ((LJFM::FILE_MODE) (int)  tolua_tonumber(tolua_S,3,0));
  LJFM::FILE_ACCESS fa = ((LJFM::FILE_ACCESS) (int)  tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Open'", NULL);
#endif
  {
   bool tolua_ret = (bool)  self->Open(filename,fm,fa);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)filename);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Open'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: Close of class  LJFM::LJFMF */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LJFMF_Close00
static int tolua_engineWin32_LJFM_LJFMF_Close00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* self = (LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Close'", NULL);
#endif
  {
   self->Close();
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Close'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::ShortValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_ShortValueFromTable00
static int tolua_engineWin32_LJFM_ShortValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   int tolua_ret = (int)  LJFM::ShortValueFromTable(fp,iStatus);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShortValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::IntValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_IntValueFromTable00
static int tolua_engineWin32_LJFM_IntValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   int tolua_ret = (int)  LJFM::IntValueFromTable(fp,iStatus);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IntValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::LongValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_LongValueFromTable00
static int tolua_engineWin32_LJFM_LongValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   long long tolua_ret = (long long)  LJFM::LongValueFromTable(fp,iStatus);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LongValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::DoubleValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_DoubleValueFromTable00
static int tolua_engineWin32_LJFM_DoubleValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   double tolua_ret = (double)  LJFM::DoubleValueFromTable(fp,iStatus);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DoubleValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::BoolValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_BoolValueFromTable00
static int tolua_engineWin32_LJFM_BoolValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   bool tolua_ret = (bool)  LJFM::BoolValueFromTable(fp,iStatus);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BoolValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::StringValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_StringValueFromTable00
static int tolua_engineWin32_LJFM_StringValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   std::wstring tolua_ret = (std::wstring)  LJFM::StringValueFromTable(fp,iStatus);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StringValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: LJFM::UIntValueFromTable */
#ifndef TOLUA_DISABLE_tolua_engineWin32_LJFM_UIntValueFromTable00
static int tolua_engineWin32_LJFM_UIntValueFromTable00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"LJFM::LJFMF",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  LJFM::LJFMF* fp = ((LJFM::LJFMF*)  tolua_tousertype(tolua_S,1,0));
  int iStatus = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   unsigned int tolua_ret = (unsigned int)  LJFM::UIntValueFromTable(fp,iStatus);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)iStatus);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'UIntValueFromTable'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: read_profile_string of class  IniFile */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IniFile_read_profile_string00
static int tolua_engineWin32_IniFile_read_profile_string00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"IniFile",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
     !tolua_isstring(tolua_S,6,0,&tolua_err) ||
     !tolua_isstring(tolua_S,7,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,8,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* section = ((const char*)  tolua_tostring(tolua_S,2,0));
  const char* key = ((const char*)  tolua_tostring(tolua_S,3,0));
  char* value = ((char*)  tolua_tostring(tolua_S,4,0));
  int size = ((int)  tolua_tonumber(tolua_S,5,0));
  const char* default_value = ((const char*)  tolua_tostring(tolua_S,6,0));
  const char* file = ((const char*)  tolua_tostring(tolua_S,7,0));
  {
   int tolua_ret = (int)  IniFile::read_profile_string(section,key,value,size,default_value,file);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'read_profile_string'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: read_profile_int of class  IniFile */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IniFile_read_profile_int00
static int tolua_engineWin32_IniFile_read_profile_int00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"IniFile",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* section = ((const char*)  tolua_tostring(tolua_S,2,0));
  const char* key = ((const char*)  tolua_tostring(tolua_S,3,0));
  int default_value = ((int)  tolua_tonumber(tolua_S,4,0));
  const char* file = ((const char*)  tolua_tostring(tolua_S,5,0));
  {
   int tolua_ret = (int)  IniFile::read_profile_int(section,key,default_value,file);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'read_profile_int'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: read_profile_float of class  IniFile */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IniFile_read_profile_float00
static int tolua_engineWin32_IniFile_read_profile_float00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"IniFile",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
     !tolua_isstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* section = ((const char*)  tolua_tostring(tolua_S,2,0));
  const char* key = ((const char*)  tolua_tostring(tolua_S,3,0));
  float default_value = ((float)  tolua_tonumber(tolua_S,4,0));
  const char* file = ((const char*)  tolua_tostring(tolua_S,5,0));
  {
   int tolua_ret = (int)  IniFile::read_profile_float(section,key,default_value,file);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'read_profile_float'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: write_profile_string of class  IniFile */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IniFile_write_profile_string00
static int tolua_engineWin32_IniFile_write_profile_string00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"IniFile",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isstring(tolua_S,4,0,&tolua_err) ||
     !tolua_isstring(tolua_S,5,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,6,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* section = ((const char*)  tolua_tostring(tolua_S,2,0));
  const char* key = ((const char*)  tolua_tostring(tolua_S,3,0));
  const char* value = ((const char*)  tolua_tostring(tolua_S,4,0));
  const char* file = ((const char*)  tolua_tostring(tolua_S,5,0));
  {
   int tolua_ret = (int)  IniFile::write_profile_string(section,key,value,file);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'write_profile_string'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: getCfgFilename of class  IniFile */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IniFile_getCfgFilename00
static int tolua_engineWin32_IniFile_getCfgFilename00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"IniFile",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   std::string tolua_ret = (std::string)  IniFile::getCfgFilename();
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'getCfgFilename'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetRootDir of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetRootDir00
static int tolua_engineWin32_CFileUtil_GetRootDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   std::string tolua_ret = (std::string)  CFileUtil::GetRootDir();
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetRootDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: MakePath of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_MakePath00
static int tolua_engineWin32_CFileUtil_MakePath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* aPathPrefix = ((const char*)  tolua_tostring(tolua_S,2,0));
  const char* aPathSubfix = ((const char*)  tolua_tostring(tolua_S,3,0));
  {
   std::string tolua_ret = (std::string)  CFileUtil::MakePath(aPathPrefix,aPathSubfix);
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MakePath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetDocDir of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetDocDir00
static int tolua_engineWin32_CFileUtil_GetDocDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   std::string tolua_ret = (std::string)  CFileUtil::GetDocDir();
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDocDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetCacheDir of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetCacheDir00
static int tolua_engineWin32_CFileUtil_GetCacheDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   std::string tolua_ret = (std::string)  CFileUtil::GetCacheDir();
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCacheDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTempDir of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetTempDir00
static int tolua_engineWin32_CFileUtil_GetTempDir00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   std::string tolua_ret = (std::string)  CFileUtil::GetTempDir();
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTempDir'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: IsCurLanguageSimpleCh of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_IsCurLanguageSimpleCh00
static int tolua_engineWin32_CFileUtil_IsCurLanguageSimpleCh00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   bool tolua_ret = (bool)  CFileUtil::IsCurLanguageSimpleCh();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsCurLanguageSimpleCh'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetTotalMemory of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetTotalMemory00
static int tolua_engineWin32_CFileUtil_GetTotalMemory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   double tolua_ret = (double)  CFileUtil::GetTotalMemory();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTotalMemory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetAvailableMemory of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetAvailableMemory00
static int tolua_engineWin32_CFileUtil_GetAvailableMemory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   double tolua_ret = (double)  CFileUtil::GetAvailableMemory();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetAvailableMemory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: GetUsedMemory of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_GetUsedMemory00
static int tolua_engineWin32_CFileUtil_GetUsedMemory00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   double tolua_ret = (double)  CFileUtil::GetUsedMemory();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetUsedMemory'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: CopyFileByFS of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_CopyFileByFS00
static int tolua_engineWin32_CFileUtil_CopyFileByFS00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  std::wstring Src = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  std::wstring Dst = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  {
   int tolua_ret = (int)  CFileUtil::CopyFileByFS(Src,Dst);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CopyFileByFS'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: DelFileArrOfPath of class  CFileUtil */
#ifndef TOLUA_DISABLE_tolua_engineWin32_CFileUtil_DelFileArrOfPath00
static int tolua_engineWin32_CFileUtil_DelFileArrOfPath00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"CFileUtil",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  std::wstring wsBasePath = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  std::wstring wsFileType = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  bool bLoop = ((bool)  tolua_toboolean(tolua_S,4,0));
  {
   int tolua_ret = (int)  CFileUtil::DelFileArrOfPath(wsBasePath,wsFileType,bLoop);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DelFileArrOfPath'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: IOS_MHSD_UTILS::OpenURL */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IOS_MHSD_UTILS_OpenURL00
static int tolua_engineWin32_IOS_MHSD_UTILS_OpenURL00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_iscppstring(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const std::string urlstring = ((const std::string)  tolua_tocppstring(tolua_S,1,0));
  {
   IOS_MHSD_UTILS::OpenURL(urlstring);
   tolua_pushcppstring(tolua_S,(const char*)urlstring);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OpenURL'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: IOS_MHSD_UTILS::GetCurBrightness */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IOS_MHSD_UTILS_GetCurBrightness00
static int tolua_engineWin32_IOS_MHSD_UTILS_GetCurBrightness00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnoobj(tolua_S,1,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   float tolua_ret = (float)  IOS_MHSD_UTILS::GetCurBrightness();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCurBrightness'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: IOS_MHSD_UTILS::SetCurBrightness */
#ifndef TOLUA_DISABLE_tolua_engineWin32_IOS_MHSD_UTILS_SetCurBrightness00
static int tolua_engineWin32_IOS_MHSD_UTILS_SetCurBrightness00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float brightness = ((float)  tolua_tonumber(tolua_S,1,0));
  {
   IOS_MHSD_UTILS::SetCurBrightness(brightness);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCurBrightness'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: setLoggingLevel of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_setLoggingLevel00
static int tolua_engineWin32_core_Logger_setLoggingLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  core::Logger* self = (core::Logger*)  tolua_tousertype(tolua_S,1,0);
  core::LoggingLevel level = ((core::LoggingLevel) (int)  tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setLoggingLevel'", NULL);
#endif
  {
   self->setLoggingLevel(level);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'setLoggingLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: getLoggingLevel of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_getLoggingLevel00
static int tolua_engineWin32_core_Logger_getLoggingLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  core::Logger* self = (core::Logger*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getLoggingLevel'", NULL);
#endif
  {
   core::LoggingLevel tolua_ret = (core::LoggingLevel)  self->getLoggingLevel();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'getLoggingLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: logLuaEvent of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_logLuaEvent00
static int tolua_engineWin32_core_Logger_logLuaEvent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  core::Logger* self = (core::Logger*)  tolua_tousertype(tolua_S,1,0);
  core::LoggingLevel level = ((core::LoggingLevel) (int)  tolua_tonumber(tolua_S,2,0));
  std::wstring message = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'logLuaEvent'", NULL);
#endif
  {
   self->logLuaEvent(level,message);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'logLuaEvent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: flurryEvent of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_flurryEvent00
static int tolua_engineWin32_core_Logger_flurryEvent00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertable(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  std::wstring s = ((std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  bool once = ((bool)  tolua_toboolean(tolua_S,3,false));
  {
   core::Logger::flurryEvent(s,once);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'flurryEvent'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: AddPassLevel of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_AddPassLevel00
static int tolua_engineWin32_core_Logger_AddPassLevel00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  core::Logger* self = (core::Logger*)  tolua_tousertype(tolua_S,1,0);
  int PassLevel = ((int)  tolua_tonumber(tolua_S,2,0));
  std::wstring PassLevelCaption = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AddPassLevel'", NULL);
#endif
  {
   int tolua_ret = (int)  self->AddPassLevel(PassLevel,PassLevelCaption);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddPassLevel'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* method: logLuaEventInt of class  core::Logger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_Logger_logLuaEventInt00
static int tolua_engineWin32_core_Logger_logLuaEventInt00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isusertype(tolua_S,1,"core::Logger",0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  core::Logger* self = (core::Logger*)  tolua_tousertype(tolua_S,1,0);
  int level = ((int)  tolua_tonumber(tolua_S,2,0));
  std::wstring message = ((std::wstring)  tolua_tocppwstring(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'logLuaEventInt'", NULL);
#endif
  {
   self->logLuaEventInt(level,message);
  }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'logLuaEventInt'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: core::GetCoreLogger */
#ifndef TOLUA_DISABLE_tolua_engineWin32_core_GetCoreLogger00
static int tolua_engineWin32_core_GetCoreLogger00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnoobj(tolua_S,1,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  {
   core::Logger* tolua_ret = (core::Logger*)  core::GetCoreLogger();
    tolua_pushusertype(tolua_S,(void*)tolua_ret,"core::Logger");
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCoreLogger'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::randBetween */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_randBetween00
static int tolua_engineWin32_StringCover_randBetween00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int a = ((int)  tolua_tonumber(tolua_S,1,0));
  int b = ((int)  tolua_tonumber(tolua_S,2,0));
  {
   int tolua_ret = (int)  StringCover::randBetween(a,b);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'randBetween'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::int64_tToPrecisionTime */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_int64_tToPrecisionTime00
static int tolua_engineWin32_StringCover_int64_tToPrecisionTime00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int64_t time = ((int64_t)  tolua_tonumber(tolua_S,1,0));
  {
   std::wstring tolua_ret = (std::wstring)  StringCover::int64_tToPrecisionTime(time);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'int64_tToPrecisionTime'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::StringToOctect */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_StringToOctect00
static int tolua_engineWin32_StringCover_StringToOctect00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isstring(tolua_S,1,0,&tolua_err) ||
     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const char* str = ((const char*)  tolua_tostring(tolua_S,1,0));
  const int length = ((const int)  tolua_tonumber(tolua_S,2,0));
  {
   FireNet::Octets tolua_ret = (FireNet::Octets)  StringCover::StringToOctect(str,length);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((FireNet::Octets)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"FireNet::Octets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(FireNet::Octets));
     tolua_pushusertype(tolua_S,tolua_obj,"FireNet::Octets");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StringToOctect'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::OctectToWString */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_OctectToWString00
static int tolua_engineWin32_StringCover_OctectToWString00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     (tolua_isvaluenil(tolua_S,1,&tolua_err) || !tolua_isusertype(tolua_S,1,"const FireNet::Octets",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const FireNet::Octets* oct = ((const FireNet::Octets*)  tolua_tousertype(tolua_S,1,0));
  {
   std::wstring tolua_ret = (std::wstring)  StringCover::OctectToWString(*oct);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OctectToWString'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::getTimeStruct */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_getTimeStruct00
static int tolua_engineWin32_StringCover_getTimeStruct00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  long time = ((long)  tolua_tonumber(tolua_S,1,0));
  {
   tm tolua_ret = (tm)  StringCover::getTimeStruct(time);
   {
#ifdef __cplusplus
    void* tolua_obj = Mtolua_new((tm)(tolua_ret));
     tolua_pushusertype(tolua_S,tolua_obj,"tm");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#else
    void* tolua_obj = tolua_copy(tolua_S,(void*)&tolua_ret,sizeof(tm));
     tolua_pushusertype(tolua_S,tolua_obj,"tm");
    tolua_register_gc(tolua_S,lua_gettop(tolua_S));
#endif
   }
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'getTimeStruct'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::intToString */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_intToString00
static int tolua_engineWin32_StringCover_intToString00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int val = ((int)  tolua_tonumber(tolua_S,1,0));
  {
   std::string tolua_ret = (std::string)  StringCover::intToString(val);
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'intToString'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::floatToString */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_floatToString00
static int tolua_engineWin32_StringCover_floatToString00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  float val = ((float)  tolua_tonumber(tolua_S,1,0));
  {
   std::string tolua_ret = (std::string)  StringCover::floatToString(val);
   tolua_pushcppstring(tolua_S,(const char*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'floatToString'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::Replace */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_Replace00
static int tolua_engineWin32_StringCover_Replace00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_iscppwstring(tolua_S,1,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,3,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const std::wstring orignStr = ((const std::wstring)  tolua_tocppwstring(tolua_S,1,0));
  const std::wstring oldStr = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  const std::wstring newStr = ((const std::wstring)  tolua_tocppwstring(tolua_S,3,0));
  {
   std::wstring tolua_ret = (std::wstring)  StringCover::Replace(orignStr,oldStr,newStr);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)orignStr);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)oldStr);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)newStr);
  }
 }
 return 4;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Replace'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::split_string */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_split_string00
static int tolua_engineWin32_StringCover_split_string00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_iscppwstring(tolua_S,1,0,&tolua_err) ||
     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const std::vector<std::wstring>",0,&tolua_err)) ||
     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"std::vector<std::wstring>",0,&tolua_err)) ||
     !tolua_isnoobj(tolua_S,4,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const std::wstring inputstr = ((const std::wstring)  tolua_tocppwstring(tolua_S,1,0));
  const std::vector<std::wstring>* delimiters = ((const std::vector<std::wstring>*)  tolua_tousertype(tolua_S,2,0));
  std::vector<std::wstring>* substrs = ((std::vector<std::wstring>*)  tolua_tousertype(tolua_S,3,0));
  {
   int tolua_ret = (int)  StringCover::split_string(inputstr,*delimiters,*substrs);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)inputstr);
  }
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'split_string'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::intTowstring */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_intTowstring00
static int tolua_engineWin32_StringCover_intTowstring00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,2,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  int num = ((int)  tolua_tonumber(tolua_S,1,0));
  {
   std::wstring tolua_ret = (std::wstring)  StringCover::intTowstring(num);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)tolua_ret);
  }
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'intTowstring'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* function: StringCover::strcmpByPinyin */
#ifndef TOLUA_DISABLE_tolua_engineWin32_StringCover_strcmpByPinyin00
static int tolua_engineWin32_StringCover_strcmpByPinyin00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
     !tolua_iscppwstring(tolua_S,1,0,&tolua_err) ||
     !tolua_iscppwstring(tolua_S,2,0,&tolua_err) ||
     !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
  goto tolua_lerror;
 else
#endif
 {
  const std::wstring str1 = ((const std::wstring)  tolua_tocppwstring(tolua_S,1,0));
  const std::wstring str2 = ((const std::wstring)  tolua_tocppwstring(tolua_S,2,0));
  {
   int tolua_ret = (int)  StringCover::strcmpByPinyin(str1,str2);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)str1);
   tolua_pushcppwstring(tolua_S,(const wchar_t*)str2);
  }
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'strcmpByPinyin'.",&tolua_err);
 return 0;
#endif
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_sec of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_sec
static int tolua_get_tm_tm_sec(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_sec'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_sec);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_sec of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_sec
static int tolua_set_tm_tm_sec(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_sec'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_sec = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_min of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_min
static int tolua_get_tm_tm_min(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_min'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_min);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_min of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_min
static int tolua_set_tm_tm_min(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_min'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_min = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_hour of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_hour
static int tolua_get_tm_tm_hour(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_hour'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_hour);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_hour of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_hour
static int tolua_set_tm_tm_hour(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_hour'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_hour = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_mday of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_mday
static int tolua_get_tm_tm_mday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_mday'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_mday);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_mday of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_mday
static int tolua_set_tm_tm_mday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_mday'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_mday = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_mon of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_mon
static int tolua_get_tm_tm_mon(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_mon'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_mon);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_mon of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_mon
static int tolua_set_tm_tm_mon(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_mon'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_mon = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_year of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_year
static int tolua_get_tm_tm_year(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_year'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_year);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_year of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_year
static int tolua_set_tm_tm_year(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_year'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_year = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_wday of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_wday
static int tolua_get_tm_tm_wday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_wday'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_wday);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_wday of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_wday
static int tolua_set_tm_tm_wday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_wday'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_wday = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_yday of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_yday
static int tolua_get_tm_tm_yday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_yday'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_yday);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_yday of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_yday
static int tolua_set_tm_tm_yday(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_yday'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_yday = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* get function: tm_isdst of class  tm */
#ifndef TOLUA_DISABLE_tolua_get_tm_tm_isdst
static int tolua_get_tm_tm_isdst(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_isdst'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->tm_isdst);
 return 1;
}
#endif //#ifndef TOLUA_DISABLE

/* set function: tm_isdst of class  tm */
#ifndef TOLUA_DISABLE_tolua_set_tm_tm_isdst
static int tolua_set_tm_tm_isdst(lua_State* tolua_S)
{
  tm* self = (tm*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tm_isdst'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err))
   tolua_error(tolua_S,"#vinvalid type in variable assignment.",&tolua_err);
#endif
  self->tm_isdst = ((int)  tolua_tonumber(tolua_S,2,0))
;
 return 0;
}
#endif //#ifndef TOLUA_DISABLE

/* Open function */
TOLUA_API int tolua_engineWin32_open (lua_State* tolua_S)
{
 tolua_open(tolua_S);
 tolua_reg_types(tolua_S);
 tolua_module(tolua_S,NULL,0);
 tolua_beginmodule(tolua_S,NULL);
  tolua_cclass(tolua_S,"POINT","POINT","",NULL);
  tolua_beginmodule(tolua_S,"POINT");
   tolua_variable(tolua_S,"x",tolua_get_POINT_x,tolua_set_POINT_x);
   tolua_variable(tolua_S,"y",tolua_get_POINT_y,tolua_set_POINT_y);
  tolua_endmodule(tolua_S);
  #ifdef __cplusplus
  tolua_cclass(tolua_S,"RECT","RECT","",tolua_collect_RECT);
  #else
  tolua_cclass(tolua_S,"RECT","RECT","",NULL);
  #endif
  tolua_beginmodule(tolua_S,"RECT");
   tolua_variable(tolua_S,"left",tolua_get_RECT_left,tolua_set_RECT_left);
   tolua_variable(tolua_S,"top",tolua_get_RECT_top,tolua_set_RECT_top);
   tolua_variable(tolua_S,"right",tolua_get_RECT_right,tolua_set_RECT_right);
   tolua_variable(tolua_S,"bottom",tolua_get_RECT_bottom,tolua_set_RECT_bottom);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_constant(tolua_S,"XPDIR_TOP",Nuclear::XPDIR_TOP);
   tolua_constant(tolua_S,"XPDIR_TOPRIGHT",Nuclear::XPDIR_TOPRIGHT);
   tolua_constant(tolua_S,"XPDIR_RIGHT",Nuclear::XPDIR_RIGHT);
   tolua_constant(tolua_S,"XPDIR_BOTTOMRIGHT",Nuclear::XPDIR_BOTTOMRIGHT);
   tolua_constant(tolua_S,"XPDIR_BOTTOM",Nuclear::XPDIR_BOTTOM);
   tolua_constant(tolua_S,"XPDIR_BOTTOMLEFT",Nuclear::XPDIR_BOTTOMLEFT);
   tolua_constant(tolua_S,"XPDIR_LEFT",Nuclear::XPDIR_LEFT);
   tolua_constant(tolua_S,"XPDIR_TOPLEFT",Nuclear::XPDIR_TOPLEFT);
   tolua_constant(tolua_S,"XPDIR_COUNT",Nuclear::XPDIR_COUNT);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearFPoint","Nuclear::NuclearFPoint","",tolua_collect_Nuclear__NuclearFPoint);
   #else
   tolua_cclass(tolua_S,"NuclearFPoint","Nuclear::NuclearFPoint","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearFPoint");
    tolua_variable(tolua_S,"x",tolua_get_Nuclear__NuclearFPoint_x,tolua_set_Nuclear__NuclearFPoint_x);
    tolua_variable(tolua_S,"y",tolua_get_Nuclear__NuclearFPoint_y,tolua_set_Nuclear__NuclearFPoint_y);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFPoint_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFPoint_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFPoint_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFPoint_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFPoint_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFPoint_new01_local);
    tolua_function(tolua_S,".add",tolua_engineWin32_Nuclear_NuclearFPoint__add00);
    tolua_function(tolua_S,".sub",tolua_engineWin32_Nuclear_NuclearFPoint__sub00);
    tolua_function(tolua_S,".mul",tolua_engineWin32_Nuclear_NuclearFPoint__mul00);
    tolua_function(tolua_S,".div",tolua_engineWin32_Nuclear_NuclearFPoint__div00);
    tolua_function(tolua_S,".eq",tolua_engineWin32_Nuclear_NuclearFPoint__eq00);
    tolua_function(tolua_S,"Dis2",tolua_engineWin32_Nuclear_NuclearFPoint_Dis200);
    tolua_function(tolua_S,"isInPolygon",tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon00);
    tolua_function(tolua_S,"isInTriangle",tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFPoint_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFPoint_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFPoint_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFPoint_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFPoint_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFPoint_new03_local);
    tolua_function(tolua_S,"Dis2",tolua_engineWin32_Nuclear_NuclearFPoint_Dis201);
    tolua_function(tolua_S,"angleBetween",tolua_engineWin32_Nuclear_NuclearFPoint_angleBetween00);
    tolua_function(tolua_S,"isInPolygon",tolua_engineWin32_Nuclear_NuclearFPoint_isInPolygon01);
    tolua_function(tolua_S,"isInTriangle",tolua_engineWin32_Nuclear_NuclearFPoint_isInTriangle01);
    tolua_function(tolua_S,"normalize",tolua_engineWin32_Nuclear_NuclearFPoint_normalize00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearPoint","Nuclear::NuclearPoint","POINT",tolua_collect_Nuclear__NuclearPoint);
   #else
   tolua_cclass(tolua_S,"NuclearPoint","Nuclear::NuclearPoint","POINT",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearPoint");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new02_local);
    tolua_function(tolua_S,".sub",tolua_engineWin32_Nuclear_NuclearPoint__sub00);
    tolua_function(tolua_S,".add",tolua_engineWin32_Nuclear_NuclearPoint__add00);
    tolua_function(tolua_S,"Dis2",tolua_engineWin32_Nuclear_NuclearPoint_Dis200);
    tolua_function(tolua_S,"ToFPOINT",tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new03_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new04);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new04_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new04_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPoint_new05);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPoint_new05_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPoint_new05_local);
    tolua_function(tolua_S,"Dis2",tolua_engineWin32_Nuclear_NuclearPoint_Dis201);
    tolua_function(tolua_S,"ToFPOINT",tolua_engineWin32_Nuclear_NuclearPoint_ToFPOINT01);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPEARR_RESREADY",Nuclear::XPEARR_RESREADY);
   tolua_constant(tolua_S,"XPEARR_LOADING",Nuclear::XPEARR_LOADING);
   tolua_constant(tolua_S,"XPEARR_LOAD_ERROR",Nuclear::XPEARR_LOAD_ERROR);
   tolua_constant(tolua_S,"XPEST_NOSCALE",Nuclear::XPEST_NOSCALE);
   tolua_constant(tolua_S,"XPEST_ONLY_SCALE_POS",Nuclear::XPEST_ONLY_SCALE_POS);
   tolua_constant(tolua_S,"XPEST_ALLSCALE",Nuclear::XPEST_ALLSCALE);
   tolua_constant(tolua_S,"XPES_PLAYING",Nuclear::XPES_PLAYING);
   tolua_constant(tolua_S,"XPES_PAUSE",Nuclear::XPES_PAUSE);
   tolua_constant(tolua_S,"XPES_STOP",Nuclear::XPES_STOP);
   tolua_constant(tolua_S,"XPES_EMPTY",Nuclear::XPES_EMPTY);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearRect","Nuclear::NuclearRect","RECT",tolua_collect_Nuclear__NuclearRect);
   #else
   tolua_cclass(tolua_S,"NuclearRect","Nuclear::NuclearRect","RECT",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearRect");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new02_local);
    tolua_function(tolua_S,"Widen",tolua_engineWin32_Nuclear_NuclearRect_Widen00);
    tolua_function(tolua_S,"Union",tolua_engineWin32_Nuclear_NuclearRect_Union00);
    tolua_function(tolua_S,"GetPos",tolua_engineWin32_Nuclear_NuclearRect_GetPos00);
    tolua_function(tolua_S,"Center",tolua_engineWin32_Nuclear_NuclearRect_Center00);
    tolua_function(tolua_S,"ToFRECT",tolua_engineWin32_Nuclear_NuclearRect_ToFRECT00);
    tolua_function(tolua_S,"PtInRect",tolua_engineWin32_Nuclear_NuclearRect_PtInRect00);
    tolua_function(tolua_S,"IsCross",tolua_engineWin32_Nuclear_NuclearRect_IsCross00);
    tolua_function(tolua_S,"Cut",tolua_engineWin32_Nuclear_NuclearRect_Cut00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new03_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new04);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new04_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new04_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearRect_new05);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearRect_new05_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearRect_new05_local);
    tolua_function(tolua_S,"Widen",tolua_engineWin32_Nuclear_NuclearRect_Widen01);
    tolua_function(tolua_S,"Union",tolua_engineWin32_Nuclear_NuclearRect_Union01);
    tolua_function(tolua_S,"GetPos",tolua_engineWin32_Nuclear_NuclearRect_GetPos01);
    tolua_function(tolua_S,"Center",tolua_engineWin32_Nuclear_NuclearRect_Center01);
    tolua_function(tolua_S,"ToFRECT",tolua_engineWin32_Nuclear_NuclearRect_ToFRECT01);
    tolua_function(tolua_S,"Assign",tolua_engineWin32_Nuclear_NuclearRect_Assign00);
    tolua_function(tolua_S,"Width",tolua_engineWin32_Nuclear_NuclearRect_Width00);
    tolua_function(tolua_S,"Height",tolua_engineWin32_Nuclear_NuclearRect_Height00);
    tolua_function(tolua_S,"PtInRect",tolua_engineWin32_Nuclear_NuclearRect_PtInRect01);
    tolua_function(tolua_S,"IsCross",tolua_engineWin32_Nuclear_NuclearRect_IsCross01);
    tolua_function(tolua_S,"Cut",tolua_engineWin32_Nuclear_NuclearRect_Cut01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearVector4","Nuclear::NuclearVector4","",tolua_collect_Nuclear__NuclearVector4);
   #else
   tolua_cclass(tolua_S,"NuclearVector4","Nuclear::NuclearVector4","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearVector4");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearVector4_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearVector4_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearVector4_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearVector4_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearVector4_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearVector4_new01_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearColor","Nuclear::NuclearColor","",tolua_collect_Nuclear__NuclearColor);
   #else
   tolua_cclass(tolua_S,"NuclearColor","Nuclear::NuclearColor","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearColor");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new03_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearColor_Reset00);
    tolua_function(tolua_S,"ToXPVECTOR4",tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR400);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearColor_Reset01);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new04);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new04_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new04_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new05);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new05_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new05_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new06);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new06_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new06_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearColor_new07);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearColor_new07_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearColor_new07_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearColor_Reset02);
    tolua_function(tolua_S,"ToXPVECTOR4",tolua_engineWin32_Nuclear_NuclearColor_ToXPVECTOR401);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearColor_Reset03);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPPM_LOOP",Nuclear::XPPM_LOOP);
   tolua_constant(tolua_S,"XPPM_LOOPNUM",Nuclear::XPPM_LOOPNUM);
   tolua_constant(tolua_S,"XPPM_TIME",Nuclear::XPPM_TIME);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"INuclearRunnable","Nuclear::INuclearRunnable","",tolua_collect_Nuclear__INuclearRunnable);
   #else
   tolua_cclass(tolua_S,"INuclearRunnable","Nuclear::INuclearRunnable","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"INuclearRunnable");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_INuclearRunnable_delete00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearDisplayMode","Nuclear::NuclearDisplayMode","",tolua_collect_Nuclear__NuclearDisplayMode);
   #else
   tolua_cclass(tolua_S,"NuclearDisplayMode","Nuclear::NuclearDisplayMode","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearDisplayMode");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearDisplayMode_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearDisplayMode_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearDisplayMode_new00_local);
    tolua_function(tolua_S,"equalExceptScreenMode",tolua_engineWin32_Nuclear_NuclearDisplayMode_equalExceptScreenMode00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPMULTISAMPLE_NONE",Nuclear::XPMULTISAMPLE_NONE);
   tolua_constant(tolua_S,"XPMULTISAMPLE_2_SAMPLES",Nuclear::XPMULTISAMPLE_2_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_3_SAMPLES",Nuclear::XPMULTISAMPLE_3_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_4_SAMPLES",Nuclear::XPMULTISAMPLE_4_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_5_SAMPLES",Nuclear::XPMULTISAMPLE_5_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_6_SAMPLES",Nuclear::XPMULTISAMPLE_6_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_7_SAMPLES",Nuclear::XPMULTISAMPLE_7_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_8_SAMPLES",Nuclear::XPMULTISAMPLE_8_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_9_SAMPLES",Nuclear::XPMULTISAMPLE_9_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_10_SAMPLES",Nuclear::XPMULTISAMPLE_10_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_11_SAMPLES",Nuclear::XPMULTISAMPLE_11_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_12_SAMPLES",Nuclear::XPMULTISAMPLE_12_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_13_SAMPLES",Nuclear::XPMULTISAMPLE_13_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_14_SAMPLES",Nuclear::XPMULTISAMPLE_14_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_15_SAMPLES",Nuclear::XPMULTISAMPLE_15_SAMPLES);
   tolua_constant(tolua_S,"XPMULTISAMPLE_16_SAMPLES",Nuclear::XPMULTISAMPLE_16_SAMPLES);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"INuclearTimer","Nuclear::INuclearTimer","",tolua_collect_Nuclear__INuclearTimer);
   #else
   tolua_cclass(tolua_S,"INuclearTimer","Nuclear::INuclearTimer","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"INuclearTimer");
    tolua_variable(tolua_S,"m_iTimerID",tolua_get_Nuclear__INuclearTimer_m_iTimerID,tolua_set_Nuclear__INuclearTimer_m_iTimerID);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_INuclearTimer_OnTimer00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_INuclearTimer_delete00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPTEXBM_DEFAULT",Nuclear::XPTEXBM_DEFAULT);
   tolua_constant(tolua_S,"XPTEXBM_MODULATE",Nuclear::XPTEXBM_MODULATE);
   tolua_constant(tolua_S,"XPTEXBM_ADDITIVE",Nuclear::XPTEXBM_ADDITIVE);
   tolua_constant(tolua_S,"XPTEXBM_COPY",Nuclear::XPTEXBM_COPY);
   tolua_constant(tolua_S,"XPTEXBM_ADDITIVE_ALPHA",Nuclear::XPTEXBM_ADDITIVE_ALPHA);
   tolua_constant(tolua_S,"XPTEXBM_MODULATE2X",Nuclear::XPTEXBM_MODULATE2X);
   tolua_constant(tolua_S,"XPTEXBM_ADDITIVE2X",Nuclear::XPTEXBM_ADDITIVE2X);
   tolua_constant(tolua_S,"XPTEXBM_MUTIPLY",Nuclear::XPTEXBM_MUTIPLY);
   tolua_constant(tolua_S,"XPTEXBM_MUTIPLY_ALPHA",Nuclear::XPTEXBM_MUTIPLY_ALPHA);
   tolua_constant(tolua_S,"XPTEXADDRESS_WRAP",Nuclear::XPTEXADDRESS_WRAP);
   tolua_constant(tolua_S,"XPTEXADDRESS_MIRROR",Nuclear::XPTEXADDRESS_MIRROR);
   tolua_constant(tolua_S,"XPTEXADDRESS_CLAMP",Nuclear::XPTEXADDRESS_CLAMP);
   tolua_constant(tolua_S,"XPTEXADDRESS_BORDER",Nuclear::XPTEXADDRESS_BORDER);
   tolua_constant(tolua_S,"XPTEXADDRESS_MIRRORONCE",Nuclear::XPTEXADDRESS_MIRRORONCE);
   tolua_constant(tolua_S,"XPTEXADDRESS_FORCE_DWORD",Nuclear::XPTEXADDRESS_FORCE_DWORD);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearFRectt","Nuclear::NuclearFRectt","",tolua_collect_Nuclear__NuclearFRectt);
   #else
   tolua_cclass(tolua_S,"NuclearFRectt","Nuclear::NuclearFRectt","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearFRectt");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new03_local);
    tolua_function(tolua_S,"Assign",tolua_engineWin32_Nuclear_NuclearFRectt_Assign00);
    tolua_function(tolua_S,"Width",tolua_engineWin32_Nuclear_NuclearFRectt_Width00);
    tolua_function(tolua_S,"Height",tolua_engineWin32_Nuclear_NuclearFRectt_Height00);
    tolua_function(tolua_S,"PtInRect",tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new04);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new04_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new04_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new05);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new05_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new05_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new06);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new06_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new06_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFRectt_new07);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFRectt_new07_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFRectt_new07_local);
    tolua_function(tolua_S,"Assign",tolua_engineWin32_Nuclear_NuclearFRectt_Assign01);
    tolua_function(tolua_S,"Width",tolua_engineWin32_Nuclear_NuclearFRectt_Width01);
    tolua_function(tolua_S,"Height",tolua_engineWin32_Nuclear_NuclearFRectt_Height01);
    tolua_function(tolua_S,"PtInRect",tolua_engineWin32_Nuclear_NuclearFRectt_PtInRect01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearVector3","Nuclear::NuclearVector3","",tolua_collect_Nuclear__NuclearVector3);
   #else
   tolua_cclass(tolua_S,"NuclearVector3","Nuclear::NuclearVector3","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearVector3");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearVector3_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearVector3_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearVector3_new00_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearVector3_Reset00);
    tolua_function(tolua_S,"Add",tolua_engineWin32_Nuclear_NuclearVector3_Add00);
    tolua_function(tolua_S,"Length",tolua_engineWin32_Nuclear_NuclearVector3_Length00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearVector3_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearVector3_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearVector3_new01_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearVector3_Reset01);
    tolua_function(tolua_S,"Add",tolua_engineWin32_Nuclear_NuclearVector3_Add01);
    tolua_function(tolua_S,"Length",tolua_engineWin32_Nuclear_NuclearVector3_Length01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearFColor","Nuclear::NuclearFColor","",tolua_collect_Nuclear__NuclearFColor);
   #else
   tolua_cclass(tolua_S,"NuclearFColor","Nuclear::NuclearFColor","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearFColor");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFColor_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFColor_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFColor_new00_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearFColor_Reset00);
    tolua_function(tolua_S,"ToDWORD",tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFColor_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFColor_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFColor_new01_local);
    tolua_function(tolua_S,"Reset",tolua_engineWin32_Nuclear_NuclearFColor_Reset01);
    tolua_function(tolua_S,"ToDWORD",tolua_engineWin32_Nuclear_NuclearFColor_ToDWORD01);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"NuclearTriangle","Nuclear::NuclearTriangle","",NULL);
   tolua_beginmodule(tolua_S,"NuclearTriangle");
    tolua_function(tolua_S,"PtInTriangle",tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle00);
    tolua_function(tolua_S,"PtInTriangle",tolua_engineWin32_Nuclear_NuclearTriangle_PtInTriangle01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearEllipse","Nuclear::NuclearEllipse","",tolua_collect_Nuclear__NuclearEllipse);
   #else
   tolua_cclass(tolua_S,"NuclearEllipse","Nuclear::NuclearEllipse","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearEllipse");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearEllipse_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearEllipse_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearEllipse_new00_local);
    tolua_function(tolua_S,"PtInEllipse",tolua_engineWin32_Nuclear_NuclearEllipse_PtInEllipse00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearMatrix3","Nuclear::NuclearMatrix3","",tolua_collect_Nuclear__NuclearMatrix3);
   #else
   tolua_cclass(tolua_S,"NuclearMatrix3","Nuclear::NuclearMatrix3","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearMatrix3");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearMatrix3_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearMatrix3_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearMatrix3_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearMatrix3_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearMatrix3_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearMatrix3_new01_local);
    tolua_function(tolua_S,"Translation",tolua_engineWin32_Nuclear_NuclearMatrix3_Translation00);
    tolua_function(tolua_S,"Translation",tolua_engineWin32_Nuclear_NuclearMatrix3_Translation01);
    tolua_function(tolua_S,"inverse",tolua_engineWin32_Nuclear_NuclearMatrix3_inverse00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearMatrix3_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearMatrix3_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearMatrix3_new02_local);
    tolua_function(tolua_S,"Translation",tolua_engineWin32_Nuclear_NuclearMatrix3_Translation02);
    tolua_function(tolua_S,"Translation",tolua_engineWin32_Nuclear_NuclearMatrix3_Translation03);
    tolua_function(tolua_S,"inverse",tolua_engineWin32_Nuclear_NuclearMatrix3_inverse01);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPFM_WIREFRAME",Nuclear::XPFM_WIREFRAME);
   tolua_constant(tolua_S,"XPFM_SOLIDFILL",Nuclear::XPFM_SOLIDFILL);
   tolua_constant(tolua_S,"XPSHAPE_TYPE_CIRCLE",Nuclear::XPSHAPE_TYPE_CIRCLE);
   tolua_constant(tolua_S,"XPSHAPE_TYPE_POLYGON",Nuclear::XPSHAPE_TYPE_POLYGON);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"INuclearShape","Nuclear::INuclearShape","",tolua_collect_Nuclear__INuclearShape);
   #else
   tolua_cclass(tolua_S,"INuclearShape","Nuclear::INuclearShape","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"INuclearShape");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_INuclearShape_delete00);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_INuclearShape_IsPointIn00);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_INuclearShape_DistanceTo00);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_INuclearShape_IsPointIn01);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_INuclearShape_IsPointIn02);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_INuclearShape_DistanceTo01);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_INuclearShape_DistanceTo02);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_INuclearShape_Render00);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_INuclearShape_GetType00);
    tolua_function(tolua_S,"Extension",tolua_engineWin32_Nuclear_INuclearShape_Extension00);
    tolua_function(tolua_S,"IsVaild",tolua_engineWin32_Nuclear_INuclearShape_IsVaild00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearCircle","Nuclear::NuclearCircle","Nuclear::INuclearShape",tolua_collect_Nuclear__NuclearCircle);
   #else
   tolua_cclass(tolua_S,"NuclearCircle","Nuclear::NuclearCircle","Nuclear::INuclearShape",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearCircle");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearCircle_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearCircle_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearCircle_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearCircle_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearCircle_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearCircle_new01_local);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_NuclearCircle_GetType00);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn00);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_NuclearCircle_Render00);
    tolua_function(tolua_S,"Extension",tolua_engineWin32_Nuclear_NuclearCircle_Extension00);
    tolua_function(tolua_S,"IsVaild",tolua_engineWin32_Nuclear_NuclearCircle_IsVaild00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearCircle_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearCircle_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearCircle_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearCircle_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearCircle_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearCircle_new03_local);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_NuclearCircle_GetType01);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_NuclearCircle_IsPointIn01);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_NuclearCircle_DistanceTo01);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_NuclearCircle_Render01);
    tolua_function(tolua_S,"Extension",tolua_engineWin32_Nuclear_NuclearCircle_Extension01);
    tolua_function(tolua_S,"IsVaild",tolua_engineWin32_Nuclear_NuclearCircle_IsVaild01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearPolygon","Nuclear::NuclearPolygon","Nuclear::INuclearShape",tolua_collect_Nuclear__NuclearPolygon);
   #else
   tolua_cclass(tolua_S,"NuclearPolygon","Nuclear::NuclearPolygon","Nuclear::INuclearShape",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearPolygon");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPolygon_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPolygon_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPolygon_new00_local);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_NuclearPolygon_GetType00);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn00);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_NuclearPolygon_Render00);
    tolua_function(tolua_S,"Extension",tolua_engineWin32_Nuclear_NuclearPolygon_Extension00);
    tolua_function(tolua_S,"IsVaild",tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPolygon_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPolygon_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPolygon_new01_local);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_NuclearPolygon_GetType01);
    tolua_function(tolua_S,"IsPointIn",tolua_engineWin32_Nuclear_NuclearPolygon_IsPointIn01);
    tolua_function(tolua_S,"DistanceTo",tolua_engineWin32_Nuclear_NuclearPolygon_DistanceTo01);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_NuclearPolygon_Render01);
    tolua_function(tolua_S,"Extension",tolua_engineWin32_Nuclear_NuclearPolygon_Extension01);
    tolua_function(tolua_S,"IsVaild",tolua_engineWin32_Nuclear_NuclearPolygon_IsVaild01);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPEL_UNDER_SPRITE",Nuclear::XPEL_UNDER_SPRITE);
   tolua_constant(tolua_S,"XPEL_SPRITE",Nuclear::XPEL_SPRITE);
   tolua_constant(tolua_S,"XPEL_ABOVE_SPRITE",Nuclear::XPEL_ABOVE_SPRITE);
   tolua_constant(tolua_S,"XPEL_TOP",Nuclear::XPEL_TOP);
   tolua_constant(tolua_S,"XPEL_NORMAL_UNDER_SPRITE",Nuclear::XPEL_NORMAL_UNDER_SPRITE);
   tolua_constant(tolua_S,"XPEL_NORMAL_SPRITE_1",Nuclear::XPEL_NORMAL_SPRITE_1);
   tolua_constant(tolua_S,"XPEL_NORMAL_ABOVE_SPRITE",Nuclear::XPEL_NORMAL_ABOVE_SPRITE);
   tolua_constant(tolua_S,"XPEL_NORMAL_SPRITE_2",Nuclear::XPEL_NORMAL_SPRITE_2);
   tolua_constant(tolua_S,"XPEL_NORMAL_TOP",Nuclear::XPEL_NORMAL_TOP);
   tolua_constant(tolua_S,"XPEL_BATTLE_LOW",Nuclear::XPEL_BATTLE_LOW);
   tolua_constant(tolua_S,"XPEL_BATTLE_MID",Nuclear::XPEL_BATTLE_MID);
   tolua_constant(tolua_S,"XPEL_BATTLE_HEIGHT",Nuclear::XPEL_BATTLE_HEIGHT);
   tolua_constant(tolua_S,"XPBGSM_AUTO",Nuclear::XPBGSM_AUTO);
   tolua_constant(tolua_S,"XPBGSM_CUSTOM",Nuclear::XPBGSM_CUSTOM);
   tolua_constant(tolua_S,"XPBGSM_BATTLE",Nuclear::XPBGSM_BATTLE);
   tolua_constant(tolua_S,"XPWM_NORMAL",Nuclear::XPWM_NORMAL);
   tolua_constant(tolua_S,"XPWM_SIMPLE_BATTLE",Nuclear::XPWM_SIMPLE_BATTLE);
   tolua_constant(tolua_S,"XPWM_WORLD_BATTLE",Nuclear::XPWM_WORLD_BATTLE);
   tolua_constant(tolua_S,"XPWM_FLY",Nuclear::XPWM_FLY);
   tolua_constant(tolua_S,"XPWBT_CENTER",Nuclear::XPWBT_CENTER);
   tolua_constant(tolua_S,"XPWBT_SCALE",Nuclear::XPWBT_SCALE);
   tolua_constant(tolua_S,"XPCAMERA_HERO_ALWAYS_IN_CENTER",Nuclear::XPCAMERA_HERO_ALWAYS_IN_CENTER);
   tolua_constant(tolua_S,"XPCAMERA_UPDATE_TYPE2",Nuclear::XPCAMERA_UPDATE_TYPE2);
   tolua_constant(tolua_S,"XPCAMERA_FOLLOW_HERO_WHEN_OUT_OF_INSENCE",Nuclear::XPCAMERA_FOLLOW_HERO_WHEN_OUT_OF_INSENCE);
   tolua_constant(tolua_S,"XPCAMERA_FOLLOW_HEROS_DIR_WHEN_OUT_OF_INSENCE",Nuclear::XPCAMERA_FOLLOW_HEROS_DIR_WHEN_OUT_OF_INSENCE);
   tolua_constant(tolua_S,"XPCAMERA_SMOOTH",Nuclear::XPCAMERA_SMOOTH);
   tolua_constant(tolua_S,"XPCAMERA_MOVE_TO_POSITION_IN_DURATION",Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION);
   tolua_constant(tolua_S,"XPCAMERA_ACCELERATE",Nuclear::XPCAMERA_ACCELERATE);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS","Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS","",tolua_collect_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS);
   #else
   tolua_cclass(tolua_S,"XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS","Nuclear::XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS");
    tolua_variable(tolua_S,"mStartPosition",tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition,tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mStartPosition);
    tolua_variable(tolua_S,"mTargetPosition",tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition,tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mTargetPosition);
    tolua_variable(tolua_S,"mDuration",tolua_get_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration,tolua_set_Nuclear__XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_mDuration);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_XPCAMERA_MOVE_TO_POSITION_IN_DURATION_PARAMS_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPPOOL_VIDEOMEM",Nuclear::XPPOOL_VIDEOMEM);
   tolua_constant(tolua_S,"XPPOOL_MANAGED",Nuclear::XPPOOL_MANAGED);
   tolua_constant(tolua_S,"XPPOOL_SYSTEMMEM",Nuclear::XPPOOL_SYSTEMMEM);
   tolua_constant(tolua_S,"XPCOMPUTERCONFIG_L",Nuclear::XPCOMPUTERCONFIG_L);
   tolua_constant(tolua_S,"XPCOMPUTERCONFIG_M",Nuclear::XPCOMPUTERCONFIG_M);
   tolua_constant(tolua_S,"XPCOMPUTERCONFIG_H",Nuclear::XPCOMPUTERCONFIG_H);
   tolua_constant(tolua_S,"XPCSINFO_FPS",Nuclear::XPCSINFO_FPS);
   tolua_constant(tolua_S,"XPCSINFO_COORDINATE",Nuclear::XPCSINFO_COORDINATE);
   tolua_constant(tolua_S,"XPCSINFO_RENDERINFO",Nuclear::XPCSINFO_RENDERINFO);
   tolua_constant(tolua_S,"XPCSINFO_SYSINFO",Nuclear::XPCSINFO_SYSINFO);
   tolua_constant(tolua_S,"XPCSINFO_WORLDINFO",Nuclear::XPCSINFO_WORLDINFO);
   tolua_constant(tolua_S,"XPCSINFO_FRAMESTAT",Nuclear::XPCSINFO_FRAMESTAT);
   tolua_constant(tolua_S,"XPCSINFO_ALL",Nuclear::XPCSINFO_ALL);
   tolua_constant(tolua_S,"XPFRAMESTAT_FRAME_TIME",Nuclear::XPFRAMESTAT_FRAME_TIME);
   tolua_constant(tolua_S,"XPFRAMESTAT_CAMERA_DIS",Nuclear::XPFRAMESTAT_CAMERA_DIS);
   tolua_constant(tolua_S,"XPFRAMESTAT_FILE_IO",Nuclear::XPFRAMESTAT_FILE_IO);
   tolua_constant(tolua_S,"XPFRAMESTAT_TASK_TIME",Nuclear::XPFRAMESTAT_TASK_TIME);
   tolua_constant(tolua_S,"XPFRAMESTAT_IAPP_MSG",Nuclear::XPFRAMESTAT_IAPP_MSG);
   tolua_constant(tolua_S,"XPWS_ACTIVE",Nuclear::XPWS_ACTIVE);
   tolua_constant(tolua_S,"XPWS_INACTIVE",Nuclear::XPWS_INACTIVE);
   tolua_constant(tolua_S,"XPWS_MINIMIZE",Nuclear::XPWS_MINIMIZE);
   tolua_constant(tolua_S,"XPSTT_NONE",Nuclear::XPSTT_NONE);
   tolua_constant(tolua_S,"XPSTT_ELEMENT_TRANSLUCENT",Nuclear::XPSTT_ELEMENT_TRANSLUCENT);
   tolua_constant(tolua_S,"XPSTT_SPRITE_TRANSLUCENT",Nuclear::XPSTT_SPRITE_TRANSLUCENT);
   tolua_constant(tolua_S,"XPPR_OK",Nuclear::XPPR_OK);
   tolua_constant(tolua_S,"XPPR_BASE_ASYNC_OK",Nuclear::XPPR_BASE_ASYNC_OK);
   tolua_constant(tolua_S,"XPPR_ASYNC_LOADING",Nuclear::XPPR_ASYNC_LOADING);
   tolua_constant(tolua_S,"WST_ALWAYS_PLANE",Nuclear::WST_ALWAYS_PLANE);
   tolua_constant(tolua_S,"WST_OBEY_DIR",Nuclear::WST_OBEY_DIR);
   tolua_constant(tolua_S,"WST_ATHWART_DIR",Nuclear::WST_ATHWART_DIR);
   tolua_constant(tolua_S,"XPTM_PIC_RECT",Nuclear::XPTM_PIC_RECT);
   tolua_constant(tolua_S,"XPTM_POLYGON",Nuclear::XPTM_POLYGON);
   tolua_constant(tolua_S,"XPTM_ALPHA",Nuclear::XPTM_ALPHA);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearBase","Nuclear::NuclearBase","",tolua_collect_Nuclear__NuclearBase);
   #else
   tolua_cclass(tolua_S,"NuclearBase","Nuclear::NuclearBase","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearBase");
    tolua_variable(tolua_S,"left",tolua_get_Nuclear__NuclearBase_left,tolua_set_Nuclear__NuclearBase_left);
    tolua_variable(tolua_S,"right",tolua_get_Nuclear__NuclearBase_right,tolua_set_Nuclear__NuclearBase_right);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBase_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBase_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBase_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPIFF_BMP",Nuclear::XPIFF_BMP);
   tolua_constant(tolua_S,"XPIFF_JPG",Nuclear::XPIFF_JPG);
   tolua_constant(tolua_S,"XPIFF_TGA",Nuclear::XPIFF_TGA);
   tolua_constant(tolua_S,"XPIFF_PNG",Nuclear::XPIFF_PNG);
   tolua_constant(tolua_S,"XPIFF_DDS",Nuclear::XPIFF_DDS);
   tolua_constant(tolua_S,"XPIFF_PPM",Nuclear::XPIFF_PPM);
   tolua_constant(tolua_S,"XPIFF_DIB",Nuclear::XPIFF_DIB);
   tolua_constant(tolua_S,"XPIFF_HDR",Nuclear::XPIFF_HDR);
   tolua_constant(tolua_S,"XPIFF_PFM",Nuclear::XPIFF_PFM);
   tolua_constant(tolua_S,"XPIFF_PVR2",Nuclear::XPIFF_PVR2);
   tolua_constant(tolua_S,"XPIFF_PVR4",Nuclear::XPIFF_PVR4);
   tolua_constant(tolua_S,"XPIFF_ATC",Nuclear::XPIFF_ATC);
   tolua_constant(tolua_S,"XPIFF_FORCE_DWORD",Nuclear::XPIFF_FORCE_DWORD);
   tolua_constant(tolua_S,"XPTEXFMT_DEFAULT",Nuclear::XPTEXFMT_DEFAULT);
   tolua_constant(tolua_S,"XPTEXFMT_A8R8G8B8",Nuclear::XPTEXFMT_A8R8G8B8);
   tolua_constant(tolua_S,"XPTEXFMT_A4R4G4B4",Nuclear::XPTEXFMT_A4R4G4B4);
   tolua_constant(tolua_S,"XPTEXFMT_R5G6B5",Nuclear::XPTEXFMT_R5G6B5);
   tolua_constant(tolua_S,"XPTEXFMT_DXT1",Nuclear::XPTEXFMT_DXT1);
   tolua_constant(tolua_S,"XPEBT_NULL",Nuclear::XPEBT_NULL);
   tolua_constant(tolua_S,"XPEBT_ORIGIN",Nuclear::XPEBT_ORIGIN);
   tolua_constant(tolua_S,"XPEBT_EFFECT_POS",Nuclear::XPEBT_EFFECT_POS);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"sNuclearFontEffectParam","Nuclear::sNuclearFontEffectParam","",tolua_collect_Nuclear__sNuclearFontEffectParam);
   #else
   tolua_cclass(tolua_S,"sNuclearFontEffectParam","Nuclear::sNuclearFontEffectParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"sNuclearFontEffectParam");
    tolua_variable(tolua_S,"fMaxScale",tolua_get_Nuclear__sNuclearFontEffectParam_fMaxScale,tolua_set_Nuclear__sNuclearFontEffectParam_fMaxScale);
    tolua_variable(tolua_S,"fMinScale",tolua_get_Nuclear__sNuclearFontEffectParam_fMinScale,tolua_set_Nuclear__sNuclearFontEffectParam_fMinScale);
    tolua_variable(tolua_S,"fCycle",tolua_get_Nuclear__sNuclearFontEffectParam_fCycle,tolua_set_Nuclear__sNuclearFontEffectParam_fCycle);
    tolua_variable(tolua_S,"nPlayTime",tolua_get_Nuclear__sNuclearFontEffectParam_nPlayTime,tolua_set_Nuclear__sNuclearFontEffectParam_nPlayTime);
    tolua_variable(tolua_S,"nLoopNum",tolua_get_Nuclear__sNuclearFontEffectParam_nLoopNum,tolua_set_Nuclear__sNuclearFontEffectParam_nLoopNum);
    tolua_variable(tolua_S,"pFrctSrc",tolua_get_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr,tolua_set_Nuclear__sNuclearFontEffectParam_pFrctSrc_ptr);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_sNuclearFontEffectParam_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPET_ANI",Nuclear::XPET_ANI);
   tolua_constant(tolua_S,"XPET_PARTICLE",Nuclear::XPET_PARTICLE);
   tolua_constant(tolua_S,"XPET_AUDIO",Nuclear::XPET_AUDIO);
   tolua_constant(tolua_S,"XPET_GEFFECT",Nuclear::XPET_GEFFECT);
   tolua_constant(tolua_S,"XPET_LISTEFFECT",Nuclear::XPET_LISTEFFECT);
   tolua_constant(tolua_S,"XPET_3D",Nuclear::XPET_3D);
   tolua_constant(tolua_S,"XPRS_UNAVAILABLE",Nuclear::XPRS_UNAVAILABLE);
   tolua_constant(tolua_S,"XPRS_AVAILABLE_NEED_LOOKUP",Nuclear::XPRS_AVAILABLE_NEED_LOOKUP);
   tolua_constant(tolua_S,"XPRS_AVAILABLE_NEED_NOT_LOOKUP",Nuclear::XPRS_AVAILABLE_NEED_NOT_LOOKUP);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearTCVertex","Nuclear::NuclearTCVertex","",tolua_collect_Nuclear__NuclearTCVertex);
   #else
   tolua_cclass(tolua_S,"NuclearTCVertex","Nuclear::NuclearTCVertex","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearTCVertex");
    tolua_variable(tolua_S,"x",tolua_get_Nuclear__NuclearTCVertex_x,tolua_set_Nuclear__NuclearTCVertex_x);
    tolua_variable(tolua_S,"y",tolua_get_Nuclear__NuclearTCVertex_y,tolua_set_Nuclear__NuclearTCVertex_y);
    tolua_variable(tolua_S,"z",tolua_get_Nuclear__NuclearTCVertex_z,tolua_set_Nuclear__NuclearTCVertex_z);
    tolua_variable(tolua_S,"rhw",tolua_get_Nuclear__NuclearTCVertex_rhw,tolua_set_Nuclear__NuclearTCVertex_rhw);
    tolua_variable(tolua_S,"c",tolua_get_Nuclear__NuclearTCVertex_c,tolua_set_Nuclear__NuclearTCVertex_c);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearTCVertex_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearTCVertex_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearTCVertex_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearUTCT1Vertex","Nuclear::NuclearUTCT1Vertex","",tolua_collect_Nuclear__NuclearUTCT1Vertex);
   #else
   tolua_cclass(tolua_S,"NuclearUTCT1Vertex","Nuclear::NuclearUTCT1Vertex","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearUTCT1Vertex");
    tolua_variable(tolua_S,"x",tolua_get_Nuclear__NuclearUTCT1Vertex_x,tolua_set_Nuclear__NuclearUTCT1Vertex_x);
    tolua_variable(tolua_S,"y",tolua_get_Nuclear__NuclearUTCT1Vertex_y,tolua_set_Nuclear__NuclearUTCT1Vertex_y);
    tolua_variable(tolua_S,"z",tolua_get_Nuclear__NuclearUTCT1Vertex_z,tolua_set_Nuclear__NuclearUTCT1Vertex_z);
    tolua_variable(tolua_S,"c",tolua_get_Nuclear__NuclearUTCT1Vertex_c,tolua_set_Nuclear__NuclearUTCT1Vertex_c);
    tolua_variable(tolua_S,"u",tolua_get_Nuclear__NuclearUTCT1Vertex_u,tolua_set_Nuclear__NuclearUTCT1Vertex_u);
    tolua_variable(tolua_S,"v",tolua_get_Nuclear__NuclearUTCT1Vertex_v,tolua_set_Nuclear__NuclearUTCT1Vertex_v);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearUTCT1Vertex_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearTCT1Vertex","Nuclear::NuclearTCT1Vertex","",tolua_collect_Nuclear__NuclearTCT1Vertex);
   #else
   tolua_cclass(tolua_S,"NuclearTCT1Vertex","Nuclear::NuclearTCT1Vertex","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearTCT1Vertex");
    tolua_variable(tolua_S,"x",tolua_get_Nuclear__NuclearTCT1Vertex_x,tolua_set_Nuclear__NuclearTCT1Vertex_x);
    tolua_variable(tolua_S,"y",tolua_get_Nuclear__NuclearTCT1Vertex_y,tolua_set_Nuclear__NuclearTCT1Vertex_y);
    tolua_variable(tolua_S,"z",tolua_get_Nuclear__NuclearTCT1Vertex_z,tolua_set_Nuclear__NuclearTCT1Vertex_z);
    tolua_variable(tolua_S,"rhw",tolua_get_Nuclear__NuclearTCT1Vertex_rhw,tolua_set_Nuclear__NuclearTCT1Vertex_rhw);
    tolua_variable(tolua_S,"c",tolua_get_Nuclear__NuclearTCT1Vertex_c,tolua_set_Nuclear__NuclearTCT1Vertex_c);
    tolua_variable(tolua_S,"u",tolua_get_Nuclear__NuclearTCT1Vertex_u,tolua_set_Nuclear__NuclearTCT1Vertex_u);
    tolua_variable(tolua_S,"v",tolua_get_Nuclear__NuclearTCT1Vertex_v,tolua_set_Nuclear__NuclearTCT1Vertex_v);
    tolua_variable(tolua_S,"u2",tolua_get_Nuclear__NuclearTCT1Vertex_u2,tolua_set_Nuclear__NuclearTCT1Vertex_u2);
    tolua_variable(tolua_S,"v2",tolua_get_Nuclear__NuclearTCT1Vertex_v2,tolua_set_Nuclear__NuclearTCT1Vertex_v2);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearTCT1Vertex_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPANI_RELEASE_WAIT_GC",Nuclear::XPANI_RELEASE_WAIT_GC);
   tolua_constant(tolua_S,"XPANI_RELEASE_IMMEDIATE_GC",Nuclear::XPANI_RELEASE_IMMEDIATE_GC);
   tolua_constant(tolua_S,"XPTA_DEFAULT",Nuclear::XPTA_DEFAULT);
   tolua_constant(tolua_S,"XPTA_CENTER_BOTTOM",Nuclear::XPTA_CENTER_BOTTOM);
   tolua_constant(tolua_S,"XPTA_CENTER_TOP",Nuclear::XPTA_CENTER_TOP);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_constant(tolua_S,"XPANIDM_NULL",Nuclear::XPANIDM_NULL);
   tolua_constant(tolua_S,"XPANIDM_8USE1",Nuclear::XPANIDM_8USE1);
   tolua_constant(tolua_S,"XPANIDM_8",Nuclear::XPANIDM_8);
   tolua_constant(tolua_S,"XPANIDM_4",Nuclear::XPANIDM_4);
   tolua_constant(tolua_S,"XPANIDM_3",Nuclear::XPANIDM_3);
   tolua_constant(tolua_S,"XPANIDM_8FROM5",Nuclear::XPANIDM_8FROM5);
   tolua_constant(tolua_S,"XPANIDM_8FROM1",Nuclear::XPANIDM_8FROM1);
   tolua_constant(tolua_S,"XPANIDM_2",Nuclear::XPANIDM_2);
   tolua_constant(tolua_S,"XPANIDM_B2FROM1",Nuclear::XPANIDM_B2FROM1);
   tolua_constant(tolua_S,"XPANIDM_4FROM2",Nuclear::XPANIDM_4FROM2);
   tolua_function(tolua_S,"GetRotationScalingMartrixByDirection",tolua_engineWin32_Nuclear_GetRotationScalingMartrixByDirection00);
   tolua_cclass(tolua_S,"XAni","Nuclear::XAni","",NULL);
   tolua_beginmodule(tolua_S,"XAni");
    tolua_constant(tolua_S,"XPANISTATE_NULL",Nuclear::XAni::XPANISTATE_NULL);
    tolua_constant(tolua_S,"XPANISTATE_NO_XAP",Nuclear::XAni::XPANISTATE_NO_XAP);
    tolua_constant(tolua_S,"XPANISTATE_NOPICTURE",Nuclear::XAni::XPANISTATE_NOPICTURE);
    tolua_constant(tolua_S,"XPANISTATE_BASE_PIC",Nuclear::XAni::XPANISTATE_BASE_PIC);
    tolua_constant(tolua_S,"XPANISTATE_PICTURE",Nuclear::XAni::XPANISTATE_PICTURE);
    #ifdef __cplusplus
    tolua_cclass(tolua_S,"XBigPic","Nuclear::XAni::XBigPic","",tolua_collect_Nuclear__XAni__XBigPic);
    #else
    tolua_cclass(tolua_S,"XBigPic","Nuclear::XAni::XBigPic","",NULL);
    #endif
    tolua_beginmodule(tolua_S,"XBigPic");
     tolua_variable(tolua_S,"handle",tolua_get_Nuclear__XAni__XBigPic_handle,tolua_set_Nuclear__XAni__XBigPic_handle);
     tolua_variable(tolua_S,"filename",tolua_get_Nuclear__XAni__XBigPic_filename,tolua_set_Nuclear__XAni__XBigPic_filename);
     tolua_variable(tolua_S,"dir",tolua_get_Nuclear__XAni__XBigPic_dir,tolua_set_Nuclear__XAni__XBigPic_dir);
     tolua_variable(tolua_S,"asyncLoad",tolua_get_Nuclear__XAni__XBigPic_asyncLoad,tolua_set_Nuclear__XAni__XBigPic_asyncLoad);
     tolua_variable(tolua_S,"loaded",tolua_get_Nuclear__XAni__XBigPic_loaded,tolua_set_Nuclear__XAni__XBigPic_loaded);
     tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_XAni_XBigPic_new00);
     tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_XAni_XBigPic_new00_local);
     tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_XAni_XBigPic_new00_local);
    tolua_endmodule(tolua_S);
    #ifdef __cplusplus
    tolua_cclass(tolua_S,"XPic","Nuclear::XAni::XPic","",tolua_collect_Nuclear__XAni__XPic);
    #else
    tolua_cclass(tolua_S,"XPic","Nuclear::XAni::XPic","",NULL);
    #endif
    tolua_beginmodule(tolua_S,"XPic");
     tolua_variable(tolua_S,"pBigPic",tolua_get_Nuclear__XAni__XPic_pBigPic_ptr,tolua_set_Nuclear__XAni__XPic_pBigPic_ptr);
     tolua_variable(tolua_S,"pBigPicPart",tolua_get_Nuclear__XAni__XPic_pBigPicPart_ptr,tolua_set_Nuclear__XAni__XPic_pBigPicPart_ptr);
     tolua_variable(tolua_S,"offset",tolua_get_Nuclear__XAni__XPic_offset,tolua_set_Nuclear__XAni__XPic_offset);
     tolua_variable(tolua_S,"srcrect",tolua_get_Nuclear__XAni__XPic_srcrect,tolua_set_Nuclear__XAni__XPic_srcrect);
     tolua_variable(tolua_S,"outLine",tolua_get_Nuclear__XAni__XPic_outLine,tolua_set_Nuclear__XAni__XPic_outLine);
     tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_XAni_XPic_new00);
     tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_XAni_XPic_new00_local);
     tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_XAni_XPic_new00_local);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"TestPoint",tolua_engineWin32_Nuclear_XAni_TestPoint00);
    tolua_function(tolua_S,"TestDir",tolua_engineWin32_Nuclear_XAni_TestDir00);
    tolua_function(tolua_S,"GetFrameCount",tolua_engineWin32_Nuclear_XAni_GetFrameCount00);
    tolua_function(tolua_S,"GetRegionCount",tolua_engineWin32_Nuclear_XAni_GetRegionCount00);
    tolua_function(tolua_S,"GetPlayTime",tolua_engineWin32_Nuclear_XAni_GetPlayTime00);
    tolua_function(tolua_S,"SetPlayTime",tolua_engineWin32_Nuclear_XAni_SetPlayTime00);
    tolua_function(tolua_S,"GetBlend",tolua_engineWin32_Nuclear_XAni_GetBlend00);
    tolua_function(tolua_S,"SetBlend",tolua_engineWin32_Nuclear_XAni_SetBlend00);
    tolua_function(tolua_S,"GetState",tolua_engineWin32_Nuclear_XAni_GetState00);
    tolua_function(tolua_S,"GetPic",tolua_engineWin32_Nuclear_XAni_GetPic00);
    tolua_function(tolua_S,"GetBase",tolua_engineWin32_Nuclear_XAni_GetBase00);
    tolua_function(tolua_S,"SetBase",tolua_engineWin32_Nuclear_XAni_SetBase00);
    tolua_function(tolua_S,"GetBorder",tolua_engineWin32_Nuclear_XAni_GetBorder00);
    tolua_function(tolua_S,"SetBorder",tolua_engineWin32_Nuclear_XAni_SetBorder00);
    tolua_function(tolua_S,"GetFileFmt",tolua_engineWin32_Nuclear_XAni_GetFileFmt00);
    tolua_function(tolua_S,"SetFileFmt",tolua_engineWin32_Nuclear_XAni_SetFileFmt00);
    tolua_function(tolua_S,"GetTexFmt",tolua_engineWin32_Nuclear_XAni_GetTexFmt00);
    tolua_function(tolua_S,"SetTexFmt",tolua_engineWin32_Nuclear_XAni_SetTexFmt00);
    tolua_function(tolua_S,"GetDirMode",tolua_engineWin32_Nuclear_XAni_GetDirMode00);
    tolua_function(tolua_S,"GetDirMask",tolua_engineWin32_Nuclear_XAni_GetDirMask00);
    tolua_function(tolua_S,"GetEffectBindType",tolua_engineWin32_Nuclear_XAni_GetEffectBindType00);
    tolua_function(tolua_S,"SetEffectBindType",tolua_engineWin32_Nuclear_XAni_SetEffectBindType00);
    tolua_function(tolua_S,"GetSysLevel",tolua_engineWin32_Nuclear_XAni_GetSysLevel00);
    tolua_function(tolua_S,"SetSysLevel",tolua_engineWin32_Nuclear_XAni_SetSysLevel00);
    tolua_function(tolua_S,"GetReleaseFlag",tolua_engineWin32_Nuclear_XAni_GetReleaseFlag00);
    tolua_function(tolua_S,"SetReleaseFlag",tolua_engineWin32_Nuclear_XAni_SetReleaseFlag00);
    tolua_function(tolua_S,"GetUsingDirs",tolua_engineWin32_Nuclear_XAni_GetUsingDirs00);
    tolua_function(tolua_S,"ExistInUsingDirs",tolua_engineWin32_Nuclear_XAni_ExistInUsingDirs00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"PAniPack","Nuclear::PAniPack","",NULL);
   tolua_beginmodule(tolua_S,"PAniPack");
    #ifdef __cplusplus
    tolua_cclass(tolua_S,"FileSec","Nuclear::PAniPack::FileSec","",tolua_collect_Nuclear__PAniPack__FileSec);
    #else
    tolua_cclass(tolua_S,"FileSec","Nuclear::PAniPack::FileSec","",NULL);
    #endif
    tolua_beginmodule(tolua_S,"FileSec");
     tolua_variable(tolua_S,"offset",tolua_get_Nuclear__PAniPack__FileSec_offset,tolua_set_Nuclear__PAniPack__FileSec_offset);
     tolua_variable(tolua_S,"strPicPath",tolua_get_Nuclear__PAniPack__FileSec_strPicPath,tolua_set_Nuclear__PAniPack__FileSec_strPicPath);
     tolua_variable(tolua_S,"rctData",tolua_get_Nuclear__PAniPack__FileSec_rctData,tolua_set_Nuclear__PAniPack__FileSec_rctData);
     tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_PAniPack_FileSec_new00);
     tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_PAniPack_FileSec_new00_local);
     tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_PAniPack_FileSec_new00_local);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"GetCenter",tolua_engineWin32_Nuclear_PAniPack_GetCenter00);
    tolua_function(tolua_S,"SetCenter",tolua_engineWin32_Nuclear_PAniPack_SetCenter00);
    tolua_function(tolua_S,"GetBase",tolua_engineWin32_Nuclear_PAniPack_GetBase00);
    tolua_function(tolua_S,"SetBase",tolua_engineWin32_Nuclear_PAniPack_SetBase00);
    tolua_function(tolua_S,"GetBorder",tolua_engineWin32_Nuclear_PAniPack_GetBorder00);
    tolua_function(tolua_S,"SetBorder",tolua_engineWin32_Nuclear_PAniPack_SetBorder00);
    tolua_function(tolua_S,"GetFileFmt",tolua_engineWin32_Nuclear_PAniPack_GetFileFmt00);
    tolua_function(tolua_S,"GetTexFmt",tolua_engineWin32_Nuclear_PAniPack_GetTexFmt00);
    tolua_function(tolua_S,"SetBlend",tolua_engineWin32_Nuclear_PAniPack_SetBlend00);
    tolua_function(tolua_S,"SetTime",tolua_engineWin32_Nuclear_PAniPack_SetTime00);
    tolua_function(tolua_S,"SetEffectBindType",tolua_engineWin32_Nuclear_PAniPack_SetEffectBindType00);
    tolua_function(tolua_S,"SetSystemLevel",tolua_engineWin32_Nuclear_PAniPack_SetSystemLevel00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"AniLoadingNotify","Nuclear::AniLoadingNotify","",NULL);
   tolua_beginmodule(tolua_S,"AniLoadingNotify");
    tolua_function(tolua_S,"OnLoadAniReady",tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniReady00);
    tolua_function(tolua_S,"OnLoadAniBaseReady",tolua_engineWin32_Nuclear_AniLoadingNotify_OnLoadAniBaseReady00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"AniManager","Nuclear::AniManager","",tolua_collect_Nuclear__AniManager);
   #else
   tolua_cclass(tolua_S,"AniManager","Nuclear::AniManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"AniManager");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_AniManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_AniManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_AniManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_AniManager_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_AniManager_Init00);
    tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_AniManager_Destroy00);
    tolua_function(tolua_S,"SetAniPicGCTime",tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime00);
    tolua_function(tolua_S,"SetAniPicGCTime",tolua_engineWin32_Nuclear_AniManager_SetAniPicGCTime01);
    tolua_function(tolua_S,"GetAniPicGCTime",tolua_engineWin32_Nuclear_AniManager_GetAniPicGCTime00);
    tolua_function(tolua_S,"SetAniXapGCTime",tolua_engineWin32_Nuclear_AniManager_SetAniXapGCTime00);
    tolua_function(tolua_S,"GetAniXapGCTime",tolua_engineWin32_Nuclear_AniManager_GetAniXapGCTime00);
    tolua_function(tolua_S,"GarbageCollection",tolua_engineWin32_Nuclear_AniManager_GarbageCollection00);
    tolua_function(tolua_S,"AsyncLoadAni",tolua_engineWin32_Nuclear_AniManager_AsyncLoadAni00);
    tolua_function(tolua_S,"RemoveLoadingNotify",tolua_engineWin32_Nuclear_AniManager_RemoveLoadingNotify00);
    tolua_function(tolua_S,"LoadAniFromPack",tolua_engineWin32_Nuclear_AniManager_LoadAniFromPack00);
    tolua_function(tolua_S,"FreeAni",tolua_engineWin32_Nuclear_AniManager_FreeAni00);
    tolua_function(tolua_S,"FreeAniPic",tolua_engineWin32_Nuclear_AniManager_FreeAniPic00);
    tolua_function(tolua_S,"setGcCooldown",tolua_engineWin32_Nuclear_AniManager_setGcCooldown00);
    tolua_function(tolua_S,"SetStepLoadTexture",tolua_engineWin32_Nuclear_AniManager_SetStepLoadTexture00);
    tolua_function(tolua_S,"GetStepLoadTexture",tolua_engineWin32_Nuclear_AniManager_GetStepLoadTexture00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ConfigManager","Nuclear::ConfigManager","",tolua_collect_Nuclear__ConfigManager);
   #else
   tolua_cclass(tolua_S,"ConfigManager","Nuclear::ConfigManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ConfigManager");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_ConfigManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_ConfigManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_ConfigManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ConfigManager_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_ConfigManager_Init00);
    tolua_function(tolua_S,"Update",tolua_engineWin32_Nuclear_ConfigManager_Update00);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_ConfigManager_OnTimer00);
    tolua_function(tolua_S,"GetCreateTexturePoolType",tolua_engineWin32_Nuclear_ConfigManager_GetCreateTexturePoolType00);
    tolua_function(tolua_S,"GetSpriteMoveSmoothLimit",tolua_engineWin32_Nuclear_ConfigManager_GetSpriteMoveSmoothLimit00);
    tolua_function(tolua_S,"SetSpriteMoveSmoothLimit",tolua_engineWin32_Nuclear_ConfigManager_SetSpriteMoveSmoothLimit00);
    tolua_function(tolua_S,"GetLogicToWorldScaleX",tolua_engineWin32_Nuclear_ConfigManager_GetLogicToWorldScaleX00);
    tolua_function(tolua_S,"SetLogicToWorldScaleX",tolua_engineWin32_Nuclear_ConfigManager_SetLogicToWorldScaleX00);
    tolua_function(tolua_S,"IsRenderNightEffectByShader",tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectByShader00);
    tolua_function(tolua_S,"SetRenderNightEffectByShader",tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectByShader00);
    tolua_function(tolua_S,"IsRenderNightEffectWithRenderTarget",tolua_engineWin32_Nuclear_ConfigManager_IsRenderNightEffectWithRenderTarget00);
    tolua_function(tolua_S,"SetRenderNightEffectWithRenderTarget",tolua_engineWin32_Nuclear_ConfigManager_SetRenderNightEffectWithRenderTarget00);
    tolua_function(tolua_S,"IsEnableMaskPic",tolua_engineWin32_Nuclear_ConfigManager_IsEnableMaskPic00);
    tolua_function(tolua_S,"SetEnableMaskPic",tolua_engineWin32_Nuclear_ConfigManager_SetEnableMaskPic00);
    tolua_function(tolua_S,"IsRenderSpriteShadow",tolua_engineWin32_Nuclear_ConfigManager_IsRenderSpriteShadow00);
    tolua_function(tolua_S,"SetRenderSpriteShadow",tolua_engineWin32_Nuclear_ConfigManager_SetRenderSpriteShadow00);
    tolua_function(tolua_S,"IsBlurForTeleport",tolua_engineWin32_Nuclear_ConfigManager_IsBlurForTeleport00);
    tolua_function(tolua_S,"SetBlurForTeleport",tolua_engineWin32_Nuclear_ConfigManager_SetBlurForTeleport00);
    tolua_function(tolua_S,"GetSystemLevel",tolua_engineWin32_Nuclear_ConfigManager_GetSystemLevel00);
    tolua_function(tolua_S,"SetSystemLevel",tolua_engineWin32_Nuclear_ConfigManager_SetSystemLevel00);
    tolua_function(tolua_S,"IsSmoothMove",tolua_engineWin32_Nuclear_ConfigManager_IsSmoothMove00);
    tolua_function(tolua_S,"SetSmoothMove",tolua_engineWin32_Nuclear_ConfigManager_SetSmoothMove00);
    tolua_function(tolua_S,"GetMinDelta",tolua_engineWin32_Nuclear_ConfigManager_GetMinDelta00);
    tolua_function(tolua_S,"SetMinDelta",tolua_engineWin32_Nuclear_ConfigManager_SetMinDelta00);
    tolua_function(tolua_S,"GetMaxDiffDelta",tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffDelta00);
    tolua_function(tolua_S,"SetMaxDiffDelta",tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffDelta00);
    tolua_function(tolua_S,"GetMaxDiffFromAvg",tolua_engineWin32_Nuclear_ConfigManager_GetMaxDiffFromAvg00);
    tolua_function(tolua_S,"SetMaxDiffFromAvg",tolua_engineWin32_Nuclear_ConfigManager_SetMaxDiffFromAvg00);
    tolua_function(tolua_S,"GetUnloadMapBGSoundFadeOutTime",tolua_engineWin32_Nuclear_ConfigManager_GetUnloadMapBGSoundFadeOutTime00);
    tolua_function(tolua_S,"SetUnloadMapBGSoundFadeOutTime",tolua_engineWin32_Nuclear_ConfigManager_SetUnloadMapBGSoundFadeOutTime00);
    tolua_function(tolua_S,"GetBGMType",tolua_engineWin32_Nuclear_ConfigManager_GetBGMType00);
    tolua_function(tolua_S,"SetBGMType",tolua_engineWin32_Nuclear_ConfigManager_SetBGMType00);
    tolua_function(tolua_S,"GetEnvSoundType",tolua_engineWin32_Nuclear_ConfigManager_GetEnvSoundType00);
    tolua_function(tolua_S,"SetEnvSoundType",tolua_engineWin32_Nuclear_ConfigManager_SetEnvSoundType00);
    tolua_function(tolua_S,"GetStepSoundType",tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundType00);
    tolua_function(tolua_S,"SetStepSoundType",tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundType00);
    tolua_function(tolua_S,"GetStepSoundPriority",tolua_engineWin32_Nuclear_ConfigManager_GetStepSoundPriority00);
    tolua_function(tolua_S,"SetStepSoundPriority",tolua_engineWin32_Nuclear_ConfigManager_SetStepSoundPriority00);
    tolua_function(tolua_S,"SetConsoleInfo",tolua_engineWin32_Nuclear_ConfigManager_SetConsoleInfo00);
    tolua_function(tolua_S,"TestConsoleInfo",tolua_engineWin32_Nuclear_ConfigManager_TestConsoleInfo00);
    tolua_function(tolua_S,"SetFrameStateInfo",tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateInfo00);
    tolua_function(tolua_S,"TestFrameStateInfo",tolua_engineWin32_Nuclear_ConfigManager_TestFrameStateInfo00);
    tolua_function(tolua_S,"SetFrameStateColor",tolua_engineWin32_Nuclear_ConfigManager_SetFrameStateColor00);
    tolua_function(tolua_S,"GetFrameStateColor",tolua_engineWin32_Nuclear_ConfigManager_GetFrameStateColor00);
    tolua_function(tolua_S,"IsDynamicMapLoading",tolua_engineWin32_Nuclear_ConfigManager_IsDynamicMapLoading00);
    tolua_function(tolua_S,"SetDynamicMapLoading",tolua_engineWin32_Nuclear_ConfigManager_SetDynamicMapLoading00);
    tolua_function(tolua_S,"IsControlFPS",tolua_engineWin32_Nuclear_ConfigManager_IsControlFPS00);
    tolua_function(tolua_S,"SetControlFPS",tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS00);
    tolua_function(tolua_S,"SetControlFPS",tolua_engineWin32_Nuclear_ConfigManager_SetControlFPS01);
    tolua_function(tolua_S,"GetControlFPS",tolua_engineWin32_Nuclear_ConfigManager_GetControlFPS00);
    tolua_function(tolua_S,"IsSortMapObjects",tolua_engineWin32_Nuclear_ConfigManager_IsSortMapObjects00);
    tolua_function(tolua_S,"SetSortMapObjects",tolua_engineWin32_Nuclear_ConfigManager_SetSortMapObjects00);
    tolua_function(tolua_S,"IsUseSurfaceCache",tolua_engineWin32_Nuclear_ConfigManager_IsUseSurfaceCache00);
    tolua_function(tolua_S,"SetUseSurfaceCache",tolua_engineWin32_Nuclear_ConfigManager_SetUseSurfaceCache00);
    tolua_function(tolua_S,"IsSyncBeforeWater",tolua_engineWin32_Nuclear_ConfigManager_IsSyncBeforeWater00);
    tolua_function(tolua_S,"SetSyncBeforeWater",tolua_engineWin32_Nuclear_ConfigManager_SetSyncBeforeWater00);
    tolua_function(tolua_S,"SetEnableLinkedObjs",tolua_engineWin32_Nuclear_ConfigManager_SetEnableLinkedObjs00);
    tolua_function(tolua_S,"IsEnableLinkedObjs",tolua_engineWin32_Nuclear_ConfigManager_IsEnableLinkedObjs00);
    tolua_function(tolua_S,"IsShowSpritePath",tolua_engineWin32_Nuclear_ConfigManager_IsShowSpritePath00);
    tolua_function(tolua_S,"SetShowSpritePath",tolua_engineWin32_Nuclear_ConfigManager_SetShowSpritePath00);
    tolua_function(tolua_S,"IsShowSpriteTrail",tolua_engineWin32_Nuclear_ConfigManager_IsShowSpriteTrail00);
    tolua_function(tolua_S,"SetShowSpriteTrail",tolua_engineWin32_Nuclear_ConfigManager_SetShowSpriteTrail00);
    tolua_function(tolua_S,"IsShowMazeGrid",tolua_engineWin32_Nuclear_ConfigManager_IsShowMazeGrid00);
    tolua_function(tolua_S,"SetShowMazeGrid",tolua_engineWin32_Nuclear_ConfigManager_SetShowMazeGrid00);
    tolua_function(tolua_S,"GetMazeMask",tolua_engineWin32_Nuclear_ConfigManager_GetMazeMask00);
    tolua_function(tolua_S,"SetMazeMask",tolua_engineWin32_Nuclear_ConfigManager_SetMazeMask00);
    tolua_function(tolua_S,"GetSpriteTranslucentType",tolua_engineWin32_Nuclear_ConfigManager_GetSpriteTranslucentType00);
    tolua_function(tolua_S,"SetSpriteTranslucentType",tolua_engineWin32_Nuclear_ConfigManager_SetSpriteTranslucentType00);
    tolua_function(tolua_S,"GetMaskAlpha",tolua_engineWin32_Nuclear_ConfigManager_GetMaskAlpha00);
    tolua_function(tolua_S,"SetMaskAlpha",tolua_engineWin32_Nuclear_ConfigManager_SetMaskAlpha00);
    tolua_function(tolua_S,"IsRenderSolidMask",tolua_engineWin32_Nuclear_ConfigManager_IsRenderSolidMask00);
    tolua_function(tolua_S,"SetRenderSolidMask",tolua_engineWin32_Nuclear_ConfigManager_SetRenderSolidMask00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"EffectManager","Nuclear::EffectManager","",tolua_collect_Nuclear__EffectManager);
   #else
   tolua_cclass(tolua_S,"EffectManager","Nuclear::EffectManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"EffectManager");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_EffectManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_EffectManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_EffectManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_EffectManager_delete00);
    tolua_function(tolua_S,"CreateEffect",tolua_engineWin32_Nuclear_EffectManager_CreateEffect00);
    tolua_function(tolua_S,"CreateLinkedEffect",tolua_engineWin32_Nuclear_EffectManager_CreateLinkedEffect00);
    tolua_function(tolua_S,"CreateListEffect",tolua_engineWin32_Nuclear_EffectManager_CreateListEffect00);
    tolua_function(tolua_S,"OnTick",tolua_engineWin32_Nuclear_EffectManager_OnTick00);
    tolua_function(tolua_S,"RemoveEffect",tolua_engineWin32_Nuclear_EffectManager_RemoveEffect00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IParticleManager","Nuclear::IParticleManager","",tolua_collect_Nuclear__IParticleManager);
   #else
   tolua_cclass(tolua_S,"IParticleManager","Nuclear::IParticleManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IParticleManager");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IParticleManager_delete00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ExecThread","Nuclear::ExecThread","",tolua_collect_Nuclear__ExecThread);
   #else
   tolua_cclass(tolua_S,"ExecThread","Nuclear::ExecThread","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ExecThread");
    #ifdef __cplusplus
    tolua_cclass(tolua_S,"Task","Nuclear::ExecThread::Task","",tolua_collect_Nuclear__ExecThread__Task);
    #else
    tolua_cclass(tolua_S,"Task","Nuclear::ExecThread::Task","",NULL);
    #endif
    tolua_beginmodule(tolua_S,"Task");
     tolua_function(tolua_S,"GetPriority",tolua_engineWin32_Nuclear_ExecThread_Task_GetPriority00);
     tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ExecThread_Task_delete00);
     tolua_function(tolua_S,"Execute",tolua_engineWin32_Nuclear_ExecThread_Task_Execute00);
     tolua_function(tolua_S,"UnexecuteAndDestroy",tolua_engineWin32_Nuclear_ExecThread_Task_UnexecuteAndDestroy00);
     tolua_function(tolua_S,"ExecuteEndAndDestroy",tolua_engineWin32_Nuclear_ExecThread_Task_ExecuteEndAndDestroy00);
    tolua_endmodule(tolua_S);
    tolua_cclass(tolua_S,"SimpleTask","Nuclear::ExecThread::SimpleTask","Nuclear::ExecThread::Task",NULL);
    tolua_beginmodule(tolua_S,"SimpleTask");
     tolua_function(tolua_S,"ExecuteEndAndDestroy",tolua_engineWin32_Nuclear_ExecThread_SimpleTask_ExecuteEndAndDestroy00);
     tolua_function(tolua_S,"UnexecuteAndDestroy",tolua_engineWin32_Nuclear_ExecThread_SimpleTask_UnexecuteAndDestroy00);
     tolua_function(tolua_S,"Execute",tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Execute00);
     tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_ExecThread_SimpleTask_Destroy00);
    tolua_endmodule(tolua_S);
    tolua_cclass(tolua_S,"CallbackTask","Nuclear::ExecThread::CallbackTask","Nuclear::ExecThread::Task",NULL);
    tolua_beginmodule(tolua_S,"CallbackTask");
     tolua_function(tolua_S,"Cancel",tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Cancel00);
     tolua_function(tolua_S,"ExecuteEndAndDestroy",tolua_engineWin32_Nuclear_ExecThread_CallbackTask_ExecuteEndAndDestroy00);
     tolua_function(tolua_S,"UnexecuteAndDestroy",tolua_engineWin32_Nuclear_ExecThread_CallbackTask_UnexecuteAndDestroy00);
     tolua_function(tolua_S,"Execute",tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Execute00);
     tolua_function(tolua_S,"Callback",tolua_engineWin32_Nuclear_ExecThread_CallbackTask_Callback00);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_ExecThread_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_ExecThread_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_ExecThread_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ExecThread_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_ExecThread_Init00);
    tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_ExecThread_Destroy00);
    tolua_function(tolua_S,"AddTask",tolua_engineWin32_Nuclear_ExecThread_AddTask00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"INuclearFileIO","Nuclear::INuclearFileIO","",tolua_collect_Nuclear__INuclearFileIO);
   #else
   tolua_cclass(tolua_S,"INuclearFileIO","Nuclear::INuclearFileIO","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"INuclearFileIO");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_INuclearFileIO_delete00);
    tolua_function(tolua_S,"GetFileImage",tolua_engineWin32_Nuclear_INuclearFileIO_GetFileImage00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearFileIOManager","Nuclear::NuclearFileIOManager","Nuclear::INuclearFileIO",tolua_collect_Nuclear__NuclearFileIOManager);
   #else
   tolua_cclass(tolua_S,"NuclearFileIOManager","Nuclear::NuclearFileIOManager","Nuclear::INuclearFileIO",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearFileIOManager");
    tolua_cclass(tolua_S,"AsyncReadTask","Nuclear::NuclearFileIOManager::AsyncReadTask","",NULL);
    tolua_beginmodule(tolua_S,"AsyncReadTask");
     tolua_function(tolua_S,"GetFileIOManager",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileIOManager00);
     tolua_function(tolua_S,"GetFileName",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetFileName00);
     tolua_function(tolua_S,"GetData",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_GetData00);
     tolua_function(tolua_S,"Submit",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Submit00);
     tolua_function(tolua_S,"Discard",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Discard00);
     tolua_function(tolua_S,"IsDiscarded",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_IsDiscarded00);
     tolua_function(tolua_S,"OnReady",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnReady00);
     tolua_function(tolua_S,"OnDiscard",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_OnDiscard00);
     tolua_function(tolua_S,"Execute",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Execute00);
     tolua_function(tolua_S,"Callback",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadTask_Callback00);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearFileIOManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearFileIOManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearFileIOManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_NuclearFileIOManager_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_NuclearFileIOManager_Init00);
    tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_NuclearFileIOManager_Destroy00);
    tolua_function(tolua_S,"OnUpdate",tolua_engineWin32_Nuclear_NuclearFileIOManager_OnUpdate00);
    tolua_function(tolua_S,"GetCurrentDirectory",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetCurrentDirectory00);
    tolua_function(tolua_S,"AddTask",tolua_engineWin32_Nuclear_NuclearFileIOManager_AddTask00);
    tolua_function(tolua_S,"AsyncReadFile",tolua_engineWin32_Nuclear_NuclearFileIOManager_AsyncReadFile00);
    tolua_function(tolua_S,"OnAsyncReadFileNotify",tolua_engineWin32_Nuclear_NuclearFileIOManager_OnAsyncReadFileNotify00);
    tolua_function(tolua_S,"GetFileIOTaskCount",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskCount00);
    tolua_function(tolua_S,"GetFileIOTaskBytes",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetFileIOTaskBytes00);
    tolua_function(tolua_S,"GetQueueOfIOTaskSize",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetQueueOfIOTaskSize00);
    tolua_function(tolua_S,"SetUpdateTimePerFrame",tolua_engineWin32_Nuclear_NuclearFileIOManager_SetUpdateTimePerFrame00);
    tolua_function(tolua_S,"GetUpdateTimePerFrame",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetUpdateTimePerFrame00);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_NuclearFileIOManager_OnTimer00);
    tolua_function(tolua_S,"OnReady",tolua_engineWin32_Nuclear_NuclearFileIOManager_OnReady00);
    tolua_function(tolua_S,"GetAverageReadSpeed",tolua_engineWin32_Nuclear_NuclearFileIOManager_GetAverageReadSpeed00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ISelectableObj","Nuclear::ISelectableObj","",tolua_collect_Nuclear__ISelectableObj);
   #else
   tolua_cclass(tolua_S,"ISelectableObj","Nuclear::ISelectableObj","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ISelectableObj");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_ISelectableObj_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_ISelectableObj_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_ISelectableObj_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ISelectableObj_delete00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IImmovableObj","Nuclear::IImmovableObj","virtualISelectableObj",tolua_collect_Nuclear__IImmovableObj);
   #else
   tolua_cclass(tolua_S,"IImmovableObj","Nuclear::IImmovableObj","virtualISelectableObj",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IImmovableObj");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IImmovableObj_delete00);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_IImmovableObj_SetLocation00);
    tolua_function(tolua_S,"GetLocation",tolua_engineWin32_Nuclear_IImmovableObj_GetLocation00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_IImmovableObj_SetDirection00);
    tolua_function(tolua_S,"GetDirection",tolua_engineWin32_Nuclear_IImmovableObj_GetDirection00);
    tolua_function(tolua_S,"SetVisible",tolua_engineWin32_Nuclear_IImmovableObj_SetVisible00);
    tolua_function(tolua_S,"IsVisiable",tolua_engineWin32_Nuclear_IImmovableObj_IsVisiable00);
    tolua_function(tolua_S,"SetEntityVisible",tolua_engineWin32_Nuclear_IImmovableObj_SetEntityVisible00);
    tolua_function(tolua_S,"IsEntityVisible",tolua_engineWin32_Nuclear_IImmovableObj_IsEntityVisible00);
    tolua_function(tolua_S,"SetTitleVisible",tolua_engineWin32_Nuclear_IImmovableObj_SetTitleVisible00);
    tolua_function(tolua_S,"IsTitleVisible",tolua_engineWin32_Nuclear_IImmovableObj_IsTitleVisible00);
    tolua_function(tolua_S,"SetTitle",tolua_engineWin32_Nuclear_IImmovableObj_SetTitle00);
    tolua_function(tolua_S,"GetTitle",tolua_engineWin32_Nuclear_IImmovableObj_GetTitle00);
    tolua_function(tolua_S,"UnsetTitle",tolua_engineWin32_Nuclear_IImmovableObj_UnsetTitle00);
    tolua_function(tolua_S,"SetTitleSize",tolua_engineWin32_Nuclear_IImmovableObj_SetTitleSize00);
    tolua_function(tolua_S,"GetTitleWidth",tolua_engineWin32_Nuclear_IImmovableObj_GetTitleWidth00);
    tolua_function(tolua_S,"GetTitleHeight",tolua_engineWin32_Nuclear_IImmovableObj_GetTitleHeight00);
    tolua_function(tolua_S,"SetHighlight",tolua_engineWin32_Nuclear_IImmovableObj_SetHighlight00);
    tolua_function(tolua_S,"IsHighlight",tolua_engineWin32_Nuclear_IImmovableObj_IsHighlight00);
    tolua_function(tolua_S,"SetTestAlpha",tolua_engineWin32_Nuclear_IImmovableObj_SetTestAlpha00);
    tolua_function(tolua_S,"IsTestAlpha",tolua_engineWin32_Nuclear_IImmovableObj_IsTestAlpha00);
    tolua_function(tolua_S,"SetMouseTestMode",tolua_engineWin32_Nuclear_IImmovableObj_SetMouseTestMode00);
    tolua_function(tolua_S,"GetMouseTestMode",tolua_engineWin32_Nuclear_IImmovableObj_GetMouseTestMode00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_cclass(tolua_S,"HorseHeight","Nuclear::HorseHeight","",NULL);
   tolua_beginmodule(tolua_S,"HorseHeight");
    tolua_function(tolua_S,"Load",tolua_engineWin32_Nuclear_HorseHeight_Load00);
    tolua_function(tolua_S,"Save",tolua_engineWin32_Nuclear_HorseHeight_Save00);
    tolua_function(tolua_S,"GetHeight",tolua_engineWin32_Nuclear_HorseHeight_GetHeight00);
    tolua_function(tolua_S,"SetHeight",tolua_engineWin32_Nuclear_HorseHeight_SetHeight00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"SpriteSoundParam","Nuclear::SpriteSoundParam","",tolua_collect_Nuclear__SpriteSoundParam);
   #else
   tolua_cclass(tolua_S,"SpriteSoundParam","Nuclear::SpriteSoundParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"SpriteSoundParam");
    tolua_variable(tolua_S,"soundname",tolua_get_Nuclear__SpriteSoundParam_soundname,tolua_set_Nuclear__SpriteSoundParam_soundname);
    tolua_variable(tolua_S,"vol",tolua_get_Nuclear__SpriteSoundParam_unsigned_vol,tolua_set_Nuclear__SpriteSoundParam_unsigned_vol);
    tolua_variable(tolua_S,"freq",tolua_get_Nuclear__SpriteSoundParam_unsigned_freq,tolua_set_Nuclear__SpriteSoundParam_unsigned_freq);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_SpriteSoundParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_SpriteSoundParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_SpriteSoundParam_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ModelSoundParam","Nuclear::ModelSoundParam","",tolua_collect_Nuclear__ModelSoundParam);
   #else
   tolua_cclass(tolua_S,"ModelSoundParam","Nuclear::ModelSoundParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ModelSoundParam");
    tolua_variable(tolua_S,"keyComponentID",tolua_get_Nuclear__ModelSoundParam_keyComponentID,tolua_set_Nuclear__ModelSoundParam_keyComponentID);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_ModelSoundParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_ModelSoundParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_ModelSoundParam_new00_local);
    tolua_function(tolua_S,"ClearSoundMap",tolua_engineWin32_Nuclear_ModelSoundParam_ClearSoundMap00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ActionType","Nuclear::ActionType","",tolua_collect_Nuclear__ActionType);
   #else
   tolua_cclass(tolua_S,"ActionType","Nuclear::ActionType","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ActionType");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_ActionType_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_ActionType_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_ActionType_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ActionType_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_ActionType_Init00);
    tolua_function(tolua_S,"Load",tolua_engineWin32_Nuclear_ActionType_Load00);
    tolua_function(tolua_S,"GetActionType",tolua_engineWin32_Nuclear_ActionType_GetActionType00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Action","Nuclear::Action","",tolua_collect_Nuclear__Action);
   #else
   tolua_cclass(tolua_S,"Action","Nuclear::Action","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Action");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_Action_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_Action_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_Action_new00_local);
    tolua_function(tolua_S,"GetLineFrame",tolua_engineWin32_Nuclear_Action_GetLineFrame00);
    tolua_function(tolua_S,"SetDir",tolua_engineWin32_Nuclear_Action_SetDir00);
    tolua_function(tolua_S,"ClearDir",tolua_engineWin32_Nuclear_Action_ClearDir00);
    tolua_function(tolua_S,"TestDir",tolua_engineWin32_Nuclear_Action_TestDir00);
    tolua_function(tolua_S,"GetDirMask",tolua_engineWin32_Nuclear_Action_GetDirMask00);
    tolua_function(tolua_S,"SetEquip",tolua_engineWin32_Nuclear_Action_SetEquip00);
    tolua_function(tolua_S,"ClearEquip",tolua_engineWin32_Nuclear_Action_ClearEquip00);
    tolua_function(tolua_S,"TestEquip",tolua_engineWin32_Nuclear_Action_TestEquip00);
    tolua_function(tolua_S,"GetEquipMask",tolua_engineWin32_Nuclear_Action_GetEquipMask00);
    tolua_function(tolua_S,"SetEquipMask",tolua_engineWin32_Nuclear_Action_SetEquipMask00);
    tolua_function(tolua_S,"IsInd",tolua_engineWin32_Nuclear_Action_IsInd00);
    tolua_function(tolua_S,"SetInd",tolua_engineWin32_Nuclear_Action_SetInd00);
    tolua_function(tolua_S,"SetFrameLink",tolua_engineWin32_Nuclear_Action_SetFrameLink00);
    tolua_function(tolua_S,"SetFrameOrder",tolua_engineWin32_Nuclear_Action_SetFrameOrder00);
    tolua_function(tolua_S,"GetFrameOrder",tolua_engineWin32_Nuclear_Action_GetFrameOrder00);
    tolua_function(tolua_S,"GetFrameStartTime",tolua_engineWin32_Nuclear_Action_GetFrameStartTime00);
    tolua_function(tolua_S,"SetFrameStartTime",tolua_engineWin32_Nuclear_Action_SetFrameStartTime00);
    tolua_function(tolua_S,"SetFrameTime",tolua_engineWin32_Nuclear_Action_SetFrameTime00);
    tolua_function(tolua_S,"GetFrameTime",tolua_engineWin32_Nuclear_Action_GetFrameTime00);
    tolua_function(tolua_S,"GetFrameCount",tolua_engineWin32_Nuclear_Action_GetFrameCount00);
    tolua_function(tolua_S,"GetStride",tolua_engineWin32_Nuclear_Action_GetStride00);
    tolua_function(tolua_S,"GetTime",tolua_engineWin32_Nuclear_Action_GetTime00);
    tolua_function(tolua_S,"SetTime",tolua_engineWin32_Nuclear_Action_SetTime00);
    tolua_function(tolua_S,"GetEffectPoint",tolua_engineWin32_Nuclear_Action_GetEffectPoint00);
    tolua_function(tolua_S,"GetDamagePoint",tolua_engineWin32_Nuclear_Action_GetDamagePoint00);
    tolua_function(tolua_S,"SetDamagePoint",tolua_engineWin32_Nuclear_Action_SetDamagePoint00);
    tolua_function(tolua_S,"SetEffectPoint",tolua_engineWin32_Nuclear_Action_SetEffectPoint00);
    tolua_function(tolua_S,"SetStride",tolua_engineWin32_Nuclear_Action_SetStride00);
    tolua_function(tolua_S,"SetFrameCount",tolua_engineWin32_Nuclear_Action_SetFrameCount00);
    tolua_function(tolua_S,"GetBoundingBox",tolua_engineWin32_Nuclear_Action_GetBoundingBox00);
    tolua_function(tolua_S,"SetBoundingBox",tolua_engineWin32_Nuclear_Action_SetBoundingBox00);
    tolua_function(tolua_S,"IsValid",tolua_engineWin32_Nuclear_Action_IsValid00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Component","Nuclear::Component","",tolua_collect_Nuclear__Component);
   #else
   tolua_cclass(tolua_S,"Component","Nuclear::Component","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Component");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_Component_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_Component_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_Component_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_Component_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_Component_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_Component_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_Component_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_Component_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_Component_new02_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_Component_delete00);
    tolua_function(tolua_S,"Release",tolua_engineWin32_Nuclear_Component_Release00);
    tolua_function(tolua_S,"IsInSegmPak",tolua_engineWin32_Nuclear_Component_IsInSegmPak00);
    tolua_function(tolua_S,"SetSegmPak",tolua_engineWin32_Nuclear_Component_SetSegmPak00);
    tolua_function(tolua_S,"GetLayer",tolua_engineWin32_Nuclear_Component_GetLayer00);
    tolua_function(tolua_S,"GetName",tolua_engineWin32_Nuclear_Component_GetName00);
    tolua_function(tolua_S,"GetConstName",tolua_engineWin32_Nuclear_Component_GetConstName00);
    tolua_function(tolua_S,"OnLoadAniReady",tolua_engineWin32_Nuclear_Component_OnLoadAniReady00);
    tolua_function(tolua_S,"OnLoadAniBaseReady",tolua_engineWin32_Nuclear_Component_OnLoadAniBaseReady00);
    tolua_function(tolua_S,"ReleaseAction",tolua_engineWin32_Nuclear_Component_ReleaseAction00);
    tolua_function(tolua_S,"SetName",tolua_engineWin32_Nuclear_Component_SetName00);
    tolua_function(tolua_S,"SetLinkName",tolua_engineWin32_Nuclear_Component_SetLinkName00);
    tolua_function(tolua_S,"DeleteAction",tolua_engineWin32_Nuclear_Component_DeleteAction00);
    tolua_function(tolua_S,"RenameAction",tolua_engineWin32_Nuclear_Component_RenameAction00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"SpriteManager","Nuclear::SpriteManager","",tolua_collect_Nuclear__SpriteManager);
   #else
   tolua_cclass(tolua_S,"SpriteManager","Nuclear::SpriteManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"SpriteManager");
    #ifdef __cplusplus
    tolua_cclass(tolua_S,"Layer","Nuclear::SpriteManager::Layer","",tolua_collect_Nuclear__SpriteManager__Layer);
    #else
    tolua_cclass(tolua_S,"Layer","Nuclear::SpriteManager::Layer","",NULL);
    #endif
    tolua_beginmodule(tolua_S,"Layer");
     tolua_variable(tolua_S,"name",tolua_get_Nuclear__SpriteManager__Layer_name,tolua_set_Nuclear__SpriteManager__Layer_name);
     tolua_variable(tolua_S,"des",tolua_get_Nuclear__SpriteManager__Layer_des,tolua_set_Nuclear__SpriteManager__Layer_des);
     tolua_variable(tolua_S,"bRide",tolua_get_Nuclear__SpriteManager__Layer_bRide,tolua_set_Nuclear__SpriteManager__Layer_bRide);
     tolua_variable(tolua_S,"bEffect",tolua_get_Nuclear__SpriteManager__Layer_bEffect,tolua_set_Nuclear__SpriteManager__Layer_bEffect);
     tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_SpriteManager_Layer_new00);
     tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_SpriteManager_Layer_new00_local);
     tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_SpriteManager_Layer_new00_local);
     tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_SpriteManager_Layer_new01);
     tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_SpriteManager_Layer_new01_local);
     tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_SpriteManager_Layer_new01_local);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_SpriteManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_SpriteManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_SpriteManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_SpriteManager_delete00);
    tolua_function(tolua_S,"GetModelDes",tolua_engineWin32_Nuclear_SpriteManager_GetModelDes00);
    tolua_function(tolua_S,"DumpModelNames",tolua_engineWin32_Nuclear_SpriteManager_DumpModelNames00);
    tolua_function(tolua_S,"DelModel",tolua_engineWin32_Nuclear_SpriteManager_DelModel00);
    tolua_function(tolua_S,"GetLayerCount",tolua_engineWin32_Nuclear_SpriteManager_GetLayerCount00);
    tolua_function(tolua_S,"GetLayerName",tolua_engineWin32_Nuclear_SpriteManager_GetLayerName00);
    tolua_function(tolua_S,"GetLayerDes",tolua_engineWin32_Nuclear_SpriteManager_GetLayerDes00);
    tolua_function(tolua_S,"GetLayerRideEnable",tolua_engineWin32_Nuclear_SpriteManager_GetLayerRideEnable00);
    tolua_function(tolua_S,"GetLayerEffectEnable",tolua_engineWin32_Nuclear_SpriteManager_GetLayerEffectEnable00);
    tolua_function(tolua_S,"GetTitlePos",tolua_engineWin32_Nuclear_SpriteManager_GetTitlePos00);
    tolua_function(tolua_S,"GetModelScale",tolua_engineWin32_Nuclear_SpriteManager_GetModelScale00);
    tolua_function(tolua_S,"GetEffectPos",tolua_engineWin32_Nuclear_SpriteManager_GetEffectPos00);
    tolua_function(tolua_S,"GetHorseHeight",tolua_engineWin32_Nuclear_SpriteManager_GetHorseHeight00);
    tolua_function(tolua_S,"GetActionSoundType",tolua_engineWin32_Nuclear_SpriteManager_GetActionSoundType00);
    tolua_function(tolua_S,"SetActionSoundType",tolua_engineWin32_Nuclear_SpriteManager_SetActionSoundType00);
    tolua_function(tolua_S,"GetActionRef",tolua_engineWin32_Nuclear_SpriteManager_GetActionRef00);
    tolua_function(tolua_S,"SaveSoundParam",tolua_engineWin32_Nuclear_SpriteManager_SaveSoundParam00);
    tolua_function(tolua_S,"SaveBase",tolua_engineWin32_Nuclear_SpriteManager_SaveBase00);
    tolua_function(tolua_S,"SetTitlePos",tolua_engineWin32_Nuclear_SpriteManager_SetTitlePos00);
    tolua_function(tolua_S,"SetEffectPos",tolua_engineWin32_Nuclear_SpriteManager_SetEffectPos00);
    tolua_function(tolua_S,"SetHorseHeight",tolua_engineWin32_Nuclear_SpriteManager_SetHorseHeight00);
    tolua_function(tolua_S,"SetWaterSurfaceType",tolua_engineWin32_Nuclear_SpriteManager_SetWaterSurfaceType00);
    tolua_function(tolua_S,"DeleteAction2",tolua_engineWin32_Nuclear_SpriteManager_DeleteAction200);
    tolua_function(tolua_S,"RenameAction2",tolua_engineWin32_Nuclear_SpriteManager_RenameAction200);
    tolua_function(tolua_S,"AddComponent",tolua_engineWin32_Nuclear_SpriteManager_AddComponent00);
    tolua_function(tolua_S,"DeleteComponent",tolua_engineWin32_Nuclear_SpriteManager_DeleteComponent00);
    tolua_function(tolua_S,"GetComponent",tolua_engineWin32_Nuclear_SpriteManager_GetComponent00);
    tolua_function(tolua_S,"DumpComponent",tolua_engineWin32_Nuclear_SpriteManager_DumpComponent00);
    tolua_function(tolua_S,"RenameComponent",tolua_engineWin32_Nuclear_SpriteManager_RenameComponent00);
    tolua_function(tolua_S,"GetSoundParam",tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam00);
    tolua_function(tolua_S,"GetSoundParam",tolua_engineWin32_Nuclear_SpriteManager_GetSoundParam01);
    tolua_function(tolua_S,"GetAction",tolua_engineWin32_Nuclear_SpriteManager_GetAction00);
    tolua_function(tolua_S,"SetAction",tolua_engineWin32_Nuclear_SpriteManager_SetAction00);
    tolua_function(tolua_S,"SaveActions",tolua_engineWin32_Nuclear_SpriteManager_SaveActions00);
    tolua_function(tolua_S,"AddAction",tolua_engineWin32_Nuclear_SpriteManager_AddAction00);
    tolua_function(tolua_S,"DeleteAction",tolua_engineWin32_Nuclear_SpriteManager_DeleteAction00);
    tolua_function(tolua_S,"RenameAction",tolua_engineWin32_Nuclear_SpriteManager_RenameAction00);
    tolua_function(tolua_S,"DumpAction",tolua_engineWin32_Nuclear_SpriteManager_DumpAction00);
    tolua_function(tolua_S,"PreInit",tolua_engineWin32_Nuclear_SpriteManager_PreInit00);
    tolua_function(tolua_S,"PostInit",tolua_engineWin32_Nuclear_SpriteManager_PostInit00);
    tolua_function(tolua_S,"SaveModels",tolua_engineWin32_Nuclear_SpriteManager_SaveModels00);
    tolua_function(tolua_S,"GetInitCount",tolua_engineWin32_Nuclear_SpriteManager_GetInitCount00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"SystemResourceManager","Nuclear::SystemResourceManager","",tolua_collect_Nuclear__SystemResourceManager);
   #else
   tolua_cclass(tolua_S,"SystemResourceManager","Nuclear::SystemResourceManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"SystemResourceManager");
    tolua_cclass(tolua_S,"WindowsVersionInfo","Nuclear::SystemResourceManager::WindowsVersionInfo","",NULL);
    tolua_beginmodule(tolua_S,"WindowsVersionInfo");
     tolua_variable(tolua_S,"m_iPlatformID",tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID,tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iPlatformID);
     tolua_variable(tolua_S,"m_iMajorVersion",tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion,tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMajorVersion);
     tolua_variable(tolua_S,"m_iMinorVersion",tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion,tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iMinorVersion);
     tolua_variable(tolua_S,"m_iBuildNumber",tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber,tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_iBuildNumber);
     tolua_variable(tolua_S,"m_strInfo",tolua_get_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo,tolua_set_Nuclear__SystemResourceManager__WindowsVersionInfo_m_strInfo);
    tolua_endmodule(tolua_S);
    tolua_cclass(tolua_S,"MemoryStatus","Nuclear::SystemResourceManager::MemoryStatus","",NULL);
    tolua_beginmodule(tolua_S,"MemoryStatus");
     tolua_variable(tolua_S,"m_iTotalPhys",tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys,tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalPhys);
     tolua_variable(tolua_S,"m_iAvailPhys",tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys,tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailPhys);
     tolua_variable(tolua_S,"m_iMemoryLoad",tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad,tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iMemoryLoad);
     tolua_variable(tolua_S,"m_iTotalVirtual",tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual,tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iTotalVirtual);
     tolua_variable(tolua_S,"m_iAvailVirtual",tolua_get_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual,tolua_set_Nuclear__SystemResourceManager__MemoryStatus_m_iAvailVirtual);
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_SystemResourceManager_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_SystemResourceManager_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_SystemResourceManager_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_SystemResourceManager_delete00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_SystemResourceManager_Init00);
    tolua_function(tolua_S,"Update",tolua_engineWin32_Nuclear_SystemResourceManager_Update00);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_SystemResourceManager_OnTimer00);
    tolua_function(tolua_S,"GetCPUCount",tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUCount00);
    tolua_function(tolua_S,"GetSystemTimerPeriod",tolua_engineWin32_Nuclear_SystemResourceManager_GetSystemTimerPeriod00);
    tolua_function(tolua_S,"IsTextureCapsNoPow2",tolua_engineWin32_Nuclear_SystemResourceManager_IsTextureCapsNoPow200);
    tolua_function(tolua_S,"GetCPUFrequency",tolua_engineWin32_Nuclear_SystemResourceManager_GetCPUFrequency00);
    tolua_function(tolua_S,"IsCPUFrequencyValid",tolua_engineWin32_Nuclear_SystemResourceManager_IsCPUFrequencyValid00);
    tolua_function(tolua_S,"GetMemoryStatus",tolua_engineWin32_Nuclear_SystemResourceManager_GetMemoryStatus00);
    tolua_function(tolua_S,"GetAvailTextureMemory",tolua_engineWin32_Nuclear_SystemResourceManager_GetAvailTextureMemory00);
    tolua_function(tolua_S,"SetSoundInited",tolua_engineWin32_Nuclear_SystemResourceManager_SetSoundInited00);
    tolua_function(tolua_S,"IsSoundInited",tolua_engineWin32_Nuclear_SystemResourceManager_IsSoundInited00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_constant(tolua_S,"XPLOADMAP_NOEFFECT",Nuclear::XPLOADMAP_NOEFFECT);
   tolua_cclass(tolua_S,"XPLoadmapParam","Nuclear::XPLoadmapParam","",NULL);
   tolua_beginmodule(tolua_S,"XPLoadmapParam");
    tolua_variable(tolua_S,"objLoc",tolua_get_Nuclear__XPLoadmapParam_objLoc,tolua_set_Nuclear__XPLoadmapParam_objLoc);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_XPLoadmapParam_GetType00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"ShakeScreenController","Nuclear::ShakeScreenController","",NULL);
   tolua_beginmodule(tolua_S,"ShakeScreenController");
    tolua_function(tolua_S,"GetShakeScreenAdjust",tolua_engineWin32_Nuclear_ShakeScreenController_GetShakeScreenAdjust00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"transformWarLayer2NewLayer",tolua_engineWin32_Nuclear_transformWarLayer2NewLayer00);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IWorld","Nuclear::IWorld","",tolua_collect_Nuclear__IWorld);
   #else
   tolua_cclass(tolua_S,"IWorld","Nuclear::IWorld","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IWorld");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IWorld_delete00);
    tolua_function(tolua_S,"LoadMap",tolua_engineWin32_Nuclear_IWorld_LoadMap00);
    tolua_function(tolua_S,"LoadMap",tolua_engineWin32_Nuclear_IWorld_LoadMap01);
    tolua_function(tolua_S,"UnloadMap",tolua_engineWin32_Nuclear_IWorld_UnloadMap00);
    tolua_function(tolua_S,"GetMapSize",tolua_engineWin32_Nuclear_IWorld_GetMapSize00);
    tolua_function(tolua_S,"SetShakeScreenController",tolua_engineWin32_Nuclear_IWorld_SetShakeScreenController00);
    tolua_function(tolua_S,"GetShakeScreenController",tolua_engineWin32_Nuclear_IWorld_GetShakeScreenController00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_IWorld_SetScale00);
    tolua_function(tolua_S,"GetScale",tolua_engineWin32_Nuclear_IWorld_GetScale00);
    tolua_function(tolua_S,"SetMapMaze",tolua_engineWin32_Nuclear_IWorld_SetMapMaze00);
    tolua_function(tolua_S,"SetMazeMask",tolua_engineWin32_Nuclear_IWorld_SetMazeMask00);
    tolua_function(tolua_S,"GetMazeMask",tolua_engineWin32_Nuclear_IWorld_GetMazeMask00);
    tolua_function(tolua_S,"SetMazeColors",tolua_engineWin32_Nuclear_IWorld_SetMazeColors00);
    tolua_function(tolua_S,"GetMazeColors",tolua_engineWin32_Nuclear_IWorld_GetMazeColors00);
    tolua_function(tolua_S,"SetMaskBoxColor",tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor00);
    tolua_function(tolua_S,"SetMaskBoxColor",tolua_engineWin32_Nuclear_IWorld_SetMaskBoxColor01);
    tolua_function(tolua_S,"GetMaskBoxColor",tolua_engineWin32_Nuclear_IWorld_GetMaskBoxColor00);
    tolua_function(tolua_S,"SetWorldMode",tolua_engineWin32_Nuclear_IWorld_SetWorldMode00);
    tolua_function(tolua_S,"GetWorldMode",tolua_engineWin32_Nuclear_IWorld_GetWorldMode00);
    tolua_function(tolua_S,"LoadWarBackgound",tolua_engineWin32_Nuclear_IWorld_LoadWarBackgound00);
    tolua_function(tolua_S,"FreeWarBackgroundHandle",tolua_engineWin32_Nuclear_IWorld_FreeWarBackgroundHandle00);
    tolua_function(tolua_S,"SetWarBackground",tolua_engineWin32_Nuclear_IWorld_SetWarBackground00);
    tolua_function(tolua_S,"SetWarBackground",tolua_engineWin32_Nuclear_IWorld_SetWarBackground01);
    tolua_function(tolua_S,"FreeAllWarBackground",tolua_engineWin32_Nuclear_IWorld_FreeAllWarBackground00);
    tolua_function(tolua_S,"SetWarBackgroundEdge",tolua_engineWin32_Nuclear_IWorld_SetWarBackgroundEdge00);
    tolua_function(tolua_S,"GetWarBackgroundEdge",tolua_engineWin32_Nuclear_IWorld_GetWarBackgroundEdge00);
    tolua_function(tolua_S,"GetSortTick",tolua_engineWin32_Nuclear_IWorld_GetSortTick00);
    tolua_function(tolua_S,"NewSprite",tolua_engineWin32_Nuclear_IWorld_NewSprite00);
    tolua_function(tolua_S,"AttachSprite",tolua_engineWin32_Nuclear_IWorld_AttachSprite00);
    tolua_function(tolua_S,"AttachSprite",tolua_engineWin32_Nuclear_IWorld_AttachSprite01);
    tolua_function(tolua_S,"DetachSprite",tolua_engineWin32_Nuclear_IWorld_DetachSprite00);
    tolua_function(tolua_S,"DeleteSprite",tolua_engineWin32_Nuclear_IWorld_DeleteSprite00);
    tolua_function(tolua_S,"DeleteAllSprite",tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite00);
    tolua_function(tolua_S,"MoveSpriteLayer",tolua_engineWin32_Nuclear_IWorld_MoveSpriteLayer00);
    tolua_function(tolua_S,"NewSprite",tolua_engineWin32_Nuclear_IWorld_NewSprite01);
    tolua_function(tolua_S,"DetachSprite",tolua_engineWin32_Nuclear_IWorld_DetachSprite01);
    tolua_function(tolua_S,"DeleteAllSprite",tolua_engineWin32_Nuclear_IWorld_DeleteAllSprite01);
    tolua_function(tolua_S,"NewWarSprite",tolua_engineWin32_Nuclear_IWorld_NewWarSprite00);
    tolua_function(tolua_S,"AttachWarSprite",tolua_engineWin32_Nuclear_IWorld_AttachWarSprite00);
    tolua_function(tolua_S,"DetachWarSprite",tolua_engineWin32_Nuclear_IWorld_DetachWarSprite00);
    tolua_function(tolua_S,"DeleteWarSprite",tolua_engineWin32_Nuclear_IWorld_DeleteWarSprite00);
    tolua_function(tolua_S,"DeleteAllWarSprite",tolua_engineWin32_Nuclear_IWorld_DeleteAllWarSprite00);
    tolua_function(tolua_S,"GetSpriteShadowParam",tolua_engineWin32_Nuclear_IWorld_GetSpriteShadowParam00);
    tolua_function(tolua_S,"SetSpriteShadowParam",tolua_engineWin32_Nuclear_IWorld_SetSpriteShadowParam00);
    tolua_function(tolua_S,"NewImmovableObj",tolua_engineWin32_Nuclear_IWorld_NewImmovableObj00);
    tolua_function(tolua_S,"DeleteImmovableObj",tolua_engineWin32_Nuclear_IWorld_DeleteImmovableObj00);
    tolua_function(tolua_S,"DeleteAllImmovableObj",tolua_engineWin32_Nuclear_IWorld_DeleteAllImmovableObj00);
    tolua_function(tolua_S,"SelectObjs",tolua_engineWin32_Nuclear_IWorld_SelectObjs00);
    tolua_function(tolua_S,"SetLinkedEffect",tolua_engineWin32_Nuclear_IWorld_SetLinkedEffect00);
    tolua_function(tolua_S,"SetEffect",tolua_engineWin32_Nuclear_IWorld_SetEffect00);
    tolua_function(tolua_S,"SetContinueEffect",tolua_engineWin32_Nuclear_IWorld_SetContinueEffect00);
    tolua_function(tolua_S,"RemoveEffect",tolua_engineWin32_Nuclear_IWorld_RemoveEffect00);
    tolua_function(tolua_S,"RemoveEffectEx",tolua_engineWin32_Nuclear_IWorld_RemoveEffectEx00);
    tolua_function(tolua_S,"PlayEffect",tolua_engineWin32_Nuclear_IWorld_PlayEffect00);
    tolua_function(tolua_S,"SetWarEffect",tolua_engineWin32_Nuclear_IWorld_SetWarEffect00);
    tolua_function(tolua_S,"SetWarContinueEffect",tolua_engineWin32_Nuclear_IWorld_SetWarContinueEffect00);
    tolua_function(tolua_S,"RemoveWarEffect",tolua_engineWin32_Nuclear_IWorld_RemoveWarEffect00);
    tolua_function(tolua_S,"AttachCameraTo",tolua_engineWin32_Nuclear_IWorld_AttachCameraTo00);
    tolua_function(tolua_S,"GetViewport",tolua_engineWin32_Nuclear_IWorld_GetViewport00);
    tolua_function(tolua_S,"SetViewport",tolua_engineWin32_Nuclear_IWorld_SetViewport00);
    tolua_function(tolua_S,"SetViewportLT",tolua_engineWin32_Nuclear_IWorld_SetViewportLT00);
    tolua_function(tolua_S,"SetGameTime",tolua_engineWin32_Nuclear_IWorld_SetGameTime00);
    tolua_function(tolua_S,"GetTempGameTime",tolua_engineWin32_Nuclear_IWorld_GetTempGameTime00);
    tolua_function(tolua_S,"SetGameTimeCycle",tolua_engineWin32_Nuclear_IWorld_SetGameTimeCycle00);
    tolua_function(tolua_S,"SetCameraUpdateType",tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType00);
    tolua_function(tolua_S,"SetCameraUpdateType",tolua_engineWin32_Nuclear_IWorld_SetCameraUpdateType01);
    tolua_function(tolua_S,"GetCameraUpdateType",tolua_engineWin32_Nuclear_IWorld_GetCameraUpdateType00);
    tolua_function(tolua_S,"PrefetchMapRes",tolua_engineWin32_Nuclear_IWorld_PrefetchMapRes00);
    tolua_function(tolua_S,"CancelPrefetch",tolua_engineWin32_Nuclear_IWorld_CancelPrefetch00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"World","Nuclear::World","Nuclear::IWorld",tolua_collect_Nuclear__World);
   #else
   tolua_cclass(tolua_S,"World","Nuclear::World","Nuclear::IWorld",NULL);
   #endif
   tolua_beginmodule(tolua_S,"World");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_World_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_World_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_World_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_World_delete00);
    tolua_function(tolua_S,"OnChangeBGSoundMode",tolua_engineWin32_Nuclear_World_OnChangeBGSoundMode00);
    tolua_function(tolua_S,"ResetBGSound",tolua_engineWin32_Nuclear_World_ResetBGSound00);
    tolua_function(tolua_S,"GetMapName",tolua_engineWin32_Nuclear_World_GetMapName00);
    tolua_function(tolua_S,"GetWaterDepth",tolua_engineWin32_Nuclear_World_GetWaterDepth00);
    tolua_function(tolua_S,"LoadMap",tolua_engineWin32_Nuclear_World_LoadMap00);
    tolua_function(tolua_S,"UnloadMap",tolua_engineWin32_Nuclear_World_UnloadMap00);
    tolua_function(tolua_S,"IsMapLoaded",tolua_engineWin32_Nuclear_World_IsMapLoaded00);
    tolua_function(tolua_S,"IsMapFull",tolua_engineWin32_Nuclear_World_IsMapFull00);
    tolua_function(tolua_S,"GetMapSize",tolua_engineWin32_Nuclear_World_GetMapSize00);
    tolua_function(tolua_S,"SetMapMaze",tolua_engineWin32_Nuclear_World_SetMapMaze00);
    tolua_function(tolua_S,"SetMazeMask",tolua_engineWin32_Nuclear_World_SetMazeMask00);
    tolua_function(tolua_S,"GetMazeMask",tolua_engineWin32_Nuclear_World_GetMazeMask00);
    tolua_function(tolua_S,"SetMaskBoxColor",tolua_engineWin32_Nuclear_World_SetMaskBoxColor00);
    tolua_function(tolua_S,"SetMaskBoxColor",tolua_engineWin32_Nuclear_World_SetMaskBoxColor01);
    tolua_function(tolua_S,"GetMaskBoxColor",tolua_engineWin32_Nuclear_World_GetMaskBoxColor00);
    tolua_function(tolua_S,"GetSpriteShadowParam",tolua_engineWin32_Nuclear_World_GetSpriteShadowParam00);
    tolua_function(tolua_S,"GetSortTick",tolua_engineWin32_Nuclear_World_GetSortTick00);
    tolua_function(tolua_S,"GetAllSpriteCount",tolua_engineWin32_Nuclear_World_GetAllSpriteCount00);
    tolua_function(tolua_S,"GetAllSpriteDetail",tolua_engineWin32_Nuclear_World_GetAllSpriteDetail00);
    tolua_function(tolua_S,"GetAllEffectCount",tolua_engineWin32_Nuclear_World_GetAllEffectCount00);
    tolua_function(tolua_S,"GetAllEffectDetail",tolua_engineWin32_Nuclear_World_GetAllEffectDetail00);
    tolua_function(tolua_S,"EnableRenderDuringLoading",tolua_engineWin32_Nuclear_World_EnableRenderDuringLoading00);
    tolua_function(tolua_S,"IsRenderDuringLoading",tolua_engineWin32_Nuclear_World_IsRenderDuringLoading00);
    tolua_function(tolua_S,"SetSpriteShadowParam",tolua_engineWin32_Nuclear_World_SetSpriteShadowParam00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_World_SetScale00);
    tolua_function(tolua_S,"GetScale",tolua_engineWin32_Nuclear_World_GetScale00);
    tolua_function(tolua_S,"PushSpriteTopEffect",tolua_engineWin32_Nuclear_World_PushSpriteTopEffect00);
    tolua_function(tolua_S,"PushSpriteBottomEffect",tolua_engineWin32_Nuclear_World_PushSpriteBottomEffect00);
    tolua_function(tolua_S,"SetWorldMode",tolua_engineWin32_Nuclear_World_SetWorldMode00);
    tolua_function(tolua_S,"GetWorldMode",tolua_engineWin32_Nuclear_World_GetWorldMode00);
    tolua_function(tolua_S,"LoadWarBackgound",tolua_engineWin32_Nuclear_World_LoadWarBackgound00);
    tolua_function(tolua_S,"FreeWarBackgroundHandle",tolua_engineWin32_Nuclear_World_FreeWarBackgroundHandle00);
    tolua_function(tolua_S,"SetWarBackground",tolua_engineWin32_Nuclear_World_SetWarBackground00);
    tolua_function(tolua_S,"FreeAllWarBackground",tolua_engineWin32_Nuclear_World_FreeAllWarBackground00);
    tolua_function(tolua_S,"SetWarBackgroundEdge",tolua_engineWin32_Nuclear_World_SetWarBackgroundEdge00);
    tolua_function(tolua_S,"GetWarBackgroundEdge",tolua_engineWin32_Nuclear_World_GetWarBackgroundEdge00);
    tolua_function(tolua_S,"NewSprite",tolua_engineWin32_Nuclear_World_NewSprite00);
    tolua_function(tolua_S,"AttachSprite",tolua_engineWin32_Nuclear_World_AttachSprite00);
    tolua_function(tolua_S,"DetachSprite",tolua_engineWin32_Nuclear_World_DetachSprite00);
    tolua_function(tolua_S,"DeleteSprite",tolua_engineWin32_Nuclear_World_DeleteSprite00);
    tolua_function(tolua_S,"DeleteAllSprite",tolua_engineWin32_Nuclear_World_DeleteAllSprite00);
    tolua_function(tolua_S,"MoveSpriteLayer",tolua_engineWin32_Nuclear_World_MoveSpriteLayer00);
    tolua_function(tolua_S,"NewImmovableObj",tolua_engineWin32_Nuclear_World_NewImmovableObj00);
    tolua_function(tolua_S,"DeleteImmovableObj",tolua_engineWin32_Nuclear_World_DeleteImmovableObj00);
    tolua_function(tolua_S,"DeleteAllImmovableObj",tolua_engineWin32_Nuclear_World_DeleteAllImmovableObj00);
    tolua_function(tolua_S,"SelectObjs",tolua_engineWin32_Nuclear_World_SelectObjs00);
    tolua_function(tolua_S,"SetLinkedEffect",tolua_engineWin32_Nuclear_World_SetLinkedEffect00);
    tolua_function(tolua_S,"SetEffect",tolua_engineWin32_Nuclear_World_SetEffect00);
    tolua_function(tolua_S,"SetContinueEffect",tolua_engineWin32_Nuclear_World_SetContinueEffect00);
    tolua_function(tolua_S,"RemoveEffect",tolua_engineWin32_Nuclear_World_RemoveEffect00);
    tolua_function(tolua_S,"RemoveEffectEx",tolua_engineWin32_Nuclear_World_RemoveEffectEx00);
    tolua_function(tolua_S,"PlayEffect",tolua_engineWin32_Nuclear_World_PlayEffect00);
    tolua_function(tolua_S,"PlayOnceEffect",tolua_engineWin32_Nuclear_World_PlayOnceEffect00);
    tolua_function(tolua_S,"CheckMapGUID",tolua_engineWin32_Nuclear_World_CheckMapGUID00);
    tolua_function(tolua_S,"pauseSceneEffects",tolua_engineWin32_Nuclear_World_pauseSceneEffects00);
    tolua_function(tolua_S,"resumeSceneEffects",tolua_engineWin32_Nuclear_World_resumeSceneEffects00);
    tolua_function(tolua_S,"showSceneEffects",tolua_engineWin32_Nuclear_World_showSceneEffects00);
    tolua_function(tolua_S,"isShowSceneEffects",tolua_engineWin32_Nuclear_World_isShowSceneEffects00);
    tolua_function(tolua_S,"AttachCameraTo",tolua_engineWin32_Nuclear_World_AttachCameraTo00);
    tolua_function(tolua_S,"SetViewport",tolua_engineWin32_Nuclear_World_SetViewport00);
    tolua_function(tolua_S,"SetViewportLT",tolua_engineWin32_Nuclear_World_SetViewportLT00);
    tolua_function(tolua_S,"PrefetchMapRes",tolua_engineWin32_Nuclear_World_PrefetchMapRes00);
    tolua_function(tolua_S,"CancelPrefetch",tolua_engineWin32_Nuclear_World_CancelPrefetch00);
    tolua_function(tolua_S,"OnRendererRestore",tolua_engineWin32_Nuclear_World_OnRendererRestore00);
    tolua_function(tolua_S,"FreeAllPicReses",tolua_engineWin32_Nuclear_World_FreeAllPicReses00);
    tolua_function(tolua_S,"NotifyLoadmapProgress",tolua_engineWin32_Nuclear_World_NotifyLoadmapProgress00);
    tolua_function(tolua_S,"NotifyALoadItemFin",tolua_engineWin32_Nuclear_World_NotifyALoadItemFin00);
    tolua_function(tolua_S,"AddTotalLoadingCount",tolua_engineWin32_Nuclear_World_AddTotalLoadingCount00);
    tolua_function(tolua_S,"Init",tolua_engineWin32_Nuclear_World_Init00);
    tolua_function(tolua_S,"SetViewSize",tolua_engineWin32_Nuclear_World_SetViewSize00);
    tolua_function(tolua_S,"GetViewport",tolua_engineWin32_Nuclear_World_GetViewport00);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_World_OnTimer00);
    tolua_function(tolua_S,"UpdateBeforeRender",tolua_engineWin32_Nuclear_World_UpdateBeforeRender00);
    tolua_function(tolua_S,"SortMid",tolua_engineWin32_Nuclear_World_SortMid00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_World_Render00);
    tolua_function(tolua_S,"RenderCaptureWorld",tolua_engineWin32_Nuclear_World_RenderCaptureWorld00);
    tolua_function(tolua_S,"RenderStaticLayer",tolua_engineWin32_Nuclear_World_RenderStaticLayer00);
    tolua_function(tolua_S,"RenderSortedLayer",tolua_engineWin32_Nuclear_World_RenderSortedLayer00);
    tolua_function(tolua_S,"RenderSortedLayerWithoutAlpha",tolua_engineWin32_Nuclear_World_RenderSortedLayerWithoutAlpha00);
    tolua_function(tolua_S,"RenderSortedLayerElementWithoutSprite",tolua_engineWin32_Nuclear_World_RenderSortedLayerElementWithoutSprite00);
    tolua_function(tolua_S,"RenderSortedLayerAlphaSpriteWithoutElement",tolua_engineWin32_Nuclear_World_RenderSortedLayerAlphaSpriteWithoutElement00);
    tolua_function(tolua_S,"RenderSortedLayerNonAlphaSpriteWithAlphaElement",tolua_engineWin32_Nuclear_World_RenderSortedLayerNonAlphaSpriteWithAlphaElement00);
    tolua_function(tolua_S,"RenderMovingBackground",tolua_engineWin32_Nuclear_World_RenderMovingBackground00);
    tolua_function(tolua_S,"RenderRenderTargetCache",tolua_engineWin32_Nuclear_World_RenderRenderTargetCache00);
    tolua_function(tolua_S,"SetNightEffect",tolua_engineWin32_Nuclear_World_SetNightEffect00);
    tolua_function(tolua_S,"OnTick",tolua_engineWin32_Nuclear_World_OnTick00);
    tolua_function(tolua_S,"UpdateSpriteAction",tolua_engineWin32_Nuclear_World_UpdateSpriteAction00);
    tolua_function(tolua_S,"RenderMaze",tolua_engineWin32_Nuclear_World_RenderMaze00);
    tolua_function(tolua_S,"RenderMaskBox",tolua_engineWin32_Nuclear_World_RenderMaskBox00);
    tolua_function(tolua_S,"SetGameTime",tolua_engineWin32_Nuclear_World_SetGameTime00);
    tolua_function(tolua_S,"SetGameTimeCycle",tolua_engineWin32_Nuclear_World_SetGameTimeCycle00);
    tolua_function(tolua_S,"GetGameTime",tolua_engineWin32_Nuclear_World_GetGameTime00);
    tolua_function(tolua_S,"GetTempGameTime",tolua_engineWin32_Nuclear_World_GetTempGameTime00);
    tolua_function(tolua_S,"SetCameraUpdateType",tolua_engineWin32_Nuclear_World_SetCameraUpdateType00);
    tolua_function(tolua_S,"GetCameraUpdateType",tolua_engineWin32_Nuclear_World_GetCameraUpdateType00);
    tolua_function(tolua_S,"SetShakeScreenController",tolua_engineWin32_Nuclear_World_SetShakeScreenController00);
    tolua_function(tolua_S,"GetShakeScreenController",tolua_engineWin32_Nuclear_World_GetShakeScreenController00);
    tolua_function(tolua_S,"SetCurveMoveHeight",tolua_engineWin32_Nuclear_World_SetCurveMoveHeight00);
    tolua_function(tolua_S,"GetCurveMoveHeight",tolua_engineWin32_Nuclear_World_GetCurveMoveHeight00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_cclass(tolua_S,"IEffect","Nuclear::IEffect","",NULL);
   tolua_beginmodule(tolua_S,"IEffect");
    tolua_function(tolua_S,"AddNotify",tolua_engineWin32_Nuclear_IEffect_AddNotify00);
    tolua_function(tolua_S,"RemoveNotify",tolua_engineWin32_Nuclear_IEffect_RemoveNotify00);
    tolua_function(tolua_S,"Play",tolua_engineWin32_Nuclear_IEffect_Play00);
    tolua_function(tolua_S,"Stop",tolua_engineWin32_Nuclear_IEffect_Stop00);
    tolua_function(tolua_S,"Pause",tolua_engineWin32_Nuclear_IEffect_Pause00);
    tolua_function(tolua_S,"Resume",tolua_engineWin32_Nuclear_IEffect_Resume00);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_IEffect_SetLocation00);
    tolua_function(tolua_S,"GetLocation",tolua_engineWin32_Nuclear_IEffect_GetLocation00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_IEffect_SetDirection00);
    tolua_function(tolua_S,"GetDirection",tolua_engineWin32_Nuclear_IEffect_GetDirection00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_IEffect_SetDirection01);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_IEffect_SetDirection02);
    tolua_function(tolua_S,"SetRotationRadian",tolua_engineWin32_Nuclear_IEffect_SetRotationRadian00);
    tolua_function(tolua_S,"GetRotationRadian",tolua_engineWin32_Nuclear_IEffect_GetRotationRadian00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_IEffect_SetScale00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_IEffect_SetScale01);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_IEffect_SetScale02);
    tolua_function(tolua_S,"GetScale",tolua_engineWin32_Nuclear_IEffect_GetScale00);
    tolua_function(tolua_S,"SetVertexColor",tolua_engineWin32_Nuclear_IEffect_SetVertexColor00);
    tolua_function(tolua_S,"GetVertexColor",tolua_engineWin32_Nuclear_IEffect_GetVertexColor00);
    tolua_function(tolua_S,"GetRelBouningBox",tolua_engineWin32_Nuclear_IEffect_GetRelBouningBox00);
    tolua_function(tolua_S,"SetEffectBindType",tolua_engineWin32_Nuclear_IEffect_SetEffectBindType00);
    tolua_function(tolua_S,"GetEffectBindType",tolua_engineWin32_Nuclear_IEffect_GetEffectBindType00);
    tolua_function(tolua_S,"SetSoundType",tolua_engineWin32_Nuclear_IEffect_SetSoundType00);
    tolua_function(tolua_S,"SetSoundType",tolua_engineWin32_Nuclear_IEffect_SetSoundType01);
    tolua_function(tolua_S,"GetSoundType",tolua_engineWin32_Nuclear_IEffect_GetSoundType00);
    tolua_function(tolua_S,"SetSoundPriority",tolua_engineWin32_Nuclear_IEffect_SetSoundPriority00);
    tolua_function(tolua_S,"GetSoundPriority",tolua_engineWin32_Nuclear_IEffect_GetSoundPriority00);
    tolua_function(tolua_S,"GetPlayState",tolua_engineWin32_Nuclear_IEffect_GetPlayState00);
    tolua_function(tolua_S,"TryConvertToParticle",tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle00);
    tolua_function(tolua_S,"TryConvertToParticle",tolua_engineWin32_Nuclear_IEffect_TryConvertToParticle01);
    tolua_function(tolua_S,"ClearNotify",tolua_engineWin32_Nuclear_IEffect_ClearNotify00);
    tolua_function(tolua_S,"Update",tolua_engineWin32_Nuclear_IEffect_Update00);
    tolua_function(tolua_S,"SetDefaultActName",tolua_engineWin32_Nuclear_IEffect_SetDefaultActName00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IEffectNotify","Nuclear::IEffectNotify","",tolua_collect_Nuclear__IEffectNotify);
   #else
   tolua_cclass(tolua_S,"IEffectNotify","Nuclear::IEffectNotify","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IEffectNotify");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_IEffectNotify_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_IEffectNotify_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_IEffectNotify_new00_local);
    tolua_function(tolua_S,"OnStop",tolua_engineWin32_Nuclear_IEffectNotify_OnStop00);
    tolua_function(tolua_S,"OnEnd",tolua_engineWin32_Nuclear_IEffectNotify_OnEnd00);
    tolua_function(tolua_S,"OnDelete",tolua_engineWin32_Nuclear_IEffectNotify_OnDelete00);
    tolua_function(tolua_S,"OnAsyncLoaded",tolua_engineWin32_Nuclear_IEffectNotify_OnAsyncLoaded00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IEffectNotify_delete00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPPCM_NO_CYCLE",Nuclear::XPPCM_NO_CYCLE);
   tolua_constant(tolua_S,"XPPCM_ALWAY_EMISSION",Nuclear::XPPCM_ALWAY_EMISSION);
   tolua_constant(tolua_S,"XPPCM_PULSE_EMISSION",Nuclear::XPPCM_PULSE_EMISSION);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Effect","Nuclear::Effect","Nuclear::IEffect",tolua_collect_Nuclear__Effect);
   #else
   tolua_cclass(tolua_S,"Effect","Nuclear::Effect","Nuclear::IEffect",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Effect");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_Effect_delete00);
    tolua_function(tolua_S,"IsInSegmPak",tolua_engineWin32_Nuclear_Effect_IsInSegmPak00);
    tolua_function(tolua_S,"SetSegmPak",tolua_engineWin32_Nuclear_Effect_SetSegmPak00);
    tolua_function(tolua_S,"AssureResource",tolua_engineWin32_Nuclear_Effect_AssureResource00);
    tolua_function(tolua_S,"Release",tolua_engineWin32_Nuclear_Effect_Release00);
    tolua_function(tolua_S,"SetScaleType",tolua_engineWin32_Nuclear_Effect_SetScaleType00);
    tolua_function(tolua_S,"GetScaleType",tolua_engineWin32_Nuclear_Effect_GetScaleType00);
    tolua_function(tolua_S,"AddNotify",tolua_engineWin32_Nuclear_Effect_AddNotify00);
    tolua_function(tolua_S,"RemoveNotify",tolua_engineWin32_Nuclear_Effect_RemoveNotify00);
    tolua_function(tolua_S,"ClearNotify",tolua_engineWin32_Nuclear_Effect_ClearNotify00);
    tolua_function(tolua_S,"HoldRes",tolua_engineWin32_Nuclear_Effect_HoldRes00);
    tolua_function(tolua_S,"Play",tolua_engineWin32_Nuclear_Effect_Play00);
    tolua_function(tolua_S,"Stop",tolua_engineWin32_Nuclear_Effect_Stop00);
    tolua_function(tolua_S,"Pause",tolua_engineWin32_Nuclear_Effect_Pause00);
    tolua_function(tolua_S,"Resume",tolua_engineWin32_Nuclear_Effect_Resume00);
    tolua_function(tolua_S,"GetPlayState",tolua_engineWin32_Nuclear_Effect_GetPlayState00);
    tolua_function(tolua_S,"GetName",tolua_engineWin32_Nuclear_Effect_GetName00);
    tolua_function(tolua_S,"SetScreenCrood",tolua_engineWin32_Nuclear_Effect_SetScreenCrood00);
    tolua_function(tolua_S,"IsScreenCrood",tolua_engineWin32_Nuclear_Effect_IsScreenCrood00);
    tolua_function(tolua_S,"GetRelBouningBox",tolua_engineWin32_Nuclear_Effect_GetRelBouningBox00);
    tolua_function(tolua_S,"GetDirection",tolua_engineWin32_Nuclear_Effect_GetDirection00);
    tolua_function(tolua_S,"GetLocation",tolua_engineWin32_Nuclear_Effect_GetLocation00);
    tolua_function(tolua_S,"GetTranslation",tolua_engineWin32_Nuclear_Effect_GetTranslation00);
    tolua_function(tolua_S,"GetScale",tolua_engineWin32_Nuclear_Effect_GetScale00);
    tolua_function(tolua_S,"GetRotationRadian",tolua_engineWin32_Nuclear_Effect_GetRotationRadian00);
    tolua_function(tolua_S,"GetVertexColor",tolua_engineWin32_Nuclear_Effect_GetVertexColor00);
    tolua_function(tolua_S,"GetTransparent",tolua_engineWin32_Nuclear_Effect_GetTransparent00);
    tolua_function(tolua_S,"GetColorate",tolua_engineWin32_Nuclear_Effect_GetColorate00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_Effect_SetDirection00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_Effect_SetDirection01);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_Effect_SetDirection02);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_Effect_SetLocation00);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_Effect_SetLocation01);
    tolua_function(tolua_S,"SetTranslation",tolua_engineWin32_Nuclear_Effect_SetTranslation00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_Effect_SetScale00);
    tolua_function(tolua_S,"SetRotationRadian",tolua_engineWin32_Nuclear_Effect_SetRotationRadian00);
    tolua_function(tolua_S,"SetVertexColor",tolua_engineWin32_Nuclear_Effect_SetVertexColor00);
    tolua_function(tolua_S,"SetTransparent",tolua_engineWin32_Nuclear_Effect_SetTransparent00);
    tolua_function(tolua_S,"Colorate",tolua_engineWin32_Nuclear_Effect_Colorate00);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_Effect_GetType00);
    tolua_function(tolua_S,"GetPlayMode",tolua_engineWin32_Nuclear_Effect_GetPlayMode00);
    tolua_function(tolua_S,"GetLoopNum",tolua_engineWin32_Nuclear_Effect_GetLoopNum00);
    tolua_function(tolua_S,"GetPlayTime",tolua_engineWin32_Nuclear_Effect_GetPlayTime00);
    tolua_function(tolua_S,"SetLoopNum",tolua_engineWin32_Nuclear_Effect_SetLoopNum00);
    tolua_function(tolua_S,"SetPlayTime",tolua_engineWin32_Nuclear_Effect_SetPlayTime00);
    tolua_function(tolua_S,"GetPlayOnceTime",tolua_engineWin32_Nuclear_Effect_GetPlayOnceTime00);
    tolua_function(tolua_S,"GetBase",tolua_engineWin32_Nuclear_Effect_GetBase00);
    tolua_function(tolua_S,"SetSoundType",tolua_engineWin32_Nuclear_Effect_SetSoundType00);
    tolua_function(tolua_S,"GetSoundType",tolua_engineWin32_Nuclear_Effect_GetSoundType00);
    tolua_function(tolua_S,"SetSoundPriority",tolua_engineWin32_Nuclear_Effect_SetSoundPriority00);
    tolua_function(tolua_S,"GetSoundPriority",tolua_engineWin32_Nuclear_Effect_GetSoundPriority00);
    tolua_function(tolua_S,"RemoveAudio",tolua_engineWin32_Nuclear_Effect_RemoveAudio00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"LINE","Nuclear::LINE","",tolua_collect_Nuclear__LINE);
   #else
   tolua_cclass(tolua_S,"LINE","Nuclear::LINE","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"LINE");
    tolua_variable(tolua_S,"pt0",tolua_get_Nuclear__LINE_pt0,tolua_set_Nuclear__LINE_pt0);
    tolua_variable(tolua_S,"pt1",tolua_get_Nuclear__LINE_pt1,tolua_set_Nuclear__LINE_pt1);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_LINE_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_LINE_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_LINE_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_LINE_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_LINE_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_LINE_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_LINE_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_LINE_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_LINE_new02_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"PSModifyParam","Nuclear::PSModifyParam","",tolua_collect_Nuclear__PSModifyParam);
   #else
   tolua_cclass(tolua_S,"PSModifyParam","Nuclear::PSModifyParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"PSModifyParam");
    tolua_variable(tolua_S,"m_pointCent",tolua_get_Nuclear__PSModifyParam_m_pointCent,tolua_set_Nuclear__PSModifyParam_m_pointCent);
    tolua_variable(tolua_S,"m_fEmitterSpinAngle",tolua_get_Nuclear__PSModifyParam_m_fEmitterSpinAngle,tolua_set_Nuclear__PSModifyParam_m_fEmitterSpinAngle);
    tolua_variable(tolua_S,"m_pointObject",tolua_get_Nuclear__PSModifyParam_m_pointObject,tolua_set_Nuclear__PSModifyParam_m_pointObject);
    tolua_variable(tolua_S,"m_fEmissionScale",tolua_get_Nuclear__PSModifyParam_m_fEmissionScale,tolua_set_Nuclear__PSModifyParam_m_fEmissionScale);
    tolua_variable(tolua_S,"m_fLineLength",tolua_get_Nuclear__PSModifyParam_m_fLineLength,tolua_set_Nuclear__PSModifyParam_m_fLineLength);
    tolua_variable(tolua_S,"m_fRctWidth",tolua_get_Nuclear__PSModifyParam_m_fRctWidth,tolua_set_Nuclear__PSModifyParam_m_fRctWidth);
    tolua_variable(tolua_S,"m_fRctHeight",tolua_get_Nuclear__PSModifyParam_m_fRctHeight,tolua_set_Nuclear__PSModifyParam_m_fRctHeight);
    tolua_variable(tolua_S,"m_scaleType",tolua_get_Nuclear__PSModifyParam_m_scaleType,tolua_set_Nuclear__PSModifyParam_m_scaleType);
    tolua_variable(tolua_S,"m_fParticleSizeCoef",tolua_get_Nuclear__PSModifyParam_m_fParticleSizeCoef,tolua_set_Nuclear__PSModifyParam_m_fParticleSizeCoef);
    tolua_variable(tolua_S,"m_fParticlePosCoef",tolua_get_Nuclear__PSModifyParam_m_fParticlePosCoef,tolua_set_Nuclear__PSModifyParam_m_fParticlePosCoef);
    tolua_variable(tolua_S,"m_fpoint0",tolua_get_Nuclear__PSModifyParam_m_fpoint0,tolua_set_Nuclear__PSModifyParam_m_fpoint0);
    tolua_variable(tolua_S,"m_fpoint1",tolua_get_Nuclear__PSModifyParam_m_fpoint1,tolua_set_Nuclear__PSModifyParam_m_fpoint1);
    tolua_variable(tolua_S,"m_fLineEmitterRotate",tolua_get_Nuclear__PSModifyParam_m_fLineEmitterRotate,tolua_set_Nuclear__PSModifyParam_m_fLineEmitterRotate);
    tolua_variable(tolua_S,"m_dwColor",tolua_get_Nuclear__PSModifyParam_m_dwColor,tolua_set_Nuclear__PSModifyParam_m_dwColor);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_PSModifyParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_PSModifyParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_PSModifyParam_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"PSParameter","Nuclear::PSParameter","",tolua_collect_Nuclear__PSParameter);
   #else
   tolua_cclass(tolua_S,"PSParameter","Nuclear::PSParameter","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"PSParameter");
    tolua_variable(tolua_S,"m_psModifyParam",tolua_get_Nuclear__PSParameter_m_psModifyParam,tolua_set_Nuclear__PSParameter_m_psModifyParam);
    tolua_variable(tolua_S,"time",tolua_get_Nuclear__PSParameter_time,tolua_set_Nuclear__PSParameter_time);
    tolua_variable(tolua_S,"layer",tolua_get_Nuclear__PSParameter_layer,tolua_set_Nuclear__PSParameter_layer);
    tolua_variable(tolua_S,"m_bScreenCoord",tolua_get_Nuclear__PSParameter_m_bScreenCoord,tolua_set_Nuclear__PSParameter_m_bScreenCoord);
    tolua_variable(tolua_S,"cycle",tolua_get_Nuclear__PSParameter_cycle,tolua_set_Nuclear__PSParameter_cycle);
    tolua_variable(tolua_S,"autorender",tolua_get_Nuclear__PSParameter_autorender,tolua_set_Nuclear__PSParameter_autorender);
    tolua_variable(tolua_S,"m_bVertexRHWflag",tolua_get_Nuclear__PSParameter_m_bVertexRHWflag,tolua_set_Nuclear__PSParameter_m_bVertexRHWflag);
    tolua_variable(tolua_S,"m_bModifyLineEmitter",tolua_get_Nuclear__PSParameter_m_bModifyLineEmitter,tolua_set_Nuclear__PSParameter_m_bModifyLineEmitter);
    tolua_variable(tolua_S,"m_ptLineEmitterStrt",tolua_get_Nuclear__PSParameter_m_ptLineEmitterStrt,tolua_set_Nuclear__PSParameter_m_ptLineEmitterStrt);
    tolua_variable(tolua_S,"m_ptLineEmitterEnd",tolua_get_Nuclear__PSParameter_m_ptLineEmitterEnd,tolua_set_Nuclear__PSParameter_m_ptLineEmitterEnd);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_PSParameter_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_PSParameter_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_PSParameter_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"PSLMOVETYPE_DEFAULT",Nuclear::PSLMOVETYPE_DEFAULT);
   tolua_constant(tolua_S,"PSLMOVETYPE_FOLLOWSPRITE",Nuclear::PSLMOVETYPE_FOLLOWSPRITE);
   tolua_constant(tolua_S,"PSLMOVETYPE_FULLSCREEN",Nuclear::PSLMOVETYPE_FULLSCREEN);
   tolua_constant(tolua_S,"PARTICLEPATHPOS_START",Nuclear::PARTICLEPATHPOS_START);
   tolua_constant(tolua_S,"PARTICLEPATHPOS_RANDOM",Nuclear::PARTICLEPATHPOS_RANDOM);
   tolua_constant(tolua_S,"PARTICLEPATHPOS_PREPOS",Nuclear::PARTICLEPATHPOS_PREPOS);
   tolua_constant(tolua_S,"PARTICLESIZERAND_XY",Nuclear::PARTICLESIZERAND_XY);
   tolua_constant(tolua_S,"PARTICLESIZERAND_X",Nuclear::PARTICLESIZERAND_X);
   tolua_constant(tolua_S,"PARTICLESIZERAND_Y",Nuclear::PARTICLESIZERAND_Y);
   tolua_constant(tolua_S,"PARTICLESIZERAND_ZOOM",Nuclear::PARTICLESIZERAND_ZOOM);
   tolua_constant(tolua_S,"PSLTYPE_POINT",Nuclear::PSLTYPE_POINT);
   tolua_constant(tolua_S,"PSLTYPE_LINE",Nuclear::PSLTYPE_LINE);
   tolua_constant(tolua_S,"PSLTYPE_CIRCLE",Nuclear::PSLTYPE_CIRCLE);
   tolua_constant(tolua_S,"PSLTYPE_RECT",Nuclear::PSLTYPE_RECT);
   tolua_constant(tolua_S,"PSLTYPE_CUSTOMPATH",Nuclear::PSLTYPE_CUSTOMPATH);
   tolua_constant(tolua_S,"PATHMIRRORTYPE_NONE",Nuclear::PATHMIRRORTYPE_NONE);
   tolua_constant(tolua_S,"PATHMIRRORTYPE_LR",Nuclear::PATHMIRRORTYPE_LR);
   tolua_constant(tolua_S,"PATHMIRRORTYPE_TB",Nuclear::PATHMIRRORTYPE_TB);
   tolua_constant(tolua_S,"PATHMIRRORTYPE_LRTB",Nuclear::PATHMIRRORTYPE_LRTB);
   tolua_constant(tolua_S,"PSLCONFIGREQ_L",Nuclear::PSLCONFIGREQ_L);
   tolua_constant(tolua_S,"PSLCONFIGREQ_M",Nuclear::PSLCONFIGREQ_M);
   tolua_constant(tolua_S,"PSLCONFIGREQ_H",Nuclear::PSLCONFIGREQ_H);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"PSINFO","Nuclear::PSINFO","",tolua_collect_Nuclear__PSINFO);
   #else
   tolua_cclass(tolua_S,"PSINFO","Nuclear::PSINFO","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"PSINFO");
    tolua_variable(tolua_S,"m_rctMaxBox",tolua_get_Nuclear__PSINFO_m_rctMaxBox,tolua_set_Nuclear__PSINFO_m_rctMaxBox);
    tolua_variable(tolua_S,"m_pointCent",tolua_get_Nuclear__PSINFO_m_pointCent,tolua_set_Nuclear__PSINFO_m_pointCent);
    tolua_variable(tolua_S,"m_moveType",tolua_get_Nuclear__PSINFO_m_moveType,tolua_set_Nuclear__PSINFO_m_moveType);
    tolua_variable(tolua_S,"m_emisType",tolua_get_Nuclear__PSINFO_m_emisType,tolua_set_Nuclear__PSINFO_m_emisType);
    tolua_variable(tolua_S,"m_nPSLConfigReq",tolua_get_Nuclear__PSINFO_m_nPSLConfigReq,tolua_set_Nuclear__PSINFO_m_nPSLConfigReq);
    tolua_variable(tolua_S,"m_bCycle",tolua_get_Nuclear__PSINFO_m_bCycle,tolua_set_Nuclear__PSINFO_m_bCycle);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_PSINFO_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_PSINFO_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_PSINFO_new00_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"PSLLOADERROR_SUCC",Nuclear::PSLLOADERROR_SUCC);
   tolua_constant(tolua_S,"PSLLOADERROR_FILE",Nuclear::PSLLOADERROR_FILE);
   tolua_constant(tolua_S,"PSLLOADERROR_TEXTURE",Nuclear::PSLLOADERROR_TEXTURE);
   tolua_constant(tolua_S,"PSLLOADERROR_PATH",Nuclear::PSLLOADERROR_PATH);
   tolua_constant(tolua_S,"PSLLOADERROR_SHAPELIST",Nuclear::PSLLOADERROR_SHAPELIST);
   tolua_constant(tolua_S,"PSLSHAPETYPE_VORONOI",Nuclear::PSLSHAPETYPE_VORONOI);
   tolua_constant(tolua_S,"PSLSHAPETYPE_RECTANGLE",Nuclear::PSLSHAPETYPE_RECTANGLE);
   tolua_constant(tolua_S,"PSLSHAPETYPE_TRIANGLE",Nuclear::PSLSHAPETYPE_TRIANGLE);
   tolua_constant(tolua_S,"PSLSHAPETYPE_2PIC",Nuclear::PSLSHAPETYPE_2PIC);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IParticleEffect","Nuclear::IParticleEffect","",tolua_collect_Nuclear__IParticleEffect);
   #else
   tolua_cclass(tolua_S,"IParticleEffect","Nuclear::IParticleEffect","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IParticleEffect");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IParticleEffect_delete00);
    tolua_function(tolua_S,"ModifyObjectPoint",tolua_engineWin32_Nuclear_IParticleEffect_ModifyObjectPoint00);
    tolua_function(tolua_S,"ModifyLineLength",tolua_engineWin32_Nuclear_IParticleEffect_ModifyLineLength00);
    tolua_function(tolua_S,"ModifyRectWH",tolua_engineWin32_Nuclear_IParticleEffect_ModifyRectWH00);
    tolua_function(tolua_S,"SetRctBlindAreas",tolua_engineWin32_Nuclear_IParticleEffect_SetRctBlindAreas00);
    tolua_function(tolua_S,"SetCycleMode",tolua_engineWin32_Nuclear_IParticleEffect_SetCycleMode00);
    tolua_function(tolua_S,"GetCycleMode",tolua_engineWin32_Nuclear_IParticleEffect_GetCycleMode00);
    tolua_function(tolua_S,"SetSysLife",tolua_engineWin32_Nuclear_IParticleEffect_SetSysLife00);
    tolua_function(tolua_S,"GetSysLife",tolua_engineWin32_Nuclear_IParticleEffect_GetSysLife00);
    tolua_function(tolua_S,"SetEmitterLinkPoint",tolua_engineWin32_Nuclear_IParticleEffect_SetEmitterLinkPoint00);
    tolua_function(tolua_S,"GetEmitterLinkPoint",tolua_engineWin32_Nuclear_IParticleEffect_GetEmitterLinkPoint00);
    tolua_function(tolua_S,"GetNumActiveParticles",tolua_engineWin32_Nuclear_IParticleEffect_GetNumActiveParticles00);
    tolua_function(tolua_S,"GetParticleMaxLife",tolua_engineWin32_Nuclear_IParticleEffect_GetParticleMaxLife00);
    tolua_function(tolua_S,"SetSpecialPsTexture",tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsTexture00);
    tolua_function(tolua_S,"GetSpecialPSTextureHandle",tolua_engineWin32_Nuclear_IParticleEffect_GetSpecialPSTextureHandle00);
    tolua_function(tolua_S,"SetSpecialPsScale",tolua_engineWin32_Nuclear_IParticleEffect_SetSpecialPsScale00);
    tolua_function(tolua_S,"SetSilentTime",tolua_engineWin32_Nuclear_IParticleEffect_SetSilentTime00);
    tolua_function(tolua_S,"ConvertToIEffect",tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect00);
    tolua_function(tolua_S,"ConvertToIEffect",tolua_engineWin32_Nuclear_IParticleEffect_ConvertToIEffect01);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ParticleEffect","Nuclear::ParticleEffect","Nuclear::Effect",tolua_collect_Nuclear__ParticleEffect);
   #else
   tolua_cclass(tolua_S,"ParticleEffect","Nuclear::ParticleEffect","Nuclear::Effect",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ParticleEffect");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ParticleEffect_delete00);
    tolua_function(tolua_S,"SetScaleType",tolua_engineWin32_Nuclear_ParticleEffect_SetScaleType00);
    tolua_function(tolua_S,"GetScaleType",tolua_engineWin32_Nuclear_ParticleEffect_GetScaleType00);
    tolua_function(tolua_S,"OnReady",tolua_engineWin32_Nuclear_ParticleEffect_OnReady00);
    tolua_function(tolua_S,"AssureResource",tolua_engineWin32_Nuclear_ParticleEffect_AssureResource00);
    tolua_function(tolua_S,"Release",tolua_engineWin32_Nuclear_ParticleEffect_Release00);
    tolua_function(tolua_S,"GetType",tolua_engineWin32_Nuclear_ParticleEffect_GetType00);
    tolua_function(tolua_S,"SetEffectBindType",tolua_engineWin32_Nuclear_ParticleEffect_SetEffectBindType00);
    tolua_function(tolua_S,"GetEffectBindType",tolua_engineWin32_Nuclear_ParticleEffect_GetEffectBindType00);
    tolua_function(tolua_S,"SetScreenCrood",tolua_engineWin32_Nuclear_ParticleEffect_SetScreenCrood00);
    tolua_function(tolua_S,"IsScreenCrood",tolua_engineWin32_Nuclear_ParticleEffect_IsScreenCrood00);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_ParticleEffect_SetLocation00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_ParticleEffect_Render00);
    tolua_function(tolua_S,"CollectRender",tolua_engineWin32_Nuclear_ParticleEffect_CollectRender00);
    tolua_function(tolua_S,"SetLoopNum",tolua_engineWin32_Nuclear_ParticleEffect_SetLoopNum00);
    tolua_function(tolua_S,"SetPlayTime",tolua_engineWin32_Nuclear_ParticleEffect_SetPlayTime00);
    tolua_function(tolua_S,"SetCycleMode",tolua_engineWin32_Nuclear_ParticleEffect_SetCycleMode00);
    tolua_function(tolua_S,"GetCycleMode",tolua_engineWin32_Nuclear_ParticleEffect_GetCycleMode00);
    tolua_function(tolua_S,"SetSysLife",tolua_engineWin32_Nuclear_ParticleEffect_SetSysLife00);
    tolua_function(tolua_S,"GetSysLife",tolua_engineWin32_Nuclear_ParticleEffect_GetSysLife00);
    tolua_function(tolua_S,"SetEmitterLinkPoint",tolua_engineWin32_Nuclear_ParticleEffect_SetEmitterLinkPoint00);
    tolua_function(tolua_S,"GetEmitterLinkPoint",tolua_engineWin32_Nuclear_ParticleEffect_GetEmitterLinkPoint00);
    tolua_function(tolua_S,"Play",tolua_engineWin32_Nuclear_ParticleEffect_Play00);
    tolua_function(tolua_S,"GetPlayOnceTime",tolua_engineWin32_Nuclear_ParticleEffect_GetPlayOnceTime00);
    tolua_function(tolua_S,"GetBase",tolua_engineWin32_Nuclear_ParticleEffect_GetBase00);
    tolua_function(tolua_S,"SetVertexColor",tolua_engineWin32_Nuclear_ParticleEffect_SetVertexColor00);
    tolua_function(tolua_S,"SetTransparent",tolua_engineWin32_Nuclear_ParticleEffect_SetTransparent00);
    tolua_function(tolua_S,"Colorate",tolua_engineWin32_Nuclear_ParticleEffect_Colorate00);
    tolua_function(tolua_S,"GetColorate",tolua_engineWin32_Nuclear_ParticleEffect_GetColorate00);
    tolua_function(tolua_S,"GetVertexColor",tolua_engineWin32_Nuclear_ParticleEffect_GetVertexColor00);
    tolua_function(tolua_S,"GetTransparent",tolua_engineWin32_Nuclear_ParticleEffect_GetTransparent00);
    tolua_function(tolua_S,"TryConvertToParticle",tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticle00);
    tolua_function(tolua_S,"TryConvertToParticleEffect",tolua_engineWin32_Nuclear_ParticleEffect_TryConvertToParticleEffect00);
    tolua_function(tolua_S,"ModifyObjectPoint",tolua_engineWin32_Nuclear_ParticleEffect_ModifyObjectPoint00);
    tolua_function(tolua_S,"ModifyLineLength",tolua_engineWin32_Nuclear_ParticleEffect_ModifyLineLength00);
    tolua_function(tolua_S,"ModifyRectWH",tolua_engineWin32_Nuclear_ParticleEffect_ModifyRectWH00);
    tolua_function(tolua_S,"GetNumActiveParticles",tolua_engineWin32_Nuclear_ParticleEffect_GetNumActiveParticles00);
    tolua_function(tolua_S,"GetParticleSystemInfo",tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemInfo00);
    tolua_function(tolua_S,"GetParticleSystemParameter",tolua_engineWin32_Nuclear_ParticleEffect_GetParticleSystemParameter00);
    tolua_function(tolua_S,"GetParticleMaxLife",tolua_engineWin32_Nuclear_ParticleEffect_GetParticleMaxLife00);
    tolua_function(tolua_S,"SetSpecialPsTexture",tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsTexture00);
    tolua_function(tolua_S,"GetSpecialPSTextureHandle",tolua_engineWin32_Nuclear_ParticleEffect_GetSpecialPSTextureHandle00);
    tolua_function(tolua_S,"SetSpecialPsScale",tolua_engineWin32_Nuclear_ParticleEffect_SetSpecialPsScale00);
    tolua_function(tolua_S,"SetSilentTime",tolua_engineWin32_Nuclear_ParticleEffect_SetSilentTime00);
    tolua_function(tolua_S,"ConvertToIEffect",tolua_engineWin32_Nuclear_ParticleEffect_ConvertToIEffect00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_constant(tolua_S,"XPSC_ALL",Nuclear::XPSC_ALL);
   tolua_constant(tolua_S,"XPSC_MAXCOUNT",Nuclear::XPSC_MAXCOUNT);
   tolua_constant(tolua_S,"XPUSAT_MOVESTATE",Nuclear::XPUSAT_MOVESTATE);
   tolua_constant(tolua_S,"XPUSAT_MOVEINFLEXION",Nuclear::XPUSAT_MOVEINFLEXION);
   tolua_constant(tolua_S,"XPUSAT_PLAYACTIONFINISH",Nuclear::XPUSAT_PLAYACTIONFINISH);
   tolua_constant(tolua_S,"XPUSAT_DEFAULTACTIONFINISH",Nuclear::XPUSAT_DEFAULTACTIONFINISH);
   tolua_constant(tolua_S,"XPUSAT_TELEPORTEND",Nuclear::XPUSAT_TELEPORTEND);
   tolua_constant(tolua_S,"XPSPREFFFLAG_BIND_EFF_POS",Nuclear::XPSPREFFFLAG_BIND_EFF_POS);
   tolua_constant(tolua_S,"XPSPREFFFLAG_BIND_AUTO",Nuclear::XPSPREFFFLAG_BIND_AUTO);
   tolua_constant(tolua_S,"XPSPREFFFLAG_BIND_WEAPON",Nuclear::XPSPREFFFLAG_BIND_WEAPON);
   tolua_constant(tolua_S,"XPSPREFFFLAG_BIND_WEAPON_0",Nuclear::XPSPREFFFLAG_BIND_WEAPON_0);
   tolua_constant(tolua_S,"XPSPREFFFLAG_BIND_WEAPON_1",Nuclear::XPSPREFFFLAG_BIND_WEAPON_1);
   tolua_constant(tolua_S,"XPSPREFFFLAG_LINKING_FRAME",Nuclear::XPSPREFFFLAG_LINKING_FRAME);
   tolua_constant(tolua_S,"XPSPREFFFLAG_SELF_REF",Nuclear::XPSPREFFFLAG_SELF_REF);
   tolua_constant(tolua_S,"XPSPREFFFLAG_ASYNC",Nuclear::XPSPREFFFLAG_ASYNC);
   tolua_constant(tolua_S,"XPSPREFFFLAG_NO_FOLLOW_SCALE",Nuclear::XPSPREFFFLAG_NO_FOLLOW_SCALE);
   tolua_constant(tolua_S,"XPSPREFFFLAG_NO_SOUND",Nuclear::XPSPREFFFLAG_NO_SOUND);
   tolua_constant(tolua_S,"XPSPREFFFLAG_DRAW_ON_TOP",Nuclear::XPSPREFFFLAG_DRAW_ON_TOP);
   tolua_constant(tolua_S,"XPSPREFFFLAG_DRAW_BEFORE_SPRITE",Nuclear::XPSPREFFFLAG_DRAW_BEFORE_SPRITE);
   tolua_constant(tolua_S,"XPSALT_SYNC",Nuclear::XPSALT_SYNC);
   tolua_constant(tolua_S,"XPSALT_ASYNC",Nuclear::XPSALT_ASYNC);
   tolua_constant(tolua_S,"XPSALT_BASE_ASYNC",Nuclear::XPSALT_BASE_ASYNC);
   tolua_cclass(tolua_S,"SpriteEventNotify","Nuclear::SpriteEventNotify","",NULL);
   tolua_beginmodule(tolua_S,"SpriteEventNotify");
    tolua_function(tolua_S,"OnEvents",tolua_engineWin32_Nuclear_SpriteEventNotify_OnEvents00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"SpriteNotify","Nuclear::SpriteNotify","",NULL);
   tolua_beginmodule(tolua_S,"SpriteNotify");
    tolua_function(tolua_S,"OnPlayFrame",tolua_engineWin32_Nuclear_SpriteNotify_OnPlayFrame00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"ISprite","Nuclear::ISprite","virtualISelectableObj",tolua_collect_Nuclear__ISprite);
   #else
   tolua_cclass(tolua_S,"ISprite","Nuclear::ISprite","virtualISelectableObj",NULL);
   #endif
   tolua_beginmodule(tolua_S,"ISprite");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_ISprite_delete00);
    tolua_function(tolua_S,"RegisterFrameNotify",tolua_engineWin32_Nuclear_ISprite_RegisterFrameNotify00);
    tolua_function(tolua_S,"DeregisterFrameNotify",tolua_engineWin32_Nuclear_ISprite_DeregisterFrameNotify00);
    tolua_function(tolua_S,"EnableStepSound",tolua_engineWin32_Nuclear_ISprite_EnableStepSound00);
    tolua_function(tolua_S,"IsStepSoundEnable",tolua_engineWin32_Nuclear_ISprite_IsStepSoundEnable00);
    tolua_function(tolua_S,"ClearAllNotify",tolua_engineWin32_Nuclear_ISprite_ClearAllNotify00);
    tolua_function(tolua_S,"GetSoundActorName",tolua_engineWin32_Nuclear_ISprite_GetSoundActorName00);
    tolua_function(tolua_S,"DumpAllActionNames",tolua_engineWin32_Nuclear_ISprite_DumpAllActionNames00);
    tolua_function(tolua_S,"SetScale",tolua_engineWin32_Nuclear_ISprite_SetScale00);
    tolua_function(tolua_S,"GetScale",tolua_engineWin32_Nuclear_ISprite_GetScale00);
    tolua_function(tolua_S,"SetLocation",tolua_engineWin32_Nuclear_ISprite_SetLocation00);
    tolua_function(tolua_S,"GetLocation",tolua_engineWin32_Nuclear_ISprite_GetLocation00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_ISprite_SetDirection00);
    tolua_function(tolua_S,"GetDirection",tolua_engineWin32_Nuclear_ISprite_GetDirection00);
    tolua_function(tolua_S,"GetVectorDirection",tolua_engineWin32_Nuclear_ISprite_GetVectorDirection00);
    tolua_function(tolua_S,"UseRenderTarget",tolua_engineWin32_Nuclear_ISprite_UseRenderTarget00);
    tolua_function(tolua_S,"IsUseRenderTarget",tolua_engineWin32_Nuclear_ISprite_IsUseRenderTarget00);
    tolua_function(tolua_S,"SetVisible",tolua_engineWin32_Nuclear_ISprite_SetVisible00);
    tolua_function(tolua_S,"IsVisiable",tolua_engineWin32_Nuclear_ISprite_IsVisiable00);
    tolua_function(tolua_S,"SetEntityVisible",tolua_engineWin32_Nuclear_ISprite_SetEntityVisible00);
    tolua_function(tolua_S,"IsEntityVisible",tolua_engineWin32_Nuclear_ISprite_IsEntityVisible00);
    tolua_function(tolua_S,"SetTitleVisible",tolua_engineWin32_Nuclear_ISprite_SetTitleVisible00);
    tolua_function(tolua_S,"IsTitleVisible",tolua_engineWin32_Nuclear_ISprite_IsTitleVisible00);
    tolua_function(tolua_S,"SetAlpha",tolua_engineWin32_Nuclear_ISprite_SetAlpha00);
    tolua_function(tolua_S,"GetAlpha",tolua_engineWin32_Nuclear_ISprite_GetAlpha00);
    tolua_function(tolua_S,"IsCoveredAlpha",tolua_engineWin32_Nuclear_ISprite_IsCoveredAlpha00);
    tolua_function(tolua_S,"SetCoveredAlpha",tolua_engineWin32_Nuclear_ISprite_SetCoveredAlpha00);
    tolua_function(tolua_S,"IsSolidMask",tolua_engineWin32_Nuclear_ISprite_IsSolidMask00);
    tolua_function(tolua_S,"SetSolidMask",tolua_engineWin32_Nuclear_ISprite_SetSolidMask00);
    tolua_function(tolua_S,"IsUpdateEveryFrame",tolua_engineWin32_Nuclear_ISprite_IsUpdateEveryFrame00);
    tolua_function(tolua_S,"SetUpdateEveryFrame",tolua_engineWin32_Nuclear_ISprite_SetUpdateEveryFrame00);
    tolua_function(tolua_S,"SetTitle",tolua_engineWin32_Nuclear_ISprite_SetTitle00);
    tolua_function(tolua_S,"GetTitle",tolua_engineWin32_Nuclear_ISprite_GetTitle00);
    tolua_function(tolua_S,"UnsetTitle",tolua_engineWin32_Nuclear_ISprite_UnsetTitle00);
    tolua_function(tolua_S,"SetTitleSize",tolua_engineWin32_Nuclear_ISprite_SetTitleSize00);
    tolua_function(tolua_S,"GetTitleWidth",tolua_engineWin32_Nuclear_ISprite_GetTitleWidth00);
    tolua_function(tolua_S,"GetTitleHeight",tolua_engineWin32_Nuclear_ISprite_GetTitleHeight00);
    tolua_function(tolua_S,"SetTitleBindSocket",tolua_engineWin32_Nuclear_ISprite_SetTitleBindSocket00);
    tolua_function(tolua_S,"GetTitleBindSocket",tolua_engineWin32_Nuclear_ISprite_GetTitleBindSocket00);
    tolua_function(tolua_S,"GetBubbleItemOffset",tolua_engineWin32_Nuclear_ISprite_GetBubbleItemOffset00);
    tolua_function(tolua_S,"GetEffectPos",tolua_engineWin32_Nuclear_ISprite_GetEffectPos00);
    tolua_function(tolua_S,"SetModel",tolua_engineWin32_Nuclear_ISprite_SetModel00);
    tolua_function(tolua_S,"SetModel",tolua_engineWin32_Nuclear_ISprite_SetModel01);
    tolua_function(tolua_S,"GetModelName",tolua_engineWin32_Nuclear_ISprite_GetModelName00);
    tolua_function(tolua_S,"SetComponent",tolua_engineWin32_Nuclear_ISprite_SetComponent00);
    tolua_function(tolua_S,"GetComponent",tolua_engineWin32_Nuclear_ISprite_GetComponent00);
    tolua_function(tolua_S,"GetComponentColor",tolua_engineWin32_Nuclear_ISprite_GetComponentColor00);
    tolua_function(tolua_S,"SetRideName",tolua_engineWin32_Nuclear_ISprite_SetRideName00);
    tolua_function(tolua_S,"SetMinMaxEffectAlpha",tolua_engineWin32_Nuclear_ISprite_SetMinMaxEffectAlpha00);
    tolua_function(tolua_S,"GetMinEffectAlpha",tolua_engineWin32_Nuclear_ISprite_GetMinEffectAlpha00);
    tolua_function(tolua_S,"GetMaxEffectAlpha",tolua_engineWin32_Nuclear_ISprite_GetMaxEffectAlpha00);
    tolua_function(tolua_S,"PrefetchAction",tolua_engineWin32_Nuclear_ISprite_PrefetchAction00);
    tolua_function(tolua_S,"HoldAction",tolua_engineWin32_Nuclear_ISprite_HoldAction00);
    tolua_function(tolua_S,"ReleaseAction",tolua_engineWin32_Nuclear_ISprite_ReleaseAction00);
    tolua_function(tolua_S,"SetHoldLastFrame",tolua_engineWin32_Nuclear_ISprite_SetHoldLastFrame00);
    tolua_function(tolua_S,"SetDefaultAction",tolua_engineWin32_Nuclear_ISprite_SetDefaultAction00);
    tolua_function(tolua_S,"GetDefaultAction",tolua_engineWin32_Nuclear_ISprite_GetDefaultAction00);
    tolua_function(tolua_S,"PlayAction",tolua_engineWin32_Nuclear_ISprite_PlayAction00);
    tolua_function(tolua_S,"GetCurActionName",tolua_engineWin32_Nuclear_ISprite_GetCurActionName00);
    tolua_function(tolua_S,"GetActionTimeByName",tolua_engineWin32_Nuclear_ISprite_GetActionTimeByName00);
    tolua_function(tolua_S,"GetCurrentFrame",tolua_engineWin32_Nuclear_ISprite_GetCurrentFrame00);
    tolua_function(tolua_S,"GetTotalFrame",tolua_engineWin32_Nuclear_ISprite_GetTotalFrame00);
    tolua_function(tolua_S,"SetBindFile",tolua_engineWin32_Nuclear_ISprite_SetBindFile00);
    tolua_function(tolua_S,"GetBindFile",tolua_engineWin32_Nuclear_ISprite_GetBindFile00);
    tolua_function(tolua_S,"SetDurativeEffect",tolua_engineWin32_Nuclear_ISprite_SetDurativeEffect00);
    tolua_function(tolua_S,"SetContinueEffect",tolua_engineWin32_Nuclear_ISprite_SetContinueEffect00);
    tolua_function(tolua_S,"RemoveDurativeEffect",tolua_engineWin32_Nuclear_ISprite_RemoveDurativeEffect00);
    tolua_function(tolua_S,"ChangeEffectOffset",tolua_engineWin32_Nuclear_ISprite_ChangeEffectOffset00);
    tolua_function(tolua_S,"PlayEffect",tolua_engineWin32_Nuclear_ISprite_PlayEffect00);
    tolua_function(tolua_S,"PlayEffect",tolua_engineWin32_Nuclear_ISprite_PlayEffect01);
    tolua_function(tolua_S,"EnableShadow",tolua_engineWin32_Nuclear_ISprite_EnableShadow00);
    tolua_function(tolua_S,"IsEnableShadow",tolua_engineWin32_Nuclear_ISprite_IsEnableShadow00);
    tolua_function(tolua_S,"TeleportWithBlur",tolua_engineWin32_Nuclear_ISprite_TeleportWithBlur00);
    tolua_function(tolua_S,"SetTurnDir",tolua_engineWin32_Nuclear_ISprite_SetTurnDir00);
    tolua_function(tolua_S,"GetTurnDir",tolua_engineWin32_Nuclear_ISprite_GetTurnDir00);
    tolua_function(tolua_S,"SetHighlight",tolua_engineWin32_Nuclear_ISprite_SetHighlight00);
    tolua_function(tolua_S,"IsHighlight",tolua_engineWin32_Nuclear_ISprite_IsHighlight00);
    tolua_function(tolua_S,"SetMouseTestMode",tolua_engineWin32_Nuclear_ISprite_SetMouseTestMode00);
    tolua_function(tolua_S,"GetMouseTestMode",tolua_engineWin32_Nuclear_ISprite_GetMouseTestMode00);
    tolua_function(tolua_S,"SetActionSoundPriority",tolua_engineWin32_Nuclear_ISprite_SetActionSoundPriority00);
    tolua_function(tolua_S,"GetActionSoundPriority",tolua_engineWin32_Nuclear_ISprite_GetActionSoundPriority00);
    tolua_function(tolua_S,"SetMoveSpeed",tolua_engineWin32_Nuclear_ISprite_SetMoveSpeed00);
    tolua_function(tolua_S,"GetMoveSpeed",tolua_engineWin32_Nuclear_ISprite_GetMoveSpeed00);
    tolua_function(tolua_S,"StopMove",tolua_engineWin32_Nuclear_ISprite_StopMove00);
    tolua_function(tolua_S,"IsMoving",tolua_engineWin32_Nuclear_ISprite_IsMoving00);
    tolua_function(tolua_S,"SetMoveSuspended",tolua_engineWin32_Nuclear_ISprite_SetMoveSuspended00);
    tolua_function(tolua_S,"IsMoveSuspended",tolua_engineWin32_Nuclear_ISprite_IsMoveSuspended00);
    tolua_function(tolua_S,"MoveTo",tolua_engineWin32_Nuclear_ISprite_MoveTo00);
    tolua_function(tolua_S,"MoveTo",tolua_engineWin32_Nuclear_ISprite_MoveTo01);
    tolua_function(tolua_S,"StartShake",tolua_engineWin32_Nuclear_ISprite_StartShake00);
    tolua_function(tolua_S,"StopShake",tolua_engineWin32_Nuclear_ISprite_StopShake00);
    tolua_function(tolua_S,"SetCurveMove",tolua_engineWin32_Nuclear_ISprite_SetCurveMove00);
    tolua_function(tolua_S,"KeepMoveTrail",tolua_engineWin32_Nuclear_ISprite_KeepMoveTrail00);
    tolua_function(tolua_S,"IsKeepMoveTrail",tolua_engineWin32_Nuclear_ISprite_IsKeepMoveTrail00);
    tolua_function(tolua_S,"SetMoveMask",tolua_engineWin32_Nuclear_ISprite_SetMoveMask00);
    tolua_function(tolua_S,"GetLogicLocation",tolua_engineWin32_Nuclear_ISprite_GetLogicLocation00);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_ISprite_SetDirection01);
    tolua_function(tolua_S,"SetDirection",tolua_engineWin32_Nuclear_ISprite_SetDirection02);
    tolua_function(tolua_S,"InAttackRange",tolua_engineWin32_Nuclear_ISprite_InAttackRange00);
    tolua_function(tolua_S,"SetComponentAniReleaseFlag",tolua_engineWin32_Nuclear_ISprite_SetComponentAniReleaseFlag00);
    tolua_function(tolua_S,"GetLayerCount",tolua_engineWin32_Nuclear_ISprite_GetLayerCount00);
    tolua_function(tolua_S,"GetLayerIndexByName",tolua_engineWin32_Nuclear_ISprite_GetLayerIndexByName00);
    tolua_function(tolua_S,"GetLayerNameByIndex",tolua_engineWin32_Nuclear_ISprite_GetLayerNameByIndex00);
    tolua_function(tolua_S,"IsPartLayer",tolua_engineWin32_Nuclear_ISprite_IsPartLayer00);
    tolua_function(tolua_S,"SetDyePartIndex",tolua_engineWin32_Nuclear_ISprite_SetDyePartIndex00);
    tolua_function(tolua_S,"GetDyeEnable",tolua_engineWin32_Nuclear_ISprite_GetDyeEnable00);
    tolua_function(tolua_S,"GetDyePartCount",tolua_engineWin32_Nuclear_ISprite_GetDyePartCount00);
    tolua_function(tolua_S,"GetDyeProjCount",tolua_engineWin32_Nuclear_ISprite_GetDyeProjCount00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"GUObject","Nuclear::GUObject","",tolua_collect_Nuclear__GUObject);
   #else
   tolua_cclass(tolua_S,"GUObject","Nuclear::GUObject","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"GUObject");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_GUObject_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_GUObject_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_GUObject_new00_local);
    tolua_function(tolua_S,"GetGUID",tolua_engineWin32_Nuclear_GUObject_GetGUID00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_GUObject_delete00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Renderable","Nuclear::Renderable","Nuclear::GUObject",tolua_collect_Nuclear__Renderable);
   #else
   tolua_cclass(tolua_S,"Renderable","Nuclear::Renderable","Nuclear::GUObject",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Renderable");
    tolua_function(tolua_S,"RenderMid",tolua_engineWin32_Nuclear_Renderable_RenderMid00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_Renderable_Render00);
    tolua_function(tolua_S,"RenderBeforeMid",tolua_engineWin32_Nuclear_Renderable_RenderBeforeMid00);
    tolua_function(tolua_S,"RenderSpriteOnly",tolua_engineWin32_Nuclear_Renderable_RenderSpriteOnly00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_Renderable_delete00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"DrawElement","Nuclear::DrawElement","",tolua_collect_Nuclear__DrawElement);
   #else
   tolua_cclass(tolua_S,"DrawElement","Nuclear::DrawElement","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"DrawElement");
    tolua_variable(tolua_S,"m_pr",tolua_get_Nuclear__DrawElement_m_pr_ptr,tolua_set_Nuclear__DrawElement_m_pr_ptr);
    tolua_variable(tolua_S,"m_pos",tolua_get_Nuclear__DrawElement_m_pos,tolua_set_Nuclear__DrawElement_m_pos);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_DrawElement_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_DrawElement_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_DrawElement_new00_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Canvas","Nuclear::Canvas","",NULL);
   tolua_beginmodule(tolua_S,"Canvas");
    tolua_function(tolua_S,"Draw",tolua_engineWin32_Nuclear_Canvas_Draw00);
    tolua_function(tolua_S,"Clear",tolua_engineWin32_Nuclear_Canvas_Clear00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"EngineParameter","Nuclear::EngineParameter","",tolua_collect_Nuclear__EngineParameter);
   #else
   tolua_cclass(tolua_S,"EngineParameter","Nuclear::EngineParameter","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"EngineParameter");
    tolua_variable(tolua_S,"szWindowTitle",tolua_get_Nuclear__EngineParameter_szWindowTitle_ptr,tolua_set_Nuclear__EngineParameter_szWindowTitle_ptr);
    tolua_variable(tolua_S,"szClassName",tolua_get_Nuclear__EngineParameter_szClassName_ptr,tolua_set_Nuclear__EngineParameter_szClassName_ptr);
    tolua_variable(tolua_S,"dmode",tolua_get_Nuclear__EngineParameter_dmode,tolua_set_Nuclear__EngineParameter_dmode);
    tolua_variable(tolua_S,"bAsyncRead",tolua_get_Nuclear__EngineParameter_bAsyncRead,tolua_set_Nuclear__EngineParameter_bAsyncRead);
    tolua_variable(tolua_S,"bApplictionInBuild",tolua_get_Nuclear__EngineParameter_bApplictionInBuild,tolua_set_Nuclear__EngineParameter_bApplictionInBuild);
    tolua_variable(tolua_S,"bHasMaximizbox",tolua_get_Nuclear__EngineParameter_bHasMaximizbox,tolua_set_Nuclear__EngineParameter_bHasMaximizbox);
    tolua_variable(tolua_S,"bSizeBox",tolua_get_Nuclear__EngineParameter_bSizeBox,tolua_set_Nuclear__EngineParameter_bSizeBox);
    tolua_variable(tolua_S,"bEnableMipMap",tolua_get_Nuclear__EngineParameter_bEnableMipMap,tolua_set_Nuclear__EngineParameter_bEnableMipMap);
    tolua_variable(tolua_S,"dwRenderFlags",tolua_get_Nuclear__EngineParameter_dwRenderFlags,tolua_set_Nuclear__EngineParameter_dwRenderFlags);
    tolua_variable(tolua_S,"multiSampleType",tolua_get_Nuclear__EngineParameter_multiSampleType,tolua_set_Nuclear__EngineParameter_multiSampleType);
    tolua_variable(tolua_S,"nAppInitStepCount",tolua_get_Nuclear__EngineParameter_nAppInitStepCount,tolua_set_Nuclear__EngineParameter_nAppInitStepCount);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_EngineParameter_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_EngineParameter_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_EngineParameter_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IEngine","Nuclear::IEngine","",tolua_collect_Nuclear__IEngine);
   #else
   tolua_cclass(tolua_S,"IEngine","Nuclear::IEngine","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IEngine");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IEngine_delete00);
    tolua_function(tolua_S,"GetScreenWidth",tolua_engineWin32_Nuclear_IEngine_GetScreenWidth00);
    tolua_function(tolua_S,"GetScreenHeight",tolua_engineWin32_Nuclear_IEngine_GetScreenHeight00);
    tolua_function(tolua_S,"SetEngineLayer",tolua_engineWin32_Nuclear_IEngine_SetEngineLayer00);
    tolua_function(tolua_S,"GetEngineLayer",tolua_engineWin32_Nuclear_IEngine_GetEngineLayer00);
    tolua_function(tolua_S,"SetInfoLogPath",tolua_engineWin32_Nuclear_IEngine_SetInfoLogPath00);
    tolua_function(tolua_S,"SetErrorLogPath",tolua_engineWin32_Nuclear_IEngine_SetErrorLogPath00);
    tolua_function(tolua_S,"SetSegmpakLogPath",tolua_engineWin32_Nuclear_IEngine_SetSegmpakLogPath00);
    tolua_function(tolua_S,"Run",tolua_engineWin32_Nuclear_IEngine_Run00);
    tolua_function(tolua_S,"Exit",tolua_engineWin32_Nuclear_IEngine_Exit00);
    tolua_function(tolua_S,"OnIdle",tolua_engineWin32_Nuclear_IEngine_OnIdle00);
    tolua_function(tolua_S,"SetGameTimeSpeedScale",tolua_engineWin32_Nuclear_IEngine_SetGameTimeSpeedScale00);
    tolua_function(tolua_S,"GetGameTimeSpeedScale",tolua_engineWin32_Nuclear_IEngine_GetGameTimeSpeedScale00);
    tolua_function(tolua_S,"PutTask",tolua_engineWin32_Nuclear_IEngine_PutTask00);
    tolua_function(tolua_S,"ScheduleTimer",tolua_engineWin32_Nuclear_IEngine_ScheduleTimer00);
    tolua_function(tolua_S,"CancelTimer",tolua_engineWin32_Nuclear_IEngine_CancelTimer00);
    tolua_function(tolua_S,"GetWorld",tolua_engineWin32_Nuclear_IEngine_GetWorld00);
    tolua_function(tolua_S,"GetEnv",tolua_engineWin32_Nuclear_IEngine_GetEnv00);
    tolua_function(tolua_S,"GetApp",tolua_engineWin32_Nuclear_IEngine_GetApp00);
    tolua_function(tolua_S,"GetRenderer",tolua_engineWin32_Nuclear_IEngine_GetRenderer00);
    tolua_function(tolua_S,"GetFileIO",tolua_engineWin32_Nuclear_IEngine_GetFileIO00);
    tolua_function(tolua_S,"CreateEngineSprite",tolua_engineWin32_Nuclear_IEngine_CreateEngineSprite00);
    tolua_function(tolua_S,"SetEngineSpriteModel",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteModel00);
    tolua_function(tolua_S,"ReleaseEngineSprite",tolua_engineWin32_Nuclear_IEngine_ReleaseEngineSprite00);
    tolua_function(tolua_S,"RendererEngineSprite",tolua_engineWin32_Nuclear_IEngine_RendererEngineSprite00);
    tolua_function(tolua_S,"SetEngineSpriteLoc",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteLoc00);
    tolua_function(tolua_S,"SetEngineSpriteDirection",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection00);
    tolua_function(tolua_S,"SetEngineSpriteDirection",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDirection01);
    tolua_function(tolua_S,"SetEngineSpriteDefaultAction",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDefaultAction00);
    tolua_function(tolua_S,"SetEngineSpriteAction",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAction00);
    tolua_function(tolua_S,"SetEngineSpriteComponent",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteComponent00);
    tolua_function(tolua_S,"EnableEngineSpriteShadow",tolua_engineWin32_Nuclear_IEngine_EnableEngineSpriteShadow00);
    tolua_function(tolua_S,"SetEngineSpriteScale",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteScale00);
    tolua_function(tolua_S,"SetEngineSpriteAlpha",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteAlpha00);
    tolua_function(tolua_S,"GetEngineSpriteActionTimeByName",tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteActionTimeByName00);
    tolua_function(tolua_S,"SetEngineSpriteDurativeEffect",tolua_engineWin32_Nuclear_IEngine_SetEngineSpriteDurativeEffect00);
    tolua_function(tolua_S,"PlayEngineSpriteEffect",tolua_engineWin32_Nuclear_IEngine_PlayEngineSpriteEffect00);
    tolua_function(tolua_S,"RemoveEngineSpriteDurativeEffect",tolua_engineWin32_Nuclear_IEngine_RemoveEngineSpriteDurativeEffect00);
    tolua_function(tolua_S,"GetEngineSpriteBubbleItemOffset",tolua_engineWin32_Nuclear_IEngine_GetEngineSpriteBubbleItemOffset00);
    tolua_function(tolua_S,"EnableParticle",tolua_engineWin32_Nuclear_IEngine_EnableParticle00);
    tolua_function(tolua_S,"CreateEffect",tolua_engineWin32_Nuclear_IEngine_CreateEffect00);
    tolua_function(tolua_S,"DrawEffect",tolua_engineWin32_Nuclear_IEngine_DrawEffect00);
    tolua_function(tolua_S,"ReleaseEffect",tolua_engineWin32_Nuclear_IEngine_ReleaseEffect00);
    tolua_function(tolua_S,"HoldEffect",tolua_engineWin32_Nuclear_IEngine_HoldEffect00);
    tolua_function(tolua_S,"ReleaseEffect",tolua_engineWin32_Nuclear_IEngine_ReleaseEffect01);
    tolua_function(tolua_S,"CaptureWorld",tolua_engineWin32_Nuclear_IEngine_CaptureWorld00);
    tolua_function(tolua_S,"SetCleanColor",tolua_engineWin32_Nuclear_IEngine_SetCleanColor00);
    tolua_function(tolua_S,"GetWindowState",tolua_engineWin32_Nuclear_IEngine_GetWindowState00);
    tolua_function(tolua_S,"GCNow",tolua_engineWin32_Nuclear_IEngine_GCNow00);
    tolua_function(tolua_S,"setGCCooldown",tolua_engineWin32_Nuclear_IEngine_setGCCooldown00);
    tolua_function(tolua_S,"ResetFPSCounter",tolua_engineWin32_Nuclear_IEngine_ResetFPSCounter00);
    tolua_function(tolua_S,"GetFPS",tolua_engineWin32_Nuclear_IEngine_GetFPS00);
    tolua_function(tolua_S,"GetLatestFPS",tolua_engineWin32_Nuclear_IEngine_GetLatestFPS00);
    tolua_function(tolua_S,"GetLogicWidth",tolua_engineWin32_Nuclear_IEngine_GetLogicWidth00);
    tolua_function(tolua_S,"GetLogicHeight",tolua_engineWin32_Nuclear_IEngine_GetLogicHeight00);
    tolua_function(tolua_S,"GetWidth",tolua_engineWin32_Nuclear_IEngine_GetWidth00);
    tolua_function(tolua_S,"GetHeight",tolua_engineWin32_Nuclear_IEngine_GetHeight00);
    tolua_function(tolua_S,"GetTimeCount",tolua_engineWin32_Nuclear_IEngine_GetTimeCount00);
    tolua_function(tolua_S,"GetCurMemSize",tolua_engineWin32_Nuclear_IEngine_GetCurMemSize00);
    tolua_function(tolua_S,"GeCurAvailableMemSize",tolua_engineWin32_Nuclear_IEngine_GeCurAvailableMemSize00);
    tolua_function(tolua_S,"SetStepLoadTexture",tolua_engineWin32_Nuclear_IEngine_SetStepLoadTexture00);
    tolua_function(tolua_S,"GetStepLoadTexture",tolua_engineWin32_Nuclear_IEngine_GetStepLoadTexture00);
    tolua_function(tolua_S,"SetLimitFireThreadSecond",tolua_engineWin32_Nuclear_IEngine_SetLimitFireThreadSecond00);
    tolua_function(tolua_S,"GetLimitFireThreadSecond",tolua_engineWin32_Nuclear_IEngine_GetLimitFireThreadSecond00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"GetEngine",tolua_engineWin32_Nuclear_GetEngine00);
   tolua_cclass(tolua_S,"EngineBase","Nuclear::EngineBase","",NULL);
   tolua_beginmodule(tolua_S,"EngineBase");
    tolua_function(tolua_S,"GetSpriteManager",tolua_engineWin32_Nuclear_EngineBase_GetSpriteManager00);
    tolua_function(tolua_S,"GetAniManager",tolua_engineWin32_Nuclear_EngineBase_GetAniManager00);
    tolua_function(tolua_S,"GetXPWorld",tolua_engineWin32_Nuclear_EngineBase_GetXPWorld00);
    tolua_function(tolua_S,"GetWorldScale",tolua_engineWin32_Nuclear_EngineBase_GetWorldScale00);
    tolua_function(tolua_S,"GetEffectManager",tolua_engineWin32_Nuclear_EngineBase_GetEffectManager00);
    tolua_function(tolua_S,"GetRenderer",tolua_engineWin32_Nuclear_EngineBase_GetRenderer00);
    tolua_function(tolua_S,"GetSpritePictureHandle",tolua_engineWin32_Nuclear_EngineBase_GetSpritePictureHandle00);
    tolua_function(tolua_S,"GetConfigManager",tolua_engineWin32_Nuclear_EngineBase_GetConfigManager00);
    tolua_function(tolua_S,"GetViewport",tolua_engineWin32_Nuclear_EngineBase_GetViewport00);
    tolua_function(tolua_S,"GetTick",tolua_engineWin32_Nuclear_EngineBase_GetTick00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_EngineBase_Render00);
    tolua_function(tolua_S,"GetGameTime",tolua_engineWin32_Nuclear_EngineBase_GetGameTime00);
    tolua_function(tolua_S,"IsDaytime",tolua_engineWin32_Nuclear_EngineBase_IsDaytime00);
    tolua_function(tolua_S,"GetWaterDepth",tolua_engineWin32_Nuclear_EngineBase_GetWaterDepth00);
    tolua_function(tolua_S,"GetApp",tolua_engineWin32_Nuclear_EngineBase_GetApp00);
    tolua_function(tolua_S,"IsAsyncRead",tolua_engineWin32_Nuclear_EngineBase_IsAsyncRead00);
    tolua_function(tolua_S,"ScheduleTimer",tolua_engineWin32_Nuclear_EngineBase_ScheduleTimer00);
    tolua_function(tolua_S,"CancelTimer",tolua_engineWin32_Nuclear_EngineBase_CancelTimer00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Engine","Nuclear::Engine","Nuclear::IEngine",NULL);
   tolua_beginmodule(tolua_S,"Engine");
    tolua_function(tolua_S,"GetScreenWidth",tolua_engineWin32_Nuclear_Engine_GetScreenWidth00);
    tolua_function(tolua_S,"GetScreenHeight",tolua_engineWin32_Nuclear_Engine_GetScreenHeight00);
    tolua_function(tolua_S,"GetLogicWidth",tolua_engineWin32_Nuclear_Engine_GetLogicWidth00);
    tolua_function(tolua_S,"GetLogicHeight",tolua_engineWin32_Nuclear_Engine_GetLogicHeight00);
    tolua_function(tolua_S,"Draw",tolua_engineWin32_Nuclear_Engine_Draw00);
    tolua_function(tolua_S,"GetInstance",tolua_engineWin32_Nuclear_Engine_GetInstance00);
    tolua_function(tolua_S,"SetInfoLogPath",tolua_engineWin32_Nuclear_Engine_SetInfoLogPath00);
    tolua_function(tolua_S,"SetErrorLogPath",tolua_engineWin32_Nuclear_Engine_SetErrorLogPath00);
    tolua_function(tolua_S,"SetSegmpakLogPath",tolua_engineWin32_Nuclear_Engine_SetSegmpakLogPath00);
    tolua_function(tolua_S,"GetCurrentDirectory",tolua_engineWin32_Nuclear_Engine_GetCurrentDirectory00);
    tolua_function(tolua_S,"GetEnv",tolua_engineWin32_Nuclear_Engine_GetEnv00);
    tolua_function(tolua_S,"Exit",tolua_engineWin32_Nuclear_Engine_Exit00);
    tolua_function(tolua_S,"SetGameTimeSpeedScale",tolua_engineWin32_Nuclear_Engine_SetGameTimeSpeedScale00);
    tolua_function(tolua_S,"GetGameTimeSpeedScale",tolua_engineWin32_Nuclear_Engine_GetGameTimeSpeedScale00);
    tolua_function(tolua_S,"Render",tolua_engineWin32_Nuclear_Engine_Render00);
    tolua_function(tolua_S,"IsMultiSampleTypeEnable",tolua_engineWin32_Nuclear_Engine_IsMultiSampleTypeEnable00);
    tolua_function(tolua_S,"PutTask",tolua_engineWin32_Nuclear_Engine_PutTask00);
    tolua_function(tolua_S,"ScheduleTimer",tolua_engineWin32_Nuclear_Engine_ScheduleTimer00);
    tolua_function(tolua_S,"CancelTimer",tolua_engineWin32_Nuclear_Engine_CancelTimer00);
    tolua_function(tolua_S,"OnIdle",tolua_engineWin32_Nuclear_Engine_OnIdle00);
    tolua_function(tolua_S,"SetSystemLevel",tolua_engineWin32_Nuclear_Engine_SetSystemLevel00);
    tolua_function(tolua_S,"GetFileIO",tolua_engineWin32_Nuclear_Engine_GetFileIO00);
    tolua_function(tolua_S,"GetApp",tolua_engineWin32_Nuclear_Engine_GetApp00);
    tolua_function(tolua_S,"GetWorld",tolua_engineWin32_Nuclear_Engine_GetWorld00);
    tolua_function(tolua_S,"GetWorld",tolua_engineWin32_Nuclear_Engine_GetWorld01);
    tolua_function(tolua_S,"GetXPWorld",tolua_engineWin32_Nuclear_Engine_GetXPWorld00);
    tolua_function(tolua_S,"GetWorldScale",tolua_engineWin32_Nuclear_Engine_GetWorldScale00);
    tolua_function(tolua_S,"GetRenderer",tolua_engineWin32_Nuclear_Engine_GetRenderer00);
    tolua_function(tolua_S,"GetConfigManager",tolua_engineWin32_Nuclear_Engine_GetConfigManager00);
    tolua_function(tolua_S,"GetSpriteManager",tolua_engineWin32_Nuclear_Engine_GetSpriteManager00);
    tolua_function(tolua_S,"GetAniManager",tolua_engineWin32_Nuclear_Engine_GetAniManager00);
    tolua_function(tolua_S,"GetSystemResourceManager",tolua_engineWin32_Nuclear_Engine_GetSystemResourceManager00);
    tolua_function(tolua_S,"GetSpritePictureHandle",tolua_engineWin32_Nuclear_Engine_GetSpritePictureHandle00);
    tolua_function(tolua_S,"GetAlphaSpritePictureHandle",tolua_engineWin32_Nuclear_Engine_GetAlphaSpritePictureHandle00);
    tolua_function(tolua_S,"GetFileIOManager",tolua_engineWin32_Nuclear_Engine_GetFileIOManager00);
    tolua_function(tolua_S,"GetSpriteManager",tolua_engineWin32_Nuclear_Engine_GetSpriteManager01);
    tolua_function(tolua_S,"GetAniManager",tolua_engineWin32_Nuclear_Engine_GetAniManager01);
    tolua_function(tolua_S,"GetEffectManager",tolua_engineWin32_Nuclear_Engine_GetEffectManager00);
    tolua_function(tolua_S,"GetPathFinder",tolua_engineWin32_Nuclear_Engine_GetPathFinder00);
    tolua_function(tolua_S,"GetTick",tolua_engineWin32_Nuclear_Engine_GetTick00);
    tolua_function(tolua_S,"IsAsyncRead",tolua_engineWin32_Nuclear_Engine_IsAsyncRead00);
    tolua_function(tolua_S,"GetWaterDepth",tolua_engineWin32_Nuclear_Engine_GetWaterDepth00);
    tolua_function(tolua_S,"EnableParticle",tolua_engineWin32_Nuclear_Engine_EnableParticle00);
    tolua_function(tolua_S,"GetViewport",tolua_engineWin32_Nuclear_Engine_GetViewport00);
    tolua_function(tolua_S,"GetSpriteShadowParam",tolua_engineWin32_Nuclear_Engine_GetSpriteShadowParam00);
    tolua_function(tolua_S,"GetWindowState",tolua_engineWin32_Nuclear_Engine_GetWindowState00);
    tolua_function(tolua_S,"SetTaskExecuteTime",tolua_engineWin32_Nuclear_Engine_SetTaskExecuteTime00);
    tolua_function(tolua_S,"GetTaskExecuteTime",tolua_engineWin32_Nuclear_Engine_GetTaskExecuteTime00);
    tolua_function(tolua_S,"SetIOUpdateExecuteTime",tolua_engineWin32_Nuclear_Engine_SetIOUpdateExecuteTime00);
    tolua_function(tolua_S,"GetIOUpdateExecuteTime",tolua_engineWin32_Nuclear_Engine_GetIOUpdateExecuteTime00);
    tolua_function(tolua_S,"GetAllSpriteCount",tolua_engineWin32_Nuclear_Engine_GetAllSpriteCount00);
    tolua_function(tolua_S,"GetTaskListCount",tolua_engineWin32_Nuclear_Engine_GetTaskListCount00);
    tolua_function(tolua_S,"GetQueueOfIOTaskSize",tolua_engineWin32_Nuclear_Engine_GetQueueOfIOTaskSize00);
    tolua_function(tolua_S,"SetAniPicGCTime",tolua_engineWin32_Nuclear_Engine_SetAniPicGCTime00);
    tolua_function(tolua_S,"GetAniPicGCTime",tolua_engineWin32_Nuclear_Engine_GetAniPicGCTime00);
    tolua_function(tolua_S,"SetAniXapGCTime",tolua_engineWin32_Nuclear_Engine_SetAniXapGCTime00);
    tolua_function(tolua_S,"GetAniXapGCTime",tolua_engineWin32_Nuclear_Engine_GetAniXapGCTime00);
    tolua_function(tolua_S,"OnRendererRestore",tolua_engineWin32_Nuclear_Engine_OnRendererRestore00);
    tolua_function(tolua_S,"RunUserTask",tolua_engineWin32_Nuclear_Engine_RunUserTask00);
    tolua_function(tolua_S,"OnTimer",tolua_engineWin32_Nuclear_Engine_OnTimer00);
    tolua_function(tolua_S,"GetGameTime",tolua_engineWin32_Nuclear_Engine_GetGameTime00);
    tolua_function(tolua_S,"IsEnableWade",tolua_engineWin32_Nuclear_Engine_IsEnableWade00);
    tolua_function(tolua_S,"SetEnableWade",tolua_engineWin32_Nuclear_Engine_SetEnableWade00);
    tolua_function(tolua_S,"WindowToClient",tolua_engineWin32_Nuclear_Engine_WindowToClient00);
    tolua_function(tolua_S,"CreateEngineSprite",tolua_engineWin32_Nuclear_Engine_CreateEngineSprite00);
    tolua_function(tolua_S,"SetEngineSpriteModel",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteModel00);
    tolua_function(tolua_S,"ReleaseEngineSprite",tolua_engineWin32_Nuclear_Engine_ReleaseEngineSprite00);
    tolua_function(tolua_S,"RendererEngineSprite",tolua_engineWin32_Nuclear_Engine_RendererEngineSprite00);
    tolua_function(tolua_S,"SetEngineSpriteLoc",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteLoc00);
    tolua_function(tolua_S,"SetEngineSpriteDirection",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection00);
    tolua_function(tolua_S,"SetEngineSpriteDirection",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDirection01);
    tolua_function(tolua_S,"SetEngineSpriteDefaultAction",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDefaultAction00);
    tolua_function(tolua_S,"SetEngineSpriteAction",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAction00);
    tolua_function(tolua_S,"EnableEngineSpriteShadow",tolua_engineWin32_Nuclear_Engine_EnableEngineSpriteShadow00);
    tolua_function(tolua_S,"SetEngineSpriteScale",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteScale00);
    tolua_function(tolua_S,"SetEngineSpriteAlpha",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha00);
    tolua_function(tolua_S,"GetEngineSpriteActionTimeByName",tolua_engineWin32_Nuclear_Engine_GetEngineSpriteActionTimeByName00);
    tolua_function(tolua_S,"SetEngineSpriteDurativeEffect",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteDurativeEffect00);
    tolua_function(tolua_S,"PlayEngineSpriteEffect",tolua_engineWin32_Nuclear_Engine_PlayEngineSpriteEffect00);
    tolua_function(tolua_S,"RemoveEngineSpriteDurativeEffect",tolua_engineWin32_Nuclear_Engine_RemoveEngineSpriteDurativeEffect00);
    tolua_function(tolua_S,"GetEngineSpriteBubbleItemOffset",tolua_engineWin32_Nuclear_Engine_GetEngineSpriteBubbleItemOffset00);
    tolua_function(tolua_S,"CreateEffect",tolua_engineWin32_Nuclear_Engine_CreateEffect00);
    tolua_function(tolua_S,"DrawEffect",tolua_engineWin32_Nuclear_Engine_DrawEffect00);
    tolua_function(tolua_S,"ReleaseEffect",tolua_engineWin32_Nuclear_Engine_ReleaseEffect00);
    tolua_function(tolua_S,"HoldEffect",tolua_engineWin32_Nuclear_Engine_HoldEffect00);
    tolua_function(tolua_S,"ReleaseEffect",tolua_engineWin32_Nuclear_Engine_ReleaseEffect01);
    tolua_function(tolua_S,"CaptureWorld",tolua_engineWin32_Nuclear_Engine_CaptureWorld00);
    tolua_function(tolua_S,"SetCleanColor",tolua_engineWin32_Nuclear_Engine_SetCleanColor00);
    tolua_function(tolua_S,"GetCleanColor",tolua_engineWin32_Nuclear_Engine_GetCleanColor00);
    tolua_function(tolua_S,"GCNow",tolua_engineWin32_Nuclear_Engine_GCNow00);
    tolua_function(tolua_S,"setGCCooldown",tolua_engineWin32_Nuclear_Engine_setGCCooldown00);
    tolua_function(tolua_S,"SetSmoothDeltaLimit",tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaLimit00);
    tolua_function(tolua_S,"GetSmoothDeltaLimit",tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaLimit00);
    tolua_function(tolua_S,"SetEngineSpriteAlpha",tolua_engineWin32_Nuclear_Engine_SetEngineSpriteAlpha01);
    tolua_function(tolua_S,"SetSmoothDeltaCount",tolua_engineWin32_Nuclear_Engine_SetSmoothDeltaCount00);
    tolua_function(tolua_S,"GetSmoothDeltaCount",tolua_engineWin32_Nuclear_Engine_GetSmoothDeltaCount00);
    tolua_function(tolua_S,"GetLogicWidth",tolua_engineWin32_Nuclear_Engine_GetLogicWidth01);
    tolua_function(tolua_S,"GetLogicHeight",tolua_engineWin32_Nuclear_Engine_GetLogicHeight01);
    tolua_function(tolua_S,"GetWidth",tolua_engineWin32_Nuclear_Engine_GetWidth00);
    tolua_function(tolua_S,"GetHeight",tolua_engineWin32_Nuclear_Engine_GetHeight00);
    tolua_function(tolua_S,"GetTimeCount",tolua_engineWin32_Nuclear_Engine_GetTimeCount00);
    tolua_function(tolua_S,"GetCurMemSize",tolua_engineWin32_Nuclear_Engine_GetCurMemSize00);
    tolua_function(tolua_S,"GeCurAvailableMemSize",tolua_engineWin32_Nuclear_Engine_GeCurAvailableMemSize00);
    tolua_function(tolua_S,"GetCurDeltaTime",tolua_engineWin32_Nuclear_Engine_GetCurDeltaTime00);
    tolua_function(tolua_S,"SetStepLoadTexture",tolua_engineWin32_Nuclear_Engine_SetStepLoadTexture00);
    tolua_function(tolua_S,"GetStepLoadTexture",tolua_engineWin32_Nuclear_Engine_GetStepLoadTexture00);
    tolua_function(tolua_S,"SetLimitFireThreadSecond",tolua_engineWin32_Nuclear_Engine_SetLimitFireThreadSecond00);
    tolua_function(tolua_S,"GetLimitFireThreadSecond",tolua_engineWin32_Nuclear_Engine_GetLimitFireThreadSecond00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IEnv","Nuclear::IEnv","",tolua_collect_Nuclear__IEnv);
   #else
   tolua_cclass(tolua_S,"IEnv","Nuclear::IEnv","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IEnv");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IEnv_delete00);
    tolua_function(tolua_S,"GetDisplayMode",tolua_engineWin32_Nuclear_IEnv_GetDisplayMode00);
    tolua_function(tolua_S,"GetCurrentMultiSampleType",tolua_engineWin32_Nuclear_IEnv_GetCurrentMultiSampleType00);
    tolua_function(tolua_S,"IsMultiSampleTypeEnable",tolua_engineWin32_Nuclear_IEnv_IsMultiSampleTypeEnable00);
    tolua_function(tolua_S,"IsSoundInited",tolua_engineWin32_Nuclear_IEnv_IsSoundInited00);
    tolua_function(tolua_S,"GetCurrentDirectory",tolua_engineWin32_Nuclear_IEnv_GetCurrentDirectory00);
    tolua_function(tolua_S,"SetCursorPosition",tolua_engineWin32_Nuclear_IEnv_SetCursorPosition00);
    tolua_function(tolua_S,"GetCursorPosition",tolua_engineWin32_Nuclear_IEnv_GetCursorPosition00);
    tolua_function(tolua_S,"EnableRenderDuringLoading",tolua_engineWin32_Nuclear_IEnv_EnableRenderDuringLoading00);
    tolua_function(tolua_S,"IsRenderDuringLoading",tolua_engineWin32_Nuclear_IEnv_IsRenderDuringLoading00);
    tolua_function(tolua_S,"SetConsoleInfo",tolua_engineWin32_Nuclear_IEnv_SetConsoleInfo00);
    tolua_function(tolua_S,"TestConsoleInfo",tolua_engineWin32_Nuclear_IEnv_TestConsoleInfo00);
    tolua_function(tolua_S,"SetFrameStateInfo",tolua_engineWin32_Nuclear_IEnv_SetFrameStateInfo00);
    tolua_function(tolua_S,"TestFrameStateInfo",tolua_engineWin32_Nuclear_IEnv_TestFrameStateInfo00);
    tolua_function(tolua_S,"SetFrameStateColor",tolua_engineWin32_Nuclear_IEnv_SetFrameStateColor00);
    tolua_function(tolua_S,"GetFrameStateColor",tolua_engineWin32_Nuclear_IEnv_GetFrameStateColor00);
    tolua_function(tolua_S,"SetDynamicMapLoading",tolua_engineWin32_Nuclear_IEnv_SetDynamicMapLoading00);
    tolua_function(tolua_S,"IsDynamicMapLoading",tolua_engineWin32_Nuclear_IEnv_IsDynamicMapLoading00);
    tolua_function(tolua_S,"SetControlFPS",tolua_engineWin32_Nuclear_IEnv_SetControlFPS00);
    tolua_function(tolua_S,"IsControlFPS",tolua_engineWin32_Nuclear_IEnv_IsControlFPS00);
    tolua_function(tolua_S,"SetControlFPS",tolua_engineWin32_Nuclear_IEnv_SetControlFPS01);
    tolua_function(tolua_S,"GetControlFPS",tolua_engineWin32_Nuclear_IEnv_GetControlFPS00);
    tolua_function(tolua_S,"SetTaskExecuteTime",tolua_engineWin32_Nuclear_IEnv_SetTaskExecuteTime00);
    tolua_function(tolua_S,"GetTaskExecuteTime",tolua_engineWin32_Nuclear_IEnv_GetTaskExecuteTime00);
    tolua_function(tolua_S,"SetIOUpdateExecuteTime",tolua_engineWin32_Nuclear_IEnv_SetIOUpdateExecuteTime00);
    tolua_function(tolua_S,"GetIOUpdateExecuteTime",tolua_engineWin32_Nuclear_IEnv_GetIOUpdateExecuteTime00);
    tolua_function(tolua_S,"SetRenderNightEffectByShader",tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectByShader00);
    tolua_function(tolua_S,"IsRenderNightEffectByShader",tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectByShader00);
    tolua_function(tolua_S,"IsRenderNightEffectWithRenderTarget",tolua_engineWin32_Nuclear_IEnv_IsRenderNightEffectWithRenderTarget00);
    tolua_function(tolua_S,"SetRenderNightEffectWithRenderTarget",tolua_engineWin32_Nuclear_IEnv_SetRenderNightEffectWithRenderTarget00);
    tolua_function(tolua_S,"IsEnableMaskPic",tolua_engineWin32_Nuclear_IEnv_IsEnableMaskPic00);
    tolua_function(tolua_S,"SetEnableMaskPic",tolua_engineWin32_Nuclear_IEnv_SetEnableMaskPic00);
    tolua_function(tolua_S,"IsRenderSpriteShadow",tolua_engineWin32_Nuclear_IEnv_IsRenderSpriteShadow00);
    tolua_function(tolua_S,"SetRenderSpriteShadow",tolua_engineWin32_Nuclear_IEnv_SetRenderSpriteShadow00);
    tolua_function(tolua_S,"IsBlurForTeleport",tolua_engineWin32_Nuclear_IEnv_IsBlurForTeleport00);
    tolua_function(tolua_S,"SetBlurForTeleport",tolua_engineWin32_Nuclear_IEnv_SetBlurForTeleport00);
    tolua_function(tolua_S,"SetEnableSurfaceCache",tolua_engineWin32_Nuclear_IEnv_SetEnableSurfaceCache00);
    tolua_function(tolua_S,"IsEnableSurfaceCache",tolua_engineWin32_Nuclear_IEnv_IsEnableSurfaceCache00);
    tolua_function(tolua_S,"IsSyncBeforeWater",tolua_engineWin32_Nuclear_IEnv_IsSyncBeforeWater00);
    tolua_function(tolua_S,"SetSyncBeforeWater",tolua_engineWin32_Nuclear_IEnv_SetSyncBeforeWater00);
    tolua_function(tolua_S,"SetEnableSortMapObjects",tolua_engineWin32_Nuclear_IEnv_SetEnableSortMapObjects00);
    tolua_function(tolua_S,"IsEnableSortMapObjects",tolua_engineWin32_Nuclear_IEnv_IsEnableSortMapObjects00);
    tolua_function(tolua_S,"SetEnableLinkedObjs",tolua_engineWin32_Nuclear_IEnv_SetEnableLinkedObjs00);
    tolua_function(tolua_S,"IsEnableLinkedObjs",tolua_engineWin32_Nuclear_IEnv_IsEnableLinkedObjs00);
    tolua_function(tolua_S,"GetSystemLevel",tolua_engineWin32_Nuclear_IEnv_GetSystemLevel00);
    tolua_function(tolua_S,"ShowSpritePath",tolua_engineWin32_Nuclear_IEnv_ShowSpritePath00);
    tolua_function(tolua_S,"ShowSpriteTrail",tolua_engineWin32_Nuclear_IEnv_ShowSpriteTrail00);
    tolua_function(tolua_S,"ShowMapGrid",tolua_engineWin32_Nuclear_IEnv_ShowMapGrid00);
    tolua_function(tolua_S,"IsShowSpritePath",tolua_engineWin32_Nuclear_IEnv_IsShowSpritePath00);
    tolua_function(tolua_S,"IsShowSpriteTrail",tolua_engineWin32_Nuclear_IEnv_IsShowSpriteTrail00);
    tolua_function(tolua_S,"IsShowMapGrid",tolua_engineWin32_Nuclear_IEnv_IsShowMapGrid00);
    tolua_function(tolua_S,"SetMapMazeMask",tolua_engineWin32_Nuclear_IEnv_SetMapMazeMask00);
    tolua_function(tolua_S,"GetMapMazeMask",tolua_engineWin32_Nuclear_IEnv_GetMapMazeMask00);
    tolua_function(tolua_S,"SetAniPicGCTime",tolua_engineWin32_Nuclear_IEnv_SetAniPicGCTime00);
    tolua_function(tolua_S,"GetAniPicGCTime",tolua_engineWin32_Nuclear_IEnv_GetAniPicGCTime00);
    tolua_function(tolua_S,"SetAniXapGCTime",tolua_engineWin32_Nuclear_IEnv_SetAniXapGCTime00);
    tolua_function(tolua_S,"GetAniXapGCTime",tolua_engineWin32_Nuclear_IEnv_GetAniXapGCTime00);
    tolua_function(tolua_S,"SetMax3DEffectComponentCount",tolua_engineWin32_Nuclear_IEnv_SetMax3DEffectComponentCount00);
    tolua_function(tolua_S,"GetSpriteTranslucentType",tolua_engineWin32_Nuclear_IEnv_GetSpriteTranslucentType00);
    tolua_function(tolua_S,"SetSpriteTranslucentType",tolua_engineWin32_Nuclear_IEnv_SetSpriteTranslucentType00);
    tolua_function(tolua_S,"GetMaskAlpha",tolua_engineWin32_Nuclear_IEnv_GetMaskAlpha00);
    tolua_function(tolua_S,"SetMaskAlpha",tolua_engineWin32_Nuclear_IEnv_SetMaskAlpha00);
    tolua_function(tolua_S,"IsRenderSolidMask",tolua_engineWin32_Nuclear_IEnv_IsRenderSolidMask00);
    tolua_function(tolua_S,"SetRenderSolidMask",tolua_engineWin32_Nuclear_IEnv_SetRenderSolidMask00);
    tolua_function(tolua_S,"GetAvailableMultiSampleType",tolua_engineWin32_Nuclear_IEnv_GetAvailableMultiSampleType00);
    tolua_function(tolua_S,"IsSmoothMove",tolua_engineWin32_Nuclear_IEnv_IsSmoothMove00);
    tolua_function(tolua_S,"SetSmoothMove",tolua_engineWin32_Nuclear_IEnv_SetSmoothMove00);
    tolua_function(tolua_S,"GetMinDelta",tolua_engineWin32_Nuclear_IEnv_GetMinDelta00);
    tolua_function(tolua_S,"SetMinDelta",tolua_engineWin32_Nuclear_IEnv_SetMinDelta00);
    tolua_function(tolua_S,"GetMaxDiffDelta",tolua_engineWin32_Nuclear_IEnv_GetMaxDiffDelta00);
    tolua_function(tolua_S,"SetMaxDiffDelta",tolua_engineWin32_Nuclear_IEnv_SetMaxDiffDelta00);
    tolua_function(tolua_S,"GetMaxDiffFromAvg",tolua_engineWin32_Nuclear_IEnv_GetMaxDiffFromAvg00);
    tolua_function(tolua_S,"SetMaxDiffFromAvg",tolua_engineWin32_Nuclear_IEnv_SetMaxDiffFromAvg00);
    tolua_function(tolua_S,"IsEnableWade",tolua_engineWin32_Nuclear_IEnv_IsEnableWade00);
    tolua_function(tolua_S,"SetEnableWade",tolua_engineWin32_Nuclear_IEnv_SetEnableWade00);
    tolua_function(tolua_S,"GetUnloadMapBGSoundFadeOutTime",tolua_engineWin32_Nuclear_IEnv_GetUnloadMapBGSoundFadeOutTime00);
    tolua_function(tolua_S,"SetUnloadMapBGSoundFadeOutTime",tolua_engineWin32_Nuclear_IEnv_SetUnloadMapBGSoundFadeOutTime00);
    tolua_function(tolua_S,"GetBGMType",tolua_engineWin32_Nuclear_IEnv_GetBGMType00);
    tolua_function(tolua_S,"SetBGMType",tolua_engineWin32_Nuclear_IEnv_SetBGMType00);
    tolua_function(tolua_S,"GetEnvSoundType",tolua_engineWin32_Nuclear_IEnv_GetEnvSoundType00);
    tolua_function(tolua_S,"SetEnvSoundType",tolua_engineWin32_Nuclear_IEnv_SetEnvSoundType00);
    tolua_function(tolua_S,"GetStepSoundType",tolua_engineWin32_Nuclear_IEnv_GetStepSoundType00);
    tolua_function(tolua_S,"SetStepSoundType",tolua_engineWin32_Nuclear_IEnv_SetStepSoundType00);
    tolua_function(tolua_S,"GetActionSoundType",tolua_engineWin32_Nuclear_IEnv_GetActionSoundType00);
    tolua_function(tolua_S,"SetActionSoundType",tolua_engineWin32_Nuclear_IEnv_SetActionSoundType00);
    tolua_function(tolua_S,"Get3DSpriteActionSoundType",tolua_engineWin32_Nuclear_IEnv_Get3DSpriteActionSoundType00);
    tolua_function(tolua_S,"Set3DSpriteActionSoundType",tolua_engineWin32_Nuclear_IEnv_Set3DSpriteActionSoundType00);
    tolua_function(tolua_S,"GetStepSoundPriority",tolua_engineWin32_Nuclear_IEnv_GetStepSoundPriority00);
    tolua_function(tolua_S,"SetStepSoundPriority",tolua_engineWin32_Nuclear_IEnv_SetStepSoundPriority00);
    tolua_function(tolua_S,"SetSpriteMoveSmoothLimit",tolua_engineWin32_Nuclear_IEnv_SetSpriteMoveSmoothLimit00);
    tolua_function(tolua_S,"GetSpriteMoveSmoothLimit",tolua_engineWin32_Nuclear_IEnv_GetSpriteMoveSmoothLimit00);
    tolua_function(tolua_S,"GetLogicToWorldScaleX",tolua_engineWin32_Nuclear_IEnv_GetLogicToWorldScaleX00);
    tolua_function(tolua_S,"SetLogicToWorldScaleX",tolua_engineWin32_Nuclear_IEnv_SetLogicToWorldScaleX00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"DrawPictureParam","Nuclear::DrawPictureParam","",tolua_collect_Nuclear__DrawPictureParam);
   #else
   tolua_cclass(tolua_S,"DrawPictureParam","Nuclear::DrawPictureParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"DrawPictureParam");
    tolua_variable(tolua_S,"handle",tolua_get_Nuclear__DrawPictureParam_handle,tolua_set_Nuclear__DrawPictureParam_handle);
    tolua_variable(tolua_S,"pRect",tolua_get_Nuclear__DrawPictureParam_pRect_ptr,NULL);
    tolua_variable(tolua_S,"pMatrix",tolua_get_Nuclear__DrawPictureParam_pMatrix_ptr,NULL);
    tolua_variable(tolua_S,"pColor",tolua_get_Nuclear__DrawPictureParam_pColor_ptr,NULL);
    tolua_variable(tolua_S,"colorCount",tolua_get_Nuclear__DrawPictureParam_colorCount,tolua_set_Nuclear__DrawPictureParam_colorCount);
    tolua_variable(tolua_S,"blend",tolua_get_Nuclear__DrawPictureParam_blend,tolua_set_Nuclear__DrawPictureParam_blend);
    tolua_variable(tolua_S,"pSrcrect",tolua_get_Nuclear__DrawPictureParam_pSrcrect_ptr,NULL);
    tolua_variable(tolua_S,"bSpecAlpha",tolua_get_Nuclear__DrawPictureParam_bSpecAlpha,tolua_set_Nuclear__DrawPictureParam_bSpecAlpha);
    tolua_variable(tolua_S,"bUseBW",tolua_get_Nuclear__DrawPictureParam_bUseBW,tolua_set_Nuclear__DrawPictureParam_bUseBW);
    tolua_variable(tolua_S,"fGreyPercent",tolua_get_Nuclear__DrawPictureParam_fGreyPercent,tolua_set_Nuclear__DrawPictureParam_fGreyPercent);
    tolua_variable(tolua_S,"fRedPercent",tolua_get_Nuclear__DrawPictureParam_fRedPercent,tolua_set_Nuclear__DrawPictureParam_fRedPercent);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_DrawPictureParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_DrawPictureParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_DrawPictureParam_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"DrawEllipsePictureParam","Nuclear::DrawEllipsePictureParam","",tolua_collect_Nuclear__DrawEllipsePictureParam);
   #else
   tolua_cclass(tolua_S,"DrawEllipsePictureParam","Nuclear::DrawEllipsePictureParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"DrawEllipsePictureParam");
    tolua_variable(tolua_S,"handle",tolua_get_Nuclear__DrawEllipsePictureParam_handle,tolua_set_Nuclear__DrawEllipsePictureParam_handle);
    tolua_variable(tolua_S,"x",tolua_get_Nuclear__DrawEllipsePictureParam_x,tolua_set_Nuclear__DrawEllipsePictureParam_x);
    tolua_variable(tolua_S,"y",tolua_get_Nuclear__DrawEllipsePictureParam_y,tolua_set_Nuclear__DrawEllipsePictureParam_y);
    tolua_variable(tolua_S,"rx",tolua_get_Nuclear__DrawEllipsePictureParam_rx,tolua_set_Nuclear__DrawEllipsePictureParam_rx);
    tolua_variable(tolua_S,"ry",tolua_get_Nuclear__DrawEllipsePictureParam_ry,tolua_set_Nuclear__DrawEllipsePictureParam_ry);
    tolua_variable(tolua_S,"u0",tolua_get_Nuclear__DrawEllipsePictureParam_u0,tolua_set_Nuclear__DrawEllipsePictureParam_u0);
    tolua_variable(tolua_S,"v0",tolua_get_Nuclear__DrawEllipsePictureParam_v0,tolua_set_Nuclear__DrawEllipsePictureParam_v0);
    tolua_variable(tolua_S,"ru",tolua_get_Nuclear__DrawEllipsePictureParam_ru,tolua_set_Nuclear__DrawEllipsePictureParam_ru);
    tolua_variable(tolua_S,"rv",tolua_get_Nuclear__DrawEllipsePictureParam_rv,tolua_set_Nuclear__DrawEllipsePictureParam_rv);
    tolua_variable(tolua_S,"color",tolua_get_Nuclear__DrawEllipsePictureParam_color,tolua_set_Nuclear__DrawEllipsePictureParam_color);
    tolua_variable(tolua_S,"TextureMode",tolua_get_Nuclear__DrawEllipsePictureParam_TextureMode,tolua_set_Nuclear__DrawEllipsePictureParam_TextureMode);
    tolua_variable(tolua_S,"borderColor",tolua_get_Nuclear__DrawEllipsePictureParam_borderColor,tolua_set_Nuclear__DrawEllipsePictureParam_borderColor);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_DrawEllipsePictureParam_new00_local);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"DrawBatchPictureParam","Nuclear::DrawBatchPictureParam","",tolua_collect_Nuclear__DrawBatchPictureParam);
   #else
   tolua_cclass(tolua_S,"DrawBatchPictureParam","Nuclear::DrawBatchPictureParam","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"DrawBatchPictureParam");
    tolua_variable(tolua_S,"handle",tolua_get_Nuclear__DrawBatchPictureParam_handle,tolua_set_Nuclear__DrawBatchPictureParam_handle);
    tolua_variable(tolua_S,"secHandle",tolua_get_Nuclear__DrawBatchPictureParam_secHandle,tolua_set_Nuclear__DrawBatchPictureParam_secHandle);
    tolua_variable(tolua_S,"pRect",tolua_get_Nuclear__DrawBatchPictureParam_pRect_ptr,NULL);
    tolua_variable(tolua_S,"rectCount",tolua_get_Nuclear__DrawBatchPictureParam_rectCount,tolua_set_Nuclear__DrawBatchPictureParam_rectCount);
    tolua_variable(tolua_S,"pMatrix",tolua_get_Nuclear__DrawBatchPictureParam_pMatrix_ptr,NULL);
    tolua_variable(tolua_S,"pColor",tolua_get_Nuclear__DrawBatchPictureParam_pColor_ptr,NULL);
    tolua_variable(tolua_S,"colorCount",tolua_get_Nuclear__DrawBatchPictureParam_colorCount,tolua_set_Nuclear__DrawBatchPictureParam_colorCount);
    tolua_variable(tolua_S,"blend",tolua_get_Nuclear__DrawBatchPictureParam_blend,tolua_set_Nuclear__DrawBatchPictureParam_blend);
    tolua_variable(tolua_S,"pSrcrect",tolua_get_Nuclear__DrawBatchPictureParam_pSrcrect_ptr,NULL);
    tolua_variable(tolua_S,"pSecSrcRect",tolua_get_Nuclear__DrawBatchPictureParam_pSecSrcRect_ptr,NULL);
    tolua_variable(tolua_S,"bSameuv",tolua_get_Nuclear__DrawBatchPictureParam_bSameuv,tolua_set_Nuclear__DrawBatchPictureParam_bSameuv);
    tolua_variable(tolua_S,"bSecSameuv",tolua_get_Nuclear__DrawBatchPictureParam_bSecSameuv,tolua_set_Nuclear__DrawBatchPictureParam_bSecSameuv);
    tolua_variable(tolua_S,"bSpecAlpha",tolua_get_Nuclear__DrawBatchPictureParam_bSpecAlpha,tolua_set_Nuclear__DrawBatchPictureParam_bSpecAlpha);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_DrawBatchPictureParam_new01_local);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPRV_DEFAULT",Nuclear::XPRV_DEFAULT);
   tolua_constant(tolua_S,"XPRV_DX9",Nuclear::XPRV_DX9);
   tolua_constant(tolua_S,"XPRV_COCOS2D",Nuclear::XPRV_COCOS2D);
   tolua_constant(tolua_S,"XPCRF_VERTICALSYNC",Nuclear::XPCRF_VERTICALSYNC);
   tolua_constant(tolua_S,"XPCRR_NULL_POINTER",Nuclear::XPCRR_NULL_POINTER);
   tolua_constant(tolua_S,"XPCRR_GET_DIRECT3D",Nuclear::XPCRR_GET_DIRECT3D);
   tolua_constant(tolua_S,"XPCRR_CREATE_DEVICE",Nuclear::XPCRR_CREATE_DEVICE);
   tolua_constant(tolua_S,"XPCRR_INIT_STATE_MANAGER",Nuclear::XPCRR_INIT_STATE_MANAGER);
   tolua_constant(tolua_S,"XPCRR_CREATE_DEPTHSTENCIL_SURFACE",Nuclear::XPCRR_CREATE_DEPTHSTENCIL_SURFACE);
   tolua_constant(tolua_S,"XPCRR_CREATE_SECOND_DEPTHSTENCIL_SURFACE",Nuclear::XPCRR_CREATE_SECOND_DEPTHSTENCIL_SURFACE);
   tolua_constant(tolua_S,"XPCRR_SET_DEPTHSTENCIL_SURFACE",Nuclear::XPCRR_SET_DEPTHSTENCIL_SURFACE);
   tolua_constant(tolua_S,"XPCRR_SHADER_VERSION",Nuclear::XPCRR_SHADER_VERSION);
   tolua_constant(tolua_S,"XPCRR_OK",Nuclear::XPCRR_OK);
   tolua_constant(tolua_S,"XPDS_NO_DEVICE",Nuclear::XPDS_NO_DEVICE);
   tolua_constant(tolua_S,"XPDS_INTERNAL_ERROR",Nuclear::XPDS_INTERNAL_ERROR);
   tolua_constant(tolua_S,"XPDS_LOST_DEVICE",Nuclear::XPDS_LOST_DEVICE);
   tolua_constant(tolua_S,"XPDS_RESET_ERROR",Nuclear::XPDS_RESET_ERROR);
   tolua_constant(tolua_S,"XPDS_OK",Nuclear::XPDS_OK);
   tolua_constant(tolua_S,"XPSDT_NONE",Nuclear::XPSDT_NONE);
   tolua_constant(tolua_S,"XPSDT_USE_MAIN",Nuclear::XPSDT_USE_MAIN);
   tolua_constant(tolua_S,"XPSDT_INDEPENDENCE",Nuclear::XPSDT_INDEPENDENCE);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Renderer","Nuclear::Renderer","",tolua_collect_Nuclear__Renderer);
   #else
   tolua_cclass(tolua_S,"Renderer","Nuclear::Renderer","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Renderer");
    tolua_variable(tolua_S,"Z",tolua_get_Nuclear__Renderer_Z,NULL);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_Renderer_delete00);
    tolua_function(tolua_S,"DrawLine",tolua_engineWin32_Nuclear_Renderer_DrawLine00);
    tolua_function(tolua_S,"DrawBox",tolua_engineWin32_Nuclear_Renderer_DrawBox00);
    tolua_function(tolua_S,"DrawCircle",tolua_engineWin32_Nuclear_Renderer_DrawCircle00);
    tolua_function(tolua_S,"LoadPictureFromNativePath",tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath00);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Renderer_DrawPicture00);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile00);
    tolua_function(tolua_S,"OnResetDevice",tolua_engineWin32_Nuclear_Renderer_OnResetDevice00);
    tolua_function(tolua_S,"GetDisplayMode",tolua_engineWin32_Nuclear_Renderer_GetDisplayMode00);
    tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_Renderer_Destroy00);
    tolua_function(tolua_S,"SetScissorRect",tolua_engineWin32_Nuclear_Renderer_SetScissorRect00);
    tolua_function(tolua_S,"DrawLine",tolua_engineWin32_Nuclear_Renderer_DrawLine01);
    tolua_function(tolua_S,"DrawLine",tolua_engineWin32_Nuclear_Renderer_DrawLine02);
    tolua_function(tolua_S,"DrawTriangle",tolua_engineWin32_Nuclear_Renderer_DrawTriangle00);
    tolua_function(tolua_S,"DrawBox",tolua_engineWin32_Nuclear_Renderer_DrawBox01);
    tolua_function(tolua_S,"DrawBox",tolua_engineWin32_Nuclear_Renderer_DrawBox02);
    tolua_function(tolua_S,"DrawFan",tolua_engineWin32_Nuclear_Renderer_DrawFan00);
    tolua_function(tolua_S,"DrawEllipseFan",tolua_engineWin32_Nuclear_Renderer_DrawEllipseFan00);
    tolua_function(tolua_S,"DrawEllipse",tolua_engineWin32_Nuclear_Renderer_DrawEllipse00);
    tolua_function(tolua_S,"DrawTriangleList",tolua_engineWin32_Nuclear_Renderer_DrawTriangleList00);
    tolua_function(tolua_S,"DrawEllipsePicture",tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture00);
    tolua_function(tolua_S,"DrawEllipsePicture",tolua_engineWin32_Nuclear_Renderer_DrawEllipsePicture01);
    tolua_function(tolua_S,"LoadPictureFromNativePath",tolua_engineWin32_Nuclear_Renderer_LoadPictureFromNativePath01);
    tolua_function(tolua_S,"LoadPicture",tolua_engineWin32_Nuclear_Renderer_LoadPicture00);
    tolua_function(tolua_S,"CachePicture",tolua_engineWin32_Nuclear_Renderer_CachePicture00);
    tolua_function(tolua_S,"CacheInMemory",tolua_engineWin32_Nuclear_Renderer_CacheInMemory00);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Renderer_DrawPicture01);
    tolua_function(tolua_S,"FreePicture",tolua_engineWin32_Nuclear_Renderer_FreePicture00);
    tolua_function(tolua_S,"DrawBatchPicture",tolua_engineWin32_Nuclear_Renderer_DrawBatchPicture00);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Renderer_DrawPicture02);
    tolua_function(tolua_S,"CreateRenderTarget",tolua_engineWin32_Nuclear_Renderer_CreateRenderTarget00);
    tolua_function(tolua_S,"FreeRenderTarget",tolua_engineWin32_Nuclear_Renderer_FreeRenderTarget00);
    tolua_function(tolua_S,"PushRenderTarget",tolua_engineWin32_Nuclear_Renderer_PushRenderTarget00);
    tolua_function(tolua_S,"PopRenderTarget",tolua_engineWin32_Nuclear_Renderer_PopRenderTarget00);
    tolua_function(tolua_S,"SelectRenderEffect",tolua_engineWin32_Nuclear_Renderer_SelectRenderEffect00);
    tolua_function(tolua_S,"SetShaderParam",tolua_engineWin32_Nuclear_Renderer_SetShaderParam00);
    tolua_function(tolua_S,"GetRenderEffect",tolua_engineWin32_Nuclear_Renderer_GetRenderEffect00);
    tolua_function(tolua_S,"IsAutoTestDevice",tolua_engineWin32_Nuclear_Renderer_IsAutoTestDevice00);
    tolua_function(tolua_S,"SetAutoTestDevice",tolua_engineWin32_Nuclear_Renderer_SetAutoTestDevice00);
    tolua_function(tolua_S,"SetRestoreTask",tolua_engineWin32_Nuclear_Renderer_SetRestoreTask00);
    tolua_function(tolua_S,"SetLostTask",tolua_engineWin32_Nuclear_Renderer_SetLostTask00);
    tolua_function(tolua_S,"GetAvailableTextureMem",tolua_engineWin32_Nuclear_Renderer_GetAvailableTextureMem00);
    tolua_function(tolua_S,"IsTextureCapsNoPow2",tolua_engineWin32_Nuclear_Renderer_IsTextureCapsNoPow200);
    tolua_function(tolua_S,"GetParticleManager",tolua_engineWin32_Nuclear_Renderer_GetParticleManager00);
    tolua_function(tolua_S,"GetFontManager",tolua_engineWin32_Nuclear_Renderer_GetFontManager00);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile01);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile02);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile03);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Renderer_SaveTextureToFile04);
    tolua_function(tolua_S,"DumpAllPicture",tolua_engineWin32_Nuclear_Renderer_DumpAllPicture00);
    tolua_function(tolua_S,"GetPictureSizeInfo",tolua_engineWin32_Nuclear_Renderer_GetPictureSizeInfo00);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Renderer_DrawPicture03);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPBLEND_ZERO",Nuclear::XPBLEND_ZERO);
   tolua_constant(tolua_S,"XPBLEND_ONE",Nuclear::XPBLEND_ONE);
   tolua_constant(tolua_S,"XPBLEND_SRCCOLOR",Nuclear::XPBLEND_SRCCOLOR);
   tolua_constant(tolua_S,"XPBLEND_INVSRCCOLOR",Nuclear::XPBLEND_INVSRCCOLOR);
   tolua_constant(tolua_S,"XPBLEND_SRCALPHA",Nuclear::XPBLEND_SRCALPHA);
   tolua_constant(tolua_S,"XPBLEND_INVSRCALPHA",Nuclear::XPBLEND_INVSRCALPHA);
   tolua_constant(tolua_S,"XPBLEND_DESTALPHA",Nuclear::XPBLEND_DESTALPHA);
   tolua_constant(tolua_S,"XPBLEND_INVDESTALPHA",Nuclear::XPBLEND_INVDESTALPHA);
   tolua_constant(tolua_S,"XPBLEND_DESTCOLOR",Nuclear::XPBLEND_DESTCOLOR);
   tolua_constant(tolua_S,"XPBLEND_INVDESTCOLOR",Nuclear::XPBLEND_INVDESTCOLOR);
   tolua_constant(tolua_S,"XPBLEND_SRCALPHASAT",Nuclear::XPBLEND_SRCALPHASAT);
   tolua_constant(tolua_S,"XPBLEND_BOTHSRCALPHA",Nuclear::XPBLEND_BOTHSRCALPHA);
   tolua_constant(tolua_S,"XPBLEND_BOTHINVSRCALPHA",Nuclear::XPBLEND_BOTHINVSRCALPHA);
   tolua_constant(tolua_S,"XPBLEND_BLENDFACTOR",Nuclear::XPBLEND_BLENDFACTOR);
   tolua_constant(tolua_S,"XPBLEND_INVBLENDFACTOR",Nuclear::XPBLEND_INVBLENDFACTOR);
   tolua_constant(tolua_S,"XPTOP_DEFAULT",Nuclear::XPTOP_DEFAULT);
   tolua_constant(tolua_S,"XPTOP_MODULATE",Nuclear::XPTOP_MODULATE);
   tolua_constant(tolua_S,"XPTOP_SELECTARG1",Nuclear::XPTOP_SELECTARG1);
   tolua_constant(tolua_S,"XPTOP_SELECTARG2",Nuclear::XPTOP_SELECTARG2);
   tolua_constant(tolua_S,"XPTOP_ADD",Nuclear::XPTOP_ADD);
   tolua_constant(tolua_S,"XPTOP_SUBTRACT",Nuclear::XPTOP_SUBTRACT);
   tolua_constant(tolua_S,"XPTOP_ADDSMOOTH",Nuclear::XPTOP_ADDSMOOTH);
   tolua_constant(tolua_S,"XPTOP_ADDSIGNED",Nuclear::XPTOP_ADDSIGNED);
   tolua_constant(tolua_S,"XPTOP_MODULATE2X",Nuclear::XPTOP_MODULATE2X);
   tolua_constant(tolua_S,"PSLRENDSTATE_ALPHA",Nuclear::PSLRENDSTATE_ALPHA);
   tolua_constant(tolua_S,"PSLRENDSTATE_LIGHTING",Nuclear::PSLRENDSTATE_LIGHTING);
   tolua_constant(tolua_S,"PSLRENDSTATE_ADD",Nuclear::PSLRENDSTATE_ADD);
   tolua_constant(tolua_S,"XPRE_NULL",Nuclear::XPRE_NULL);
   tolua_constant(tolua_S,"XPRE_COLORBALANCE",Nuclear::XPRE_COLORBALANCE);
   tolua_constant(tolua_S,"XPRE_COLORBALANCE_2",Nuclear::XPRE_COLORBALANCE_2);
   tolua_constant(tolua_S,"XPRE_ALPHA",Nuclear::XPRE_ALPHA);
   tolua_constant(tolua_S,"XPRE_2TEXTUREBLEND",Nuclear::XPRE_2TEXTUREBLEND);
   tolua_constant(tolua_S,"XPRE_DISTORTION",Nuclear::XPRE_DISTORTION);
   tolua_constant(tolua_S,"XPRE_COUNT",Nuclear::XPRE_COUNT);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"IFontManager","Nuclear::IFontManager","",tolua_collect_Nuclear__IFontManager);
   #else
   tolua_cclass(tolua_S,"IFontManager","Nuclear::IFontManager","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"IFontManager");
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_IFontManager_delete00);
    tolua_function(tolua_S,"Release",tolua_engineWin32_Nuclear_IFontManager_Release00);
    tolua_function(tolua_S,"GetFontTypeHeight",tolua_engineWin32_Nuclear_IFontManager_GetFontTypeHeight00);
    tolua_function(tolua_S,"GetFontTypeUnderlinePosition",tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlinePosition00);
    tolua_function(tolua_S,"GetFontTypeUnderlineThickness",tolua_engineWin32_Nuclear_IFontManager_GetFontTypeUnderlineThickness00);
    tolua_function(tolua_S,"NewText",tolua_engineWin32_Nuclear_IFontManager_NewText00);
    tolua_function(tolua_S,"DrawText",tolua_engineWin32_Nuclear_IFontManager_DrawText00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"XPTEXFMT_DEFAULT",Nuclear::XPTEXFMT_DEFAULT);
   tolua_constant(tolua_S,"XPTEXFMT_A8R8G8B8",Nuclear::XPTEXFMT_A8R8G8B8);
   tolua_constant(tolua_S,"XPTEXFMT_A4R4G4B4",Nuclear::XPTEXFMT_A4R4G4B4);
   tolua_constant(tolua_S,"XPTEXFMT_R5G6B5",Nuclear::XPTEXFMT_R5G6B5);
   tolua_constant(tolua_S,"XPTEXFMT_DXT1",Nuclear::XPTEXFMT_DXT1);
   tolua_constant(tolua_S,"XPTEXFMT_DXT2",Nuclear::XPTEXFMT_DXT2);
   tolua_constant(tolua_S,"XPTEXFMT_DXT3",Nuclear::XPTEXFMT_DXT3);
   tolua_constant(tolua_S,"XPTEXFMT_DXT4",Nuclear::XPTEXFMT_DXT4);
   tolua_constant(tolua_S,"XPTEXFMT_DXT5",Nuclear::XPTEXFMT_DXT5);
   tolua_constant(tolua_S,"XPPOOL_VIDEOMEM",Nuclear::XPPOOL_VIDEOMEM);
   tolua_constant(tolua_S,"XPPOOL_MANAGED",Nuclear::XPPOOL_MANAGED);
   tolua_constant(tolua_S,"XPPOOL_SYSTEMMEM",Nuclear::XPPOOL_SYSTEMMEM);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearPictureInfo","Nuclear::NuclearPictureInfo","",tolua_collect_Nuclear__NuclearPictureInfo);
   #else
   tolua_cclass(tolua_S,"NuclearPictureInfo","Nuclear::NuclearPictureInfo","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearPictureInfo");
    tolua_variable(tolua_S,"m_nPicWidth",tolua_get_Nuclear__NuclearPictureInfo_m_nPicWidth,tolua_set_Nuclear__NuclearPictureInfo_m_nPicWidth);
    tolua_variable(tolua_S,"m_nPicHeight",tolua_get_Nuclear__NuclearPictureInfo_m_nPicHeight,tolua_set_Nuclear__NuclearPictureInfo_m_nPicHeight);
    tolua_variable(tolua_S,"m_texfmt",tolua_get_Nuclear__NuclearPictureInfo_m_texfmt,tolua_set_Nuclear__NuclearPictureInfo_m_texfmt);
    tolua_variable(tolua_S,"m_pooltype",tolua_get_Nuclear__NuclearPictureInfo_m_pooltype,tolua_set_Nuclear__NuclearPictureInfo_m_pooltype);
    tolua_variable(tolua_S,"fileuri",tolua_get_Nuclear__NuclearPictureInfo_fileuri,tolua_set_Nuclear__NuclearPictureInfo_fileuri);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearPictureInfo_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearPictureInfo_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearPictureInfo_new00_local);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Cocos2dRenderer","Nuclear::Cocos2dRenderer","Nuclear::Renderer",tolua_collect_Nuclear__Cocos2dRenderer);
   #else
   tolua_cclass(tolua_S,"Cocos2dRenderer","Nuclear::Cocos2dRenderer","Nuclear::Renderer",NULL);
   #endif
   tolua_beginmodule(tolua_S,"Cocos2dRenderer");
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_Cocos2dRenderer_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_Cocos2dRenderer_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_Cocos2dRenderer_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_Cocos2dRenderer_delete00);
    tolua_function(tolua_S,"Create",tolua_engineWin32_Nuclear_Cocos2dRenderer_Create00);
    tolua_function(tolua_S,"Destroy",tolua_engineWin32_Nuclear_Cocos2dRenderer_Destroy00);
    tolua_function(tolua_S,"IsTextureEtc",tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureEtc00);
    tolua_function(tolua_S,"GetDisplayMode",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetDisplayMode00);
    tolua_function(tolua_S,"SetScissorRect",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetScissorRect00);
    tolua_function(tolua_S,"GetBackBuffer",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetBackBuffer00);
    tolua_function(tolua_S,"DrawLine",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine00);
    tolua_function(tolua_S,"DrawLine",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawLine01);
    tolua_function(tolua_S,"DrawTriangle",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangle00);
    tolua_function(tolua_S,"DrawBox",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox00);
    tolua_function(tolua_S,"DrawBox",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBox01);
    tolua_function(tolua_S,"DrawEllipse",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipse00);
    tolua_function(tolua_S,"DrawFan",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawFan00);
    tolua_function(tolua_S,"DrawEllipseFan",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipseFan00);
    tolua_function(tolua_S,"DrawPolygon",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPolygon00);
    tolua_function(tolua_S,"DrawTriangles",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangles00);
    tolua_function(tolua_S,"DrawTriangleList",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleList00);
    tolua_function(tolua_S,"DrawEllipsePicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture00);
    tolua_function(tolua_S,"DrawEllipsePicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawEllipsePicture01);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture00);
    tolua_function(tolua_S,"DrawPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawPicture01);
    tolua_function(tolua_S,"FreePicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture00);
    tolua_function(tolua_S,"SelectRenderEffect",tolua_engineWin32_Nuclear_Cocos2dRenderer_SelectRenderEffect00);
    tolua_function(tolua_S,"SetShaderParam",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetShaderParam00);
    tolua_function(tolua_S,"GetRenderEffect",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect00);
    tolua_function(tolua_S,"CreateRenderTarget",tolua_engineWin32_Nuclear_Cocos2dRenderer_CreateRenderTarget00);
    tolua_function(tolua_S,"FreeRenderTarget",tolua_engineWin32_Nuclear_Cocos2dRenderer_FreeRenderTarget00);
    tolua_function(tolua_S,"PushRenderTarget",tolua_engineWin32_Nuclear_Cocos2dRenderer_PushRenderTarget00);
    tolua_function(tolua_S,"PopRenderTarget",tolua_engineWin32_Nuclear_Cocos2dRenderer_PopRenderTarget00);
    tolua_function(tolua_S,"DrawBatchPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawBatchPicture00);
    tolua_function(tolua_S,"LoadPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPicture00);
    tolua_function(tolua_S,"CachePicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_CachePicture00);
    tolua_function(tolua_S,"LoadPictureFromMem",tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromMem00);
    tolua_function(tolua_S,"GetTextData",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextData00);
    tolua_function(tolua_S,"NewPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_NewPicture00);
    tolua_function(tolua_S,"FreePicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_FreePicture01);
    tolua_function(tolua_S,"DrawText",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawText00);
    tolua_function(tolua_S,"DrawTmpText",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTmpText00);
    tolua_function(tolua_S,"IsAutoTestDevice",tolua_engineWin32_Nuclear_Cocos2dRenderer_IsAutoTestDevice00);
    tolua_function(tolua_S,"SetAutoTestDevice",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAutoTestDevice00);
    tolua_function(tolua_S,"SetAlphaBlendEnable",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendEnable00);
    tolua_function(tolua_S,"GetAlphaBlendEnable",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendEnable00);
    tolua_function(tolua_S,"SetAlphaBlendSrcType",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendSrcType00);
    tolua_function(tolua_S,"GetAlphaBlendSrcType",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendSrcType00);
    tolua_function(tolua_S,"SetAlphaBlendDstType",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetAlphaBlendDstType00);
    tolua_function(tolua_S,"GetAlphaBlendDstType",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAlphaBlendDstType00);
    tolua_function(tolua_S,"SetTextureColorBlendType",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetTextureColorBlendType00);
    tolua_function(tolua_S,"GetTextureColorBlendType",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetTextureColorBlendType00);
    tolua_function(tolua_S,"SetSeparateAlphaBlend",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetSeparateAlphaBlend00);
    tolua_function(tolua_S,"GetSeparateAlphaBlend",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetSeparateAlphaBlend00);
    tolua_function(tolua_S,"SetRenderEffect",tolua_engineWin32_Nuclear_Cocos2dRenderer_SetRenderEffect00);
    tolua_function(tolua_S,"GetRenderEffect",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetRenderEffect01);
    tolua_function(tolua_S,"DrawTriangleFan",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawTriangleFan00);
    tolua_function(tolua_S,"DrawParticles",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles00);
    tolua_function(tolua_S,"DrawParticles",tolua_engineWin32_Nuclear_Cocos2dRenderer_DrawParticles01);
    tolua_function(tolua_S,"CollectParticles",tolua_engineWin32_Nuclear_Cocos2dRenderer_CollectParticles00);
    tolua_function(tolua_S,"BatchDrawParticles",tolua_engineWin32_Nuclear_Cocos2dRenderer_BatchDrawParticles00);
    tolua_function(tolua_S,"GetPictureInfo",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo00);
    tolua_function(tolua_S,"GetPictureInfo",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureInfo01);
    tolua_function(tolua_S,"GetPictureHandle",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetPictureHandle00);
    tolua_function(tolua_S,"GetAdapterDescription",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAdapterDescription00);
    tolua_function(tolua_S,"GetAvailableTextureMem",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetAvailableTextureMem00);
    tolua_function(tolua_S,"IsTextureCapsNoPow2",tolua_engineWin32_Nuclear_Cocos2dRenderer_IsTextureCapsNoPow200);
    tolua_function(tolua_S,"GetParticleManager",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetParticleManager00);
    tolua_function(tolua_S,"GetFontManager",tolua_engineWin32_Nuclear_Cocos2dRenderer_GetFontManager00);
    tolua_function(tolua_S,"SaveTextureToFile",tolua_engineWin32_Nuclear_Cocos2dRenderer_SaveTextureToFile00);
    tolua_function(tolua_S,"DumpAllPicture",tolua_engineWin32_Nuclear_Cocos2dRenderer_DumpAllPicture00);
    tolua_function(tolua_S,"LoadPictureFromNativePath",tolua_engineWin32_Nuclear_Cocos2dRenderer_LoadPictureFromNativePath00);
    tolua_function(tolua_S,"OnResetDevice",tolua_engineWin32_Nuclear_Cocos2dRenderer_OnResetDevice00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearOctets","Nuclear::NuclearOctets","",tolua_collect_Nuclear__NuclearOctets);
   #else
   tolua_cclass(tolua_S,"NuclearOctets","Nuclear::NuclearOctets","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearOctets");
    tolua_function(tolua_S,"reserve",tolua_engineWin32_Nuclear_NuclearOctets_reserve00);
    tolua_function(tolua_S,"replace",tolua_engineWin32_Nuclear_NuclearOctets_replace00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_NuclearOctets_delete00);
    tolua_function(tolua_S,"begin",tolua_engineWin32_Nuclear_NuclearOctets_begin00);
    tolua_function(tolua_S,"end",tolua_engineWin32_Nuclear_NuclearOctets_end00);
    tolua_function(tolua_S,"constbegin",tolua_engineWin32_Nuclear_NuclearOctets_constbegin00);
    tolua_function(tolua_S,"constend",tolua_engineWin32_Nuclear_NuclearOctets_constend00);
    tolua_function(tolua_S,"size",tolua_engineWin32_Nuclear_NuclearOctets_size00);
    tolua_function(tolua_S,"capacity",tolua_engineWin32_Nuclear_NuclearOctets_capacity00);
    tolua_function(tolua_S,"clear",tolua_engineWin32_Nuclear_NuclearOctets_clear00);
    tolua_function(tolua_S,"erase",tolua_engineWin32_Nuclear_NuclearOctets_erase00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearOctets_insert00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearOctets_insert01);
    tolua_function(tolua_S,"resize",tolua_engineWin32_Nuclear_NuclearOctets_resize00);
    tolua_function(tolua_S,"clone",tolua_engineWin32_Nuclear_NuclearOctets_clone00);
    tolua_function(tolua_S,"GetRef",tolua_engineWin32_Nuclear_NuclearOctets_GetRef00);
    tolua_function(tolua_S,"SetTick",tolua_engineWin32_Nuclear_NuclearOctets_SetTick00);
    tolua_function(tolua_S,"GetTick",tolua_engineWin32_Nuclear_NuclearOctets_GetTick00);
    tolua_function(tolua_S,"dump",tolua_engineWin32_Nuclear_NuclearOctets_dump00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearBufferOctets","Nuclear::NuclearBufferOctets","Nuclear::NuclearOctets",tolua_collect_Nuclear__NuclearBufferOctets);
   #else
   tolua_cclass(tolua_S,"NuclearBufferOctets","Nuclear::NuclearBufferOctets","Nuclear::NuclearOctets",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearBufferOctets");
    tolua_function(tolua_S,"reserve",tolua_engineWin32_Nuclear_NuclearBufferOctets_reserve00);
    tolua_function(tolua_S,"replace",tolua_engineWin32_Nuclear_NuclearBufferOctets_replace00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_NuclearBufferOctets_delete00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBufferOctets_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBufferOctets_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBufferOctets_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBufferOctets_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBufferOctets_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBufferOctets_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBufferOctets_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBufferOctets_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBufferOctets_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBufferOctets_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBufferOctets_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBufferOctets_new03_local);
    tolua_function(tolua_S,"begin",tolua_engineWin32_Nuclear_NuclearBufferOctets_begin00);
    tolua_function(tolua_S,"end",tolua_engineWin32_Nuclear_NuclearBufferOctets_end00);
    tolua_function(tolua_S,"constbegin",tolua_engineWin32_Nuclear_NuclearBufferOctets_constbegin00);
    tolua_function(tolua_S,"constend",tolua_engineWin32_Nuclear_NuclearBufferOctets_constend00);
    tolua_function(tolua_S,"size",tolua_engineWin32_Nuclear_NuclearBufferOctets_size00);
    tolua_function(tolua_S,"capacity",tolua_engineWin32_Nuclear_NuclearBufferOctets_capacity00);
    tolua_function(tolua_S,"clear",tolua_engineWin32_Nuclear_NuclearBufferOctets_clear00);
    tolua_function(tolua_S,"erase",tolua_engineWin32_Nuclear_NuclearBufferOctets_erase00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearBufferOctets_insert00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearBufferOctets_insert01);
    tolua_function(tolua_S,"resize",tolua_engineWin32_Nuclear_NuclearBufferOctets_resize00);
    tolua_function(tolua_S,"clone",tolua_engineWin32_Nuclear_NuclearBufferOctets_clone00);
    tolua_function(tolua_S,"GetRef",tolua_engineWin32_Nuclear_NuclearBufferOctets_GetRef00);
    tolua_function(tolua_S,"SetTick",tolua_engineWin32_Nuclear_NuclearBufferOctets_SetTick00);
    tolua_function(tolua_S,"GetTick",tolua_engineWin32_Nuclear_NuclearBufferOctets_GetTick00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"NuclearBuffer","Nuclear::NuclearBuffer","",tolua_collect_Nuclear__NuclearBuffer);
   #else
   tolua_cclass(tolua_S,"NuclearBuffer","Nuclear::NuclearBuffer","",NULL);
   #endif
   tolua_beginmodule(tolua_S,"NuclearBuffer");
    tolua_function(tolua_S,"reserve",tolua_engineWin32_Nuclear_NuclearBuffer_reserve00);
    tolua_function(tolua_S,"replace",tolua_engineWin32_Nuclear_NuclearBuffer_replace00);
    tolua_function(tolua_S,"delete",tolua_engineWin32_Nuclear_NuclearBuffer_delete00);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBuffer_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBuffer_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBuffer_new00_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBuffer_new01);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBuffer_new01_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBuffer_new01_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBuffer_new02);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBuffer_new02_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBuffer_new02_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBuffer_new03);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBuffer_new03_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBuffer_new03_local);
    tolua_function(tolua_S,"new",tolua_engineWin32_Nuclear_NuclearBuffer_new04);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_Nuclear_NuclearBuffer_new04_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_Nuclear_NuclearBuffer_new04_local);
    tolua_function(tolua_S,"swap",tolua_engineWin32_Nuclear_NuclearBuffer_swap00);
    tolua_function(tolua_S,"normalbegin",tolua_engineWin32_Nuclear_NuclearBuffer_normalbegin00);
    tolua_function(tolua_S,"normalend",tolua_engineWin32_Nuclear_NuclearBuffer_normalend00);
    tolua_function(tolua_S,"constbegin",tolua_engineWin32_Nuclear_NuclearBuffer_constbegin00);
    tolua_function(tolua_S,"constend",tolua_engineWin32_Nuclear_NuclearBuffer_constend00);
    tolua_function(tolua_S,"size",tolua_engineWin32_Nuclear_NuclearBuffer_size00);
    tolua_function(tolua_S,"capacity",tolua_engineWin32_Nuclear_NuclearBuffer_capacity00);
    tolua_function(tolua_S,"clear",tolua_engineWin32_Nuclear_NuclearBuffer_clear00);
    tolua_function(tolua_S,"erase",tolua_engineWin32_Nuclear_NuclearBuffer_erase00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearBuffer_insert00);
    tolua_function(tolua_S,"insert",tolua_engineWin32_Nuclear_NuclearBuffer_insert01);
    tolua_function(tolua_S,"resize",tolua_engineWin32_Nuclear_NuclearBuffer_resize00);
    tolua_function(tolua_S,"dump",tolua_engineWin32_Nuclear_NuclearBuffer_dump00);
    tolua_function(tolua_S,"GetRefCount",tolua_engineWin32_Nuclear_NuclearBuffer_GetRefCount00);
    tolua_function(tolua_S,"SetTick",tolua_engineWin32_Nuclear_NuclearBuffer_SetTick00);
    tolua_function(tolua_S,"GetTick",tolua_engineWin32_Nuclear_NuclearBuffer_GetTick00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_constant(tolua_S,"XPDIR_TOP",Nuclear::XPDIR_TOP);
   tolua_constant(tolua_S,"XPDIR_TOPRIGHT",Nuclear::XPDIR_TOPRIGHT);
   tolua_constant(tolua_S,"XPDIR_RIGHT",Nuclear::XPDIR_RIGHT);
   tolua_constant(tolua_S,"XPDIR_BOTTOMRIGHT",Nuclear::XPDIR_BOTTOMRIGHT);
   tolua_constant(tolua_S,"XPDIR_BOTTOM",Nuclear::XPDIR_BOTTOM);
   tolua_constant(tolua_S,"XPDIR_BOTTOMLEFT",Nuclear::XPDIR_BOTTOMLEFT);
   tolua_constant(tolua_S,"XPDIR_LEFT",Nuclear::XPDIR_LEFT);
   tolua_constant(tolua_S,"XPDIR_TOPLEFT",Nuclear::XPDIR_TOPLEFT);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Nuclear",0);
  tolua_beginmodule(tolua_S,"Nuclear");
   tolua_function(tolua_S,"XPSinCos",tolua_engineWin32_Nuclear_XPSinCos00);
   tolua_function(tolua_S,"TORADIANS",tolua_engineWin32_Nuclear_TORADIANS00);
   tolua_function(tolua_S,"TOANGLE",tolua_engineWin32_Nuclear_TOANGLE00);
   tolua_function(tolua_S,"XPSIN",tolua_engineWin32_Nuclear_XPSIN00);
   tolua_function(tolua_S,"XPCOS",tolua_engineWin32_Nuclear_XPCOS00);
   tolua_function(tolua_S,"GetGreatestDenominator",tolua_engineWin32_Nuclear_GetGreatestDenominator00);
   tolua_function(tolua_S,"GetLowestComMultiple",tolua_engineWin32_Nuclear_GetLowestComMultiple00);
   tolua_function(tolua_S,"Cross",tolua_engineWin32_Nuclear_Cross00);
   tolua_function(tolua_S,"IsCross",tolua_engineWin32_Nuclear_IsCross00);
   tolua_function(tolua_S,"XPVec3TransformCoord",tolua_engineWin32_Nuclear_XPVec3TransformCoord00);
   tolua_function(tolua_S,"XPVec3TransformNormal",tolua_engineWin32_Nuclear_XPVec3TransformNormal00);
   tolua_function(tolua_S,"XPMatrixZero",tolua_engineWin32_Nuclear_XPMatrixZero00);
   tolua_function(tolua_S,"XPMatrixIdentity",tolua_engineWin32_Nuclear_XPMatrixIdentity00);
   tolua_function(tolua_S,"XPMatrixRotationPoint",tolua_engineWin32_Nuclear_XPMatrixRotationPoint00);
   tolua_function(tolua_S,"XPMatrixRotationOrigin",tolua_engineWin32_Nuclear_XPMatrixRotationOrigin00);
   tolua_function(tolua_S,"XPMatrixTranslation",tolua_engineWin32_Nuclear_XPMatrixTranslation00);
   tolua_function(tolua_S,"XPMatrixTranslation",tolua_engineWin32_Nuclear_XPMatrixTranslation01);
   tolua_function(tolua_S,"XPMatrixShearX",tolua_engineWin32_Nuclear_XPMatrixShearX00);
   tolua_function(tolua_S,"XPMatrixShearX",tolua_engineWin32_Nuclear_XPMatrixShearX01);
   tolua_function(tolua_S,"XPMatrixShearY",tolua_engineWin32_Nuclear_XPMatrixShearY00);
   tolua_function(tolua_S,"XPMatrixShearY",tolua_engineWin32_Nuclear_XPMatrixShearY01);
   tolua_function(tolua_S,"XPMatrixScaling",tolua_engineWin32_Nuclear_XPMatrixScaling00);
   tolua_function(tolua_S,"XPMatrixScaling",tolua_engineWin32_Nuclear_XPMatrixScaling01);
   tolua_function(tolua_S,"XPMatrixMirrorY",tolua_engineWin32_Nuclear_XPMatrixMirrorY00);
   tolua_constant(tolua_S,"XPSHAPE_TYPE_CIRCLE",Nuclear::XPSHAPE_TYPE_CIRCLE);
   tolua_constant(tolua_S,"XPSHAPE_TYPE_POLYGON",Nuclear::XPSHAPE_TYPE_POLYGON);
   tolua_function(tolua_S,"GetMaxRect",tolua_engineWin32_Nuclear_GetMaxRect00);
   tolua_function(tolua_S,"IsPower2",tolua_engineWin32_Nuclear_IsPower200);
   tolua_function(tolua_S,"PartitionRectToPower2",tolua_engineWin32_Nuclear_PartitionRectToPower200);
   tolua_function(tolua_S,"TransToDiamondRadix",tolua_engineWin32_Nuclear_TransToDiamondRadix00);
   tolua_function(tolua_S,"distance",tolua_engineWin32_Nuclear_distance00);
   tolua_function(tolua_S,"distance2",tolua_engineWin32_Nuclear_distance200);
   tolua_function(tolua_S,"DotProduct",tolua_engineWin32_Nuclear_DotProduct00);
   tolua_function(tolua_S,"VectorLength",tolua_engineWin32_Nuclear_VectorLength00);
   tolua_function(tolua_S,"Computer2VectorAngle",tolua_engineWin32_Nuclear_Computer2VectorAngle00);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"LJFM",0);
  tolua_beginmodule(tolua_S,"LJFM");
   tolua_cclass(tolua_S,"LJFMBF","LJFM::LJFMBF","LJFMUO",NULL);
   tolua_beginmodule(tolua_S,"LJFMBF");
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"LJFMFS","LJFM::LJFMFS","LJFM::LJFMUO",tolua_collect_LJFM__LJFMFS);
   #else
   tolua_cclass(tolua_S,"LJFMFS","LJFM::LJFMFS","LJFM::LJFMUO",NULL);
   #endif
   tolua_beginmodule(tolua_S,"LJFMFS");
    tolua_function(tolua_S,"new",tolua_engineWin32_LJFM_LJFMFS_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_LJFM_LJFMFS_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_LJFM_LJFMFS_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_LJFM_LJFMFS_delete00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"LJFMIF","LJFM::LJFMIF","LJFM::LJFMBF",tolua_collect_LJFM__LJFMIF);
   #else
   tolua_cclass(tolua_S,"LJFMIF","LJFM::LJFMIF","LJFM::LJFMBF",NULL);
   #endif
   tolua_beginmodule(tolua_S,"LJFMIF");
    tolua_function(tolua_S,"new",tolua_engineWin32_LJFM_LJFMIF_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_LJFM_LJFMIF_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_LJFM_LJFMIF_new00_local);
    tolua_function(tolua_S,"delete",tolua_engineWin32_LJFM_LJFMIF_delete00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"LJFMFSManager","LJFM::LJFMFSManager","",NULL);
   tolua_beginmodule(tolua_S,"LJFMFSManager");
    tolua_function(tolua_S,"GetLJFMFSManager",tolua_engineWin32_LJFM_LJFMFSManager_GetLJFMFSManager00);
    tolua_function(tolua_S,"GetFSPtr",tolua_engineWin32_LJFM_LJFMFSManager_GetFSPtr00);
    tolua_function(tolua_S,"ReleaseFSPtr",tolua_engineWin32_LJFM_LJFMFSManager_ReleaseFSPtr00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"FM_EXCL",LJFM::FM_EXCL);
   tolua_constant(tolua_S,"FM_CREAT",LJFM::FM_CREAT);
   tolua_constant(tolua_S,"FM_TRUNC",LJFM::FM_TRUNC);
   tolua_constant(tolua_S,"FA_RDONLY",LJFM::FA_RDONLY);
   tolua_constant(tolua_S,"FA_WRONLY",LJFM::FA_WRONLY);
   tolua_constant(tolua_S,"FA_RDWR",LJFM::FA_RDWR);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"LJFMF","LJFM::LJFMF","LJFM::LJFMBF",tolua_collect_LJFM__LJFMF);
   #else
   tolua_cclass(tolua_S,"LJFMF","LJFM::LJFMF","LJFM::LJFMBF",NULL);
   #endif
   tolua_beginmodule(tolua_S,"LJFMF");
    tolua_function(tolua_S,"new",tolua_engineWin32_LJFM_LJFMF_new00);
    tolua_function(tolua_S,"new_local",tolua_engineWin32_LJFM_LJFMF_new00_local);
    tolua_function(tolua_S,".call",tolua_engineWin32_LJFM_LJFMF_new00_local);
    tolua_function(tolua_S,"Open",tolua_engineWin32_LJFM_LJFMF_Open00);
    tolua_function(tolua_S,"Close",tolua_engineWin32_LJFM_LJFMF_Close00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"ShortValueFromTable",tolua_engineWin32_LJFM_ShortValueFromTable00);
   tolua_function(tolua_S,"IntValueFromTable",tolua_engineWin32_LJFM_IntValueFromTable00);
   tolua_function(tolua_S,"LongValueFromTable",tolua_engineWin32_LJFM_LongValueFromTable00);
   tolua_function(tolua_S,"DoubleValueFromTable",tolua_engineWin32_LJFM_DoubleValueFromTable00);
   tolua_function(tolua_S,"BoolValueFromTable",tolua_engineWin32_LJFM_BoolValueFromTable00);
   tolua_function(tolua_S,"StringValueFromTable",tolua_engineWin32_LJFM_StringValueFromTable00);
   tolua_function(tolua_S,"UIntValueFromTable",tolua_engineWin32_LJFM_UIntValueFromTable00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"IniFile","IniFile","",NULL);
  tolua_beginmodule(tolua_S,"IniFile");
   tolua_function(tolua_S,"read_profile_string",tolua_engineWin32_IniFile_read_profile_string00);
   tolua_function(tolua_S,"read_profile_int",tolua_engineWin32_IniFile_read_profile_int00);
   tolua_function(tolua_S,"read_profile_float",tolua_engineWin32_IniFile_read_profile_float00);
   tolua_function(tolua_S,"write_profile_string",tolua_engineWin32_IniFile_write_profile_string00);
   tolua_function(tolua_S,"getCfgFilename",tolua_engineWin32_IniFile_getCfgFilename00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"CFileUtil","CFileUtil","",NULL);
  tolua_beginmodule(tolua_S,"CFileUtil");
   tolua_function(tolua_S,"GetRootDir",tolua_engineWin32_CFileUtil_GetRootDir00);
   tolua_function(tolua_S,"MakePath",tolua_engineWin32_CFileUtil_MakePath00);
   tolua_function(tolua_S,"GetDocDir",tolua_engineWin32_CFileUtil_GetDocDir00);
   tolua_function(tolua_S,"GetCacheDir",tolua_engineWin32_CFileUtil_GetCacheDir00);
   tolua_function(tolua_S,"GetTempDir",tolua_engineWin32_CFileUtil_GetTempDir00);
   tolua_function(tolua_S,"IsCurLanguageSimpleCh",tolua_engineWin32_CFileUtil_IsCurLanguageSimpleCh00);
   tolua_function(tolua_S,"GetTotalMemory",tolua_engineWin32_CFileUtil_GetTotalMemory00);
   tolua_function(tolua_S,"GetAvailableMemory",tolua_engineWin32_CFileUtil_GetAvailableMemory00);
   tolua_function(tolua_S,"GetUsedMemory",tolua_engineWin32_CFileUtil_GetUsedMemory00);
   tolua_function(tolua_S,"CopyFileByFS",tolua_engineWin32_CFileUtil_CopyFileByFS00);
   tolua_function(tolua_S,"DelFileArrOfPath",tolua_engineWin32_CFileUtil_DelFileArrOfPath00);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"IOS_MHSD_UTILS",0);
  tolua_beginmodule(tolua_S,"IOS_MHSD_UTILS");
   tolua_function(tolua_S,"OpenURL",tolua_engineWin32_IOS_MHSD_UTILS_OpenURL00);
   tolua_function(tolua_S,"GetCurBrightness",tolua_engineWin32_IOS_MHSD_UTILS_GetCurBrightness00);
   tolua_function(tolua_S,"SetCurBrightness",tolua_engineWin32_IOS_MHSD_UTILS_SetCurBrightness00);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"core",0);
  tolua_beginmodule(tolua_S,"core");
   tolua_constant(tolua_S,"Errors",core::Errors);
   tolua_constant(tolua_S,"Warnings",core::Warnings);
   tolua_constant(tolua_S,"Standard",core::Standard);
   tolua_constant(tolua_S,"Informative",core::Informative);
   tolua_constant(tolua_S,"Insane",core::Insane);
   tolua_cclass(tolua_S,"Logger","core::Logger","",NULL);
   tolua_beginmodule(tolua_S,"Logger");
    tolua_function(tolua_S,"setLoggingLevel",tolua_engineWin32_core_Logger_setLoggingLevel00);
    tolua_function(tolua_S,"getLoggingLevel",tolua_engineWin32_core_Logger_getLoggingLevel00);
    tolua_function(tolua_S,"logLuaEvent",tolua_engineWin32_core_Logger_logLuaEvent00);
    tolua_function(tolua_S,"flurryEvent",tolua_engineWin32_core_Logger_flurryEvent00);
    tolua_function(tolua_S,"AddPassLevel",tolua_engineWin32_core_Logger_AddPassLevel00);
    tolua_function(tolua_S,"logLuaEventInt",tolua_engineWin32_core_Logger_logLuaEventInt00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"GetCoreLogger",tolua_engineWin32_core_GetCoreLogger00);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"StringCover",0);
  tolua_beginmodule(tolua_S,"StringCover");
   tolua_function(tolua_S,"randBetween",tolua_engineWin32_StringCover_randBetween00);
   tolua_function(tolua_S,"int64_tToPrecisionTime",tolua_engineWin32_StringCover_int64_tToPrecisionTime00);
   tolua_function(tolua_S,"StringToOctect",tolua_engineWin32_StringCover_StringToOctect00);
   tolua_function(tolua_S,"OctectToWString",tolua_engineWin32_StringCover_OctectToWString00);
   tolua_function(tolua_S,"getTimeStruct",tolua_engineWin32_StringCover_getTimeStruct00);
   tolua_function(tolua_S,"intToString",tolua_engineWin32_StringCover_intToString00);
   tolua_function(tolua_S,"floatToString",tolua_engineWin32_StringCover_floatToString00);
   tolua_function(tolua_S,"Replace",tolua_engineWin32_StringCover_Replace00);
   tolua_function(tolua_S,"split_string",tolua_engineWin32_StringCover_split_string00);
   tolua_function(tolua_S,"intTowstring",tolua_engineWin32_StringCover_intTowstring00);
   tolua_function(tolua_S,"strcmpByPinyin",tolua_engineWin32_StringCover_strcmpByPinyin00);
  tolua_endmodule(tolua_S);
  #ifdef __cplusplus
  tolua_cclass(tolua_S,"tm","tm","",tolua_collect_tm);
  #else
  tolua_cclass(tolua_S,"tm","tm","",NULL);
  #endif
  tolua_beginmodule(tolua_S,"tm");
   tolua_variable(tolua_S,"tm_sec",tolua_get_tm_tm_sec,tolua_set_tm_tm_sec);
   tolua_variable(tolua_S,"tm_min",tolua_get_tm_tm_min,tolua_set_tm_tm_min);
   tolua_variable(tolua_S,"tm_hour",tolua_get_tm_tm_hour,tolua_set_tm_tm_hour);
   tolua_variable(tolua_S,"tm_mday",tolua_get_tm_tm_mday,tolua_set_tm_tm_mday);
   tolua_variable(tolua_S,"tm_mon",tolua_get_tm_tm_mon,tolua_set_tm_tm_mon);
   tolua_variable(tolua_S,"tm_year",tolua_get_tm_tm_year,tolua_set_tm_tm_year);
   tolua_variable(tolua_S,"tm_wday",tolua_get_tm_tm_wday,tolua_set_tm_tm_wday);
   tolua_variable(tolua_S,"tm_yday",tolua_get_tm_tm_yday,tolua_set_tm_tm_yday);
   tolua_variable(tolua_S,"tm_isdst",tolua_get_tm_tm_isdst,tolua_set_tm_tm_isdst);
  tolua_endmodule(tolua_S);
 tolua_endmodule(tolua_S);
 return 1;
}


#if defined(LUA_VERSION_NUM) && LUA_VERSION_NUM >= 501
 TOLUA_API int luaopen_engineWin32 (lua_State* tolua_S) {
 return tolua_engineWin32_open(tolua_S);
};
#endif

